<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.7.31">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>ML Systems Textbook</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for citations */
div.csl-bib-body { }
div.csl-entry {
  clear: both;
  margin-bottom: 0em;
}
.hanging-indent div.csl-entry {
  margin-left:2em;
  text-indent:-2em;
}
div.csl-left-margin {
  min-width:2em;
  float:left;
}
div.csl-right-inline {
  margin-left:2em;
  padding-left:1em;
}
div.csl-indent {
  margin-left: 2em;
}</style>


<script src="../../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../../">
<link href="../../../contents/core/optimizations/optimizations.html" rel="next">
<link href="../../../contents/core/training/training.html" rel="prev">
<link href="../../../assets/images/icons/favicon.png" rel="icon" type="image/png">
<script src="../../../site_libs/quarto-html/quarto.js" type="module"></script>
<script src="../../../site_libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="../../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../../site_libs/quarto-html/quarto-syntax-highlighting-ae75ed80ef5b3e74590777de1ac3d8c3.css" rel="stylesheet" class="quarto-color-scheme" id="quarto-text-highlighting-styles">
<link href="../../../site_libs/quarto-html/quarto-syntax-highlighting-dark-ae75ed80ef5b3e74590777de1ac3d8c3.css" rel="stylesheet" class="quarto-color-scheme quarto-color-alternate" id="quarto-text-highlighting-styles">
<link href="../../../site_libs/quarto-html/quarto-syntax-highlighting-ae75ed80ef5b3e74590777de1ac3d8c3.css" rel="stylesheet" class="quarto-color-scheme-extra" id="quarto-text-highlighting-styles">
<script src="../../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../../site_libs/bootstrap/bootstrap-0769fbf68cc3e722256a1e1e51d908bf.min.css" rel="stylesheet" append-hash="true" class="quarto-color-scheme" id="quarto-bootstrap" data-mode="light">
<link href="../../../site_libs/bootstrap/bootstrap-dark-b3207de211d0ae0f80cf70030995c04d.min.css" rel="stylesheet" append-hash="true" class="quarto-color-scheme quarto-color-alternate" id="quarto-bootstrap" data-mode="light">
<link href="../../../site_libs/bootstrap/bootstrap-0769fbf68cc3e722256a1e1e51d908bf.min.css" rel="stylesheet" append-hash="true" class="quarto-color-scheme-extra" id="quarto-bootstrap" data-mode="light">
<link href="../../../site_libs/quarto-contrib/foldbox/foldbox.css" rel="stylesheet">
<script src="../../../site_libs/quarto-contrib/glightbox/glightbox.min.js"></script>
<link href="../../../site_libs/quarto-contrib/glightbox/glightbox.min.css" rel="stylesheet">
<link href="../../../site_libs/quarto-contrib/glightbox/lightbox.css" rel="stylesheet">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>
<script async="" src="https://www.googletagmanager.com/gtag/js?id=G-M21L0CBCVN"></script>

<script type="text/javascript">

window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'G-M21L0CBCVN', { 'anonymize_ip': true});
</script>
<script type="application/json" class="js-hypothesis-config">
{
  "theme": "clean",
  "openSidebar": false
}
</script>
<script async="" src="https://hypothes.is/embed.js"></script>
<script>
  window.document.addEventListener("DOMContentLoaded", function (_event) {
    document.body.classList.add('hypothesis-enabled');
  });
</script>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">

<script async="" src="https://www.googletagmanager.com/gtag/js?id=G-M21L0CBCVN"></script>
<script type="module" src="../../../tools/scripts/ai_menu/dist/bundle.js" defer=""></script>
<script type="module" src="../../../tools/scripts/ai_menu/dist/sqlite3-opfs-async-proxy-B_ImRJXp.js"></script>
<script type="module" src="../../../tools/scripts/ai_menu/dist/sqlite3-worker1-bundler-friendly-CbDNa4by.js"></script>
<script type="module" src="../../../tools/scripts/ai_menu/dist/worker-voUF5YDa.js"></script>
<script src="../../../assets/scripts/sidebar-auto-collapse.js" defer=""></script>
<style>
.callout-resource-exercises {
  --color1: #E0F2F1;
  --color2: #20B2AA;
}
.callout-definition {
  --color1: #F0F4F8;
  --color2: #1B4F72;
}
.callout-resource-slides {
  --color1: #E0F2F1;
  --color2: #20B2AA;
}
.callout-code {
  --color1: #F2F4F8;
  --color2: #D1D7E0;
}
.callout-quiz-answer {
  --color1: #E8F2EA;
  --color2: #4a7c59;
}
.callout-resource-videos {
  --color1: #E0F2F1;
  --color2: #20B2AA;
}
.callout-quiz-question {
  --color1: #F0F0F8;
  --color2: #5B4B8A;
}
.callout-chapter-connection {
  --color1: #FDF2F7;
  --color2: #A51C30;
}
.callout-example {
  --color1: #F0F8F6;
  --color2: #148F77;
}
</style>
<style>
details.callout-resource-exercises > summary::before {
  background-image: url("../../../assets/images/icons/callouts/icon_callout-resource-exercises.png");
}
details.callout-definition > summary::before {
  background-image: url("../../../assets/images/icons/callouts/icon_callout-definition.png");
}
details.callout-resource-slides > summary::before {
  background-image: url("../../../assets/images/icons/callouts/icon_callout-resource-slides.png");
}
details.callout-code > summary::before {
  background-image: url("../../../assets/images/icons/callouts/icon_callout-code.png");
}
details.callout-quiz-answer > summary::before {
  background-image: url("../../../assets/images/icons/callouts/icon_callout-quiz-answer.png");
}
details.callout-resource-videos > summary::before {
  background-image: url("../../../assets/images/icons/callouts/icon_callout-resource-videos.png");
}
details.callout-quiz-question > summary::before {
  background-image: url("../../../assets/images/icons/callouts/icon_callout-quiz-question.png");
}
details.callout-chapter-connection > summary::before {
  background-image: url("../../../assets/images/icons/callouts/icon_callout-chapter-connection.png");
}
details.callout-example > summary::before {
  background-image: url("../../../assets/images/icons/callouts/icon_callout-example.png");
}
</style>

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

</head>

<body class="nav-sidebar floating nav-fixed slimcontent quarto-light"><script id="quarto-html-before-body" type="application/javascript">
    const toggleBodyColorMode = (bsSheetEl) => {
      const mode = bsSheetEl.getAttribute("data-mode");
      const bodyEl = window.document.querySelector("body");
      if (mode === "dark") {
        bodyEl.classList.add("quarto-dark");
        bodyEl.classList.remove("quarto-light");
      } else {
        bodyEl.classList.add("quarto-light");
        bodyEl.classList.remove("quarto-dark");
      }
    }
    const toggleBodyColorPrimary = () => {
      const bsSheetEl = window.document.querySelector("link#quarto-bootstrap:not([rel=disabled-stylesheet])");
      if (bsSheetEl) {
        toggleBodyColorMode(bsSheetEl);
      }
    }
    const setColorSchemeToggle = (alternate) => {
      const toggles = window.document.querySelectorAll('.quarto-color-scheme-toggle');
      for (let i=0; i < toggles.length; i++) {
        const toggle = toggles[i];
        if (toggle) {
          if (alternate) {
            toggle.classList.add("alternate");
          } else {
            toggle.classList.remove("alternate");
          }
        }
      }
    };
    const toggleColorMode = (alternate) => {
      // Switch the stylesheets
      const primaryStylesheets = window.document.querySelectorAll('link.quarto-color-scheme:not(.quarto-color-alternate)');
      const alternateStylesheets = window.document.querySelectorAll('link.quarto-color-scheme.quarto-color-alternate');
      manageTransitions('#quarto-margin-sidebar .nav-link', false);
      if (alternate) {
        // note: dark is layered on light, we don't disable primary!
        enableStylesheet(alternateStylesheets);
        for (const sheetNode of alternateStylesheets) {
          if (sheetNode.id === "quarto-bootstrap") {
            toggleBodyColorMode(sheetNode);
          }
        }
      } else {
        disableStylesheet(alternateStylesheets);
        enableStylesheet(primaryStylesheets)
        toggleBodyColorPrimary();
      }
      manageTransitions('#quarto-margin-sidebar .nav-link', true);
      // Switch the toggles
      setColorSchemeToggle(alternate)
      // Hack to workaround the fact that safari doesn't
      // properly recolor the scrollbar when toggling (#1455)
      if (navigator.userAgent.indexOf('Safari') > 0 && navigator.userAgent.indexOf('Chrome') == -1) {
        manageTransitions("body", false);
        window.scrollTo(0, 1);
        setTimeout(() => {
          window.scrollTo(0, 0);
          manageTransitions("body", true);
        }, 40);
      }
    }
    const disableStylesheet = (stylesheets) => {
      for (let i=0; i < stylesheets.length; i++) {
        const stylesheet = stylesheets[i];
        stylesheet.rel = 'disabled-stylesheet';
      }
    }
    const enableStylesheet = (stylesheets) => {
      for (let i=0; i < stylesheets.length; i++) {
        const stylesheet = stylesheets[i];
        if(stylesheet.rel !== 'stylesheet') { // for Chrome, which will still FOUC without this check
          stylesheet.rel = 'stylesheet';
        }
      }
    }
    const manageTransitions = (selector, allowTransitions) => {
      const els = window.document.querySelectorAll(selector);
      for (let i=0; i < els.length; i++) {
        const el = els[i];
        if (allowTransitions) {
          el.classList.remove('notransition');
        } else {
          el.classList.add('notransition');
        }
      }
    }
    const isFileUrl = () => {
      return window.location.protocol === 'file:';
    }
    const hasAlternateSentinel = () => {
      let styleSentinel = getColorSchemeSentinel();
      if (styleSentinel !== null) {
        return styleSentinel === "alternate";
      } else {
        return false;
      }
    }
    const setStyleSentinel = (alternate) => {
      const value = alternate ? "alternate" : "default";
      if (!isFileUrl()) {
        window.localStorage.setItem("quarto-color-scheme", value);
      } else {
        localAlternateSentinel = value;
      }
    }
    const getColorSchemeSentinel = () => {
      if (!isFileUrl()) {
        const storageValue = window.localStorage.getItem("quarto-color-scheme");
        return storageValue != null ? storageValue : localAlternateSentinel;
      } else {
        return localAlternateSentinel;
      }
    }
    const toggleGiscusIfUsed = (isAlternate, darkModeDefault) => {
      const baseTheme = document.querySelector('#giscus-base-theme')?.value ?? 'light';
      const alternateTheme = document.querySelector('#giscus-alt-theme')?.value ?? 'dark';
      let newTheme = '';
      if(authorPrefersDark) {
        newTheme = isAlternate ? baseTheme : alternateTheme;
      } else {
        newTheme = isAlternate ? alternateTheme : baseTheme;
      }
      const changeGiscusTheme = () => {
        // From: https://github.com/giscus/giscus/issues/336
        const sendMessage = (message) => {
          const iframe = document.querySelector('iframe.giscus-frame');
          if (!iframe) return;
          iframe.contentWindow.postMessage({ giscus: message }, 'https://giscus.app');
        }
        sendMessage({
          setConfig: {
            theme: newTheme
          }
        });
      }
      const isGiscussLoaded = window.document.querySelector('iframe.giscus-frame') !== null;
      if (isGiscussLoaded) {
        changeGiscusTheme();
      }
    };
    const authorPrefersDark = false;
    const darkModeDefault = authorPrefersDark;
      document.querySelector('link#quarto-text-highlighting-styles.quarto-color-scheme-extra').rel = 'disabled-stylesheet';
      document.querySelector('link#quarto-bootstrap.quarto-color-scheme-extra').rel = 'disabled-stylesheet';
    let localAlternateSentinel = darkModeDefault ? 'alternate' : 'default';
    // Dark / light mode switch
    window.quartoToggleColorScheme = () => {
      // Read the current dark / light value
      let toAlternate = !hasAlternateSentinel();
      toggleColorMode(toAlternate);
      setStyleSentinel(toAlternate);
      toggleGiscusIfUsed(toAlternate, darkModeDefault);
      window.dispatchEvent(new Event('resize'));
    };
    // Switch to dark mode if need be
    if (hasAlternateSentinel()) {
      toggleColorMode(true);
    } else {
      toggleColorMode(false);
    }
  </script>

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-md " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a href="../../../index.html" class="navbar-brand navbar-brand-logo">
    <img src="../../../assets/images/icons/favicon.png" alt="" class="navbar-logo">
    </a>
    <a class="navbar-brand" href="../../../index.html">
    <span class="navbar-title">Machine Learning Systems</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item">
    <a class="nav-link active" href="../../../contents/labs/labs.html" aria-current="page"> <i class="bi bi-code" role="img">
</i> 
<span class="menu-text">Labs</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../../contents/labs/kits.html"> <i class="bi bi-box" role="img">
</i> 
<span class="menu-text">Kits</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="https://mlsysbook.ai/pdf" target="_blank"> <i class="bi bi-file-pdf" role="img">
</i> 
<span class="menu-text">PDF</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="https://mlsysbook.ai/epub" target="_blank"> <i class="bi bi-book" role="img">
</i> 
<span class="menu-text">EPUB</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="https://github.com/harvard-edge/cs249r_book" target="_blank"> <i class="bi bi-star" role="img">
</i> 
<span class="menu-text">Star</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="https://opencollective.com/mlsysbook" target="_blank"> <i class="bi bi-heart" role="img">
</i> 
<span class="menu-text">Support</span></a>
  </li>  
  <li class="nav-item dropdown ">
    <a class="nav-link dropdown-toggle" href="#" id="nav-menu-github" role="link" data-bs-toggle="dropdown" aria-expanded="false">
      <i class="bi bi-github" role="img">
</i> 
 <span class="menu-text">GitHub</span>
    </a>
    <ul class="dropdown-menu dropdown-menu-end" aria-labelledby="nav-menu-github">    
        <li>
    <a class="dropdown-item" href="https://github.com/harvard-edge/cs249r_book" target="_blank"><i class="bi bi-pencil" role="img">
</i> 
 <span class="dropdown-text">Edit this page</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="https://github.com/harvard-edge/cs249r_book/issues/new" target="_blank"><i class="bi bi-bug" role="img">
</i> 
 <span class="dropdown-text">Report an issue</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="https://github.com/harvard-edge/cs249r_book/discussions" target="_blank"><i class="bi bi-chat" role="img">
</i> 
 <span class="dropdown-text">Discussions</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="https://github.com/harvard-edge/cs249r_book" target="_blank"><i class="bi bi-code" role="img">
</i> 
 <span class="dropdown-text">View source</span></a>
  </li>  
    </ul>
  </li>
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
  <a href="" class="quarto-color-scheme-toggle quarto-navigation-tool  px-1" onclick="window.quartoToggleColorScheme(); return false;" title="Toggle dark mode"><i class="bi"></i></a>
</div>
      </div> <!-- /container-fluid -->
    </nav>
  <nav class="quarto-secondary-nav">
    <div class="container-fluid d-flex">
      <button type="button" class="quarto-btn-toggle btn" data-bs-toggle="collapse" role="button" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
        <i class="bi bi-layout-text-sidebar-reverse"></i>
      </button>
        <nav class="quarto-page-breadcrumbs" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="../../../contents/core/efficient_ai/efficient_ai.html">Performance Engineering</a></li><li class="breadcrumb-item"><a href="../../../contents/core/efficient_ai/efficient_ai.html">Efficient AI</a></li></ol></nav>
        <a class="flex-grow-1" role="navigation" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">      
        </a>
    </div>
  </nav>
  <div id="quarto-announcement" data-announcement-id="232692330cd6951db05a2d53296deb1e" class="alert alert-primary hidden"><i class="bi bi-megaphone quarto-announcement-icon"></i><div class="quarto-announcement-content">
<p style="margin: 0 0 12px 0; padding: 8px 12px; background: rgba(255,193,7,0.2); border: 1px solid #ffc107; border-radius: 4px; font-weight: 600;"><i class="bi bi-exclamation-triangle-fill" style="margin-right: 6px; color: #856404;"></i><strong>🚧 DEVELOPMENT PREVIEW</strong> - Built from dev@<code style="background: rgba(0,0,0,0.1); padding: 2px 4px; border-radius: 3px; font-size: 0.9em;">c77b1d4f</code> • 2025-10-24 23:06 UTC • <a href="https://mlsysbook.ai" style="color: #856404; text-decoration: underline;"><em>Stable version →</em></a></p>
<p>🎉 <strong>Coming 2026:</strong> <em>Machine Learning Systems</em> will be published by <strong>MIT Press</strong>. <a href="https://www.linkedin.com/posts/vijay-janapa-reddi-63a6a173_tinyml-tikz-ai-activity-7338324711145136128-6WU-?utm_source=share&amp;utm_medium=member_desktop&amp;rcm=ACoAAA-V7E4BcYtyZgLSeGhXC2t9jRSlmazfp-I">See the news →</a><br></p>
<p>✨ <strong>Enhanced Content:</strong> Major improvements to chapters, new examples, and more! <a href="../../../contents/frontmatter/changelog/changelog.html">See changelog →</a><br></p>
<p>🚀 <strong>Sneak Peek:</strong> <a href="https://mlsysbook.github.io/TinyTorch/intro.html">Tiny🔥Torch</a>. Exercises to build your own machine learning system from scratch!<br></p>
<p>📦 <strong>New Hardware:</strong> <a href="../../../contents/labs/kits.html">Seeed TinyML Kit</a>. Latest hands-on learning platform.</p>
</div><i class="bi bi-x-lg quarto-announcement-action" style="display: none;"></i></div>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse collapse-horizontal quarto-sidebar-collapse-item sidebar-navigation floating overflow-auto">
    <div class="sidebar-menu-container"> 
    <ul class="list-unstyled mt-1">
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Homepage</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../contents/frontmatter/foreword.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Foreword</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../contents/frontmatter/about/about.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">About the Book</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../contents/frontmatter/changelog/changelog.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Book Changelog</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../contents/frontmatter/acknowledgements/acknowledgements.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Acknowledgements</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../contents/frontmatter/socratiq/socratiq.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">SocratiQ AI</span></a>
  </div>
</li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-1" role="navigation" aria-expanded="true">
 <span class="menu-text">Systems Foundations</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-1" role="navigation" aria-expanded="true" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-1" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../contents/core/introduction/introduction.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Introduction</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../contents/core/ml_systems/ml_systems.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">ML Systems</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../contents/core/dl_primer/dl_primer.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">DL Primer</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../contents/core/dnn_architectures/dnn_architectures.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">DNN Architectures</span></a>
  </div>
</li>
      </ul>
  </li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-2" role="navigation" aria-expanded="true">
 <span class="menu-text">Design Principles</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-2" role="navigation" aria-expanded="true" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-2" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../contents/core/workflow/workflow.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">AI Workflow</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../contents/core/data_engineering/data_engineering.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Data Engineering</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../contents/core/frameworks/frameworks.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">AI Frameworks</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../contents/core/training/training.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">AI Training</span></a>
  </div>
</li>
      </ul>
  </li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-3" role="navigation" aria-expanded="true">
 <span class="menu-text">Performance Engineering</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-3" role="navigation" aria-expanded="true" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-3" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../contents/core/efficient_ai/efficient_ai.html" class="sidebar-item-text sidebar-link active">
 <span class="menu-text">Efficient AI</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../contents/core/optimizations/optimizations.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Model Optimizations</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../contents/core/hw_acceleration/hw_acceleration.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">AI Acceleration</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../contents/core/benchmarking/benchmarking.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Benchmarking AI</span></a>
  </div>
</li>
      </ul>
  </li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-4" role="navigation" aria-expanded="true">
 <span class="menu-text">Robust Deployment</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-4" role="navigation" aria-expanded="true" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-4" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../contents/core/ops/ops.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">ML Operations</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../contents/core/ondevice_learning/ondevice_learning.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">On-Device Learning</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../contents/core/privacy_security/privacy_security.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Security &amp; Privacy</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../contents/core/robust_ai/robust_ai.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Robust AI</span></a>
  </div>
</li>
      </ul>
  </li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-5" role="navigation" aria-expanded="true">
 <span class="menu-text">Trustworthy Systems</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-5" role="navigation" aria-expanded="true" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-5" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../contents/core/responsible_ai/responsible_ai.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Responsible AI</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../contents/core/sustainable_ai/sustainable_ai.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Sustainable AI</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../contents/core/ai_for_good/ai_for_good.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">AI for Good</span></a>
  </div>
</li>
      </ul>
  </li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-6" role="navigation" aria-expanded="true">
 <span class="menu-text">Frontiers of ML Systems</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-6" role="navigation" aria-expanded="true" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-6" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../contents/core/frontiers/frontiers.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">AGI Systems</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../contents/core/conclusion/conclusion.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Conclusion</span></a>
  </div>
</li>
      </ul>
  </li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-7" role="navigation" aria-expanded="true">
 <span class="menu-text">Hands-on Labs</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-7" role="navigation" aria-expanded="true" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-7" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../contents/labs/labs.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Getting Started</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../contents/labs/kits.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Hardware Kits</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../contents/labs/ide_setup.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">IDE Setup</span></a>
  </div>
</li>
      </ul>
  </li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-8" role="navigation" aria-expanded="true">
 <span class="menu-text">Arduino</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-8" role="navigation" aria-expanded="true" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-8" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../contents/labs/arduino/nicla_vision/nicla_vision.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Overview</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../contents/labs/arduino/nicla_vision/setup/setup.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Setup</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../contents/labs/arduino/nicla_vision/image_classification/image_classification.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Image Classification</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../contents/labs/arduino/nicla_vision/object_detection/object_detection.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Object Detection</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../contents/labs/arduino/nicla_vision/kws/kws.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Keyword Spotting (KWS)</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../contents/labs/arduino/nicla_vision/motion_classification/motion_classification.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Motion Classification and Anomaly Detection</span></a>
  </div>
</li>
      </ul>
  </li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-9" role="navigation" aria-expanded="true">
 <span class="menu-text">Seeed XIAO ESP32S3</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-9" role="navigation" aria-expanded="true" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-9" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../contents/labs/seeed/xiao_esp32s3/xiao_esp32s3.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Overview</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../contents/labs/seeed/xiao_esp32s3/setup/setup.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Setup</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../contents/labs/seeed/xiao_esp32s3/image_classification/image_classification.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Image Classification</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../contents/labs/seeed/xiao_esp32s3/object_detection/object_detection.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Object Detection</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../contents/labs/seeed/xiao_esp32s3/kws/kws.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Keyword Spotting (KWS)</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../contents/labs/seeed/xiao_esp32s3/motion_classification/motion_classification.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Motion Classification and Anomaly Detection</span></a>
  </div>
</li>
      </ul>
  </li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-10" role="navigation" aria-expanded="true">
 <span class="menu-text">Grove Vision</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-10" role="navigation" aria-expanded="true" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-10" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../contents/labs/seeed/grove_vision_ai_v2/grove_vision_ai_v2.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Overview</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../contents/labs/seeed/grove_vision_ai_v2/setup_and_no_code_apps/setup_and_no_code_apps.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Setup and No-Code Applications</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../contents/labs/seeed/grove_vision_ai_v2/image_classification/image_classification.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Image Classification</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../contents/labs/seeed/grove_vision_ai_v2/object_detection/object_detection.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Object Detection</span></a>
  </div>
</li>
      </ul>
  </li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-11" role="navigation" aria-expanded="true">
 <span class="menu-text">Raspberry Pi</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-11" role="navigation" aria-expanded="true" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-11" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../contents/labs/raspi/raspi.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Overview</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../contents/labs/raspi/setup/setup.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Setup</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../contents/labs/raspi/image_classification/image_classification.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Image Classification</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../contents/labs/raspi/object_detection/object_detection.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Object Detection</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../contents/labs/raspi/llm/llm.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Small Language Models (SLM)</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../contents/labs/raspi/vlm/vlm.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Vision-Language Models (VLM)</span></a>
  </div>
</li>
      </ul>
  </li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-12" role="navigation" aria-expanded="true">
 <span class="menu-text">Shared</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-12" role="navigation" aria-expanded="true" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-12" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../contents/labs/shared/shared.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Overview</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../contents/labs/shared/kws_feature_eng/kws_feature_eng.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">KWS Feature Engineering</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../contents/labs/shared/dsp_spectral_features_block/dsp_spectral_features_block.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">DSP Spectral Features</span></a>
  </div>
</li>
      </ul>
  </li>
        <li class="px-0"><hr class="sidebar-divider hi "></li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-13" role="navigation" aria-expanded="true">
 <span class="menu-text">Glossary</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-13" role="navigation" aria-expanded="true" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-13" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../contents/backmatter/glossary/glossary.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Complete Glossary</span></a>
  </div>
</li>
      </ul>
  </li>
    </ul>
    </div>
</nav>
<div id="quarto-sidebar-glass" class="quarto-sidebar-collapse-item" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item"></div>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active" data-toc-expanded="99">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#sec-efficient-ai" id="toc-sec-efficient-ai" class="nav-link active" data-scroll-target="#sec-efficient-ai">Efficient AI</a>
  <ul>
  <li><a href="#purpose" id="toc-purpose" class="nav-link" data-scroll-target="#purpose">Purpose</a></li>
  <li><a href="#sec-efficient-ai-efficiency-imperative-d65c" id="toc-sec-efficient-ai-efficiency-imperative-d65c" class="nav-link" data-scroll-target="#sec-efficient-ai-efficiency-imperative-d65c">The Efficiency Imperative</a></li>
  <li><a href="#sec-efficient-ai-defining-system-efficiency-a4b7" id="toc-sec-efficient-ai-defining-system-efficiency-a4b7" class="nav-link" data-scroll-target="#sec-efficient-ai-defining-system-efficiency-a4b7">Defining System Efficiency</a>
  <ul class="collapse">
  <li><a href="#sec-efficient-ai-efficiency-interdependencies-5d69" id="toc-sec-efficient-ai-efficiency-interdependencies-5d69" class="nav-link" data-scroll-target="#sec-efficient-ai-efficiency-interdependencies-5d69">Efficiency Interdependencies</a></li>
  </ul></li>
  <li><a href="#sec-efficient-ai-ai-scaling-laws-a043" id="toc-sec-efficient-ai-ai-scaling-laws-a043" class="nav-link" data-scroll-target="#sec-efficient-ai-ai-scaling-laws-a043">AI Scaling Laws</a>
  <ul class="collapse">
  <li><a href="#sec-efficient-ai-empirical-evidence-scaling-laws-0105" id="toc-sec-efficient-ai-empirical-evidence-scaling-laws-0105" class="nav-link" data-scroll-target="#sec-efficient-ai-empirical-evidence-scaling-laws-0105">Empirical Evidence for Scaling Laws</a></li>
  <li><a href="#sec-efficient-ai-computeoptimal-resource-allocation-541a" id="toc-sec-efficient-ai-computeoptimal-resource-allocation-541a" class="nav-link" data-scroll-target="#sec-efficient-ai-computeoptimal-resource-allocation-541a">Compute-Optimal Resource Allocation</a></li>
  <li><a href="#sec-efficient-ai-mathematical-foundations-operational-regimes-9afe" id="toc-sec-efficient-ai-mathematical-foundations-operational-regimes-9afe" class="nav-link" data-scroll-target="#sec-efficient-ai-mathematical-foundations-operational-regimes-9afe">Mathematical Foundations and Operational Regimes</a>
  <ul class="collapse">
  <li><a href="#sec-efficient-ai-resourceconstrained-scaling-regimes-062d" id="toc-sec-efficient-ai-resourceconstrained-scaling-regimes-062d" class="nav-link" data-scroll-target="#sec-efficient-ai-resourceconstrained-scaling-regimes-062d">Resource-Constrained Scaling Regimes</a></li>
  <li><a href="#sec-efficient-ai-datalimited-scaling-regimes-ba1d" id="toc-sec-efficient-ai-datalimited-scaling-regimes-ba1d" class="nav-link" data-scroll-target="#sec-efficient-ai-datalimited-scaling-regimes-ba1d">Data-Limited Scaling Regimes</a></li>
  <li><a href="#sec-efficient-ai-temporal-scaling-regimes-e118" id="toc-sec-efficient-ai-temporal-scaling-regimes-e118" class="nav-link" data-scroll-target="#sec-efficient-ai-temporal-scaling-regimes-e118">Temporal Scaling Regimes</a></li>
  </ul></li>
  <li><a href="#sec-efficient-ai-practical-applications-system-design-5c97" id="toc-sec-efficient-ai-practical-applications-system-design-5c97" class="nav-link" data-scroll-target="#sec-efficient-ai-practical-applications-system-design-5c97">Practical Applications in System Design</a></li>
  <li><a href="#sec-efficient-ai-sustainability-cost-implications-0473" id="toc-sec-efficient-ai-sustainability-cost-implications-0473" class="nav-link" data-scroll-target="#sec-efficient-ai-sustainability-cost-implications-0473">Sustainability and Cost Implications</a></li>
  <li><a href="#sec-efficient-ai-scaling-law-breakdown-conditions-1f8c" id="toc-sec-efficient-ai-scaling-law-breakdown-conditions-1f8c" class="nav-link" data-scroll-target="#sec-efficient-ai-scaling-law-breakdown-conditions-1f8c">Scaling Law Breakdown Conditions</a></li>
  <li><a href="#sec-efficient-ai-integrating-efficiency-scaling-a513" id="toc-sec-efficient-ai-integrating-efficiency-scaling-a513" class="nav-link" data-scroll-target="#sec-efficient-ai-integrating-efficiency-scaling-a513">Integrating Efficiency with Scaling</a></li>
  </ul></li>
  <li><a href="#sec-efficient-ai-efficiency-framework-c0de" id="toc-sec-efficient-ai-efficiency-framework-c0de" class="nav-link" data-scroll-target="#sec-efficient-ai-efficiency-framework-c0de">The Efficiency Framework</a>
  <ul class="collapse">
  <li><a href="#sec-efficient-ai-multidimensional-efficiency-synergies-ea04" id="toc-sec-efficient-ai-multidimensional-efficiency-synergies-ea04" class="nav-link" data-scroll-target="#sec-efficient-ai-multidimensional-efficiency-synergies-ea04">Multi-Dimensional Efficiency Synergies</a></li>
  <li><a href="#sec-efficient-ai-achieving-algorithmic-efficiency-ef15" id="toc-sec-efficient-ai-achieving-algorithmic-efficiency-ef15" class="nav-link" data-scroll-target="#sec-efficient-ai-achieving-algorithmic-efficiency-ef15">Achieving Algorithmic Efficiency</a>
  <ul class="collapse">
  <li><a href="#sec-efficient-ai-model-compression-fundamentals-bcc3" id="toc-sec-efficient-ai-model-compression-fundamentals-bcc3" class="nav-link" data-scroll-target="#sec-efficient-ai-model-compression-fundamentals-bcc3">Model Compression Fundamentals</a></li>
  <li><a href="#sec-efficient-ai-hardwarealgorithm-codesign-67e8" id="toc-sec-efficient-ai-hardwarealgorithm-codesign-67e8" class="nav-link" data-scroll-target="#sec-efficient-ai-hardwarealgorithm-codesign-67e8">Hardware-Algorithm Co-Design</a></li>
  <li><a href="#sec-efficient-ai-architectural-innovation-efficiency-7dd9" id="toc-sec-efficient-ai-architectural-innovation-efficiency-7dd9" class="nav-link" data-scroll-target="#sec-efficient-ai-architectural-innovation-efficiency-7dd9">Architectural Innovation for Efficiency</a></li>
  <li><a href="#sec-efficient-ai-parameterefficient-adaptation-1bce" id="toc-sec-efficient-ai-parameterefficient-adaptation-1bce" class="nav-link" data-scroll-target="#sec-efficient-ai-parameterefficient-adaptation-1bce">Parameter-Efficient Adaptation</a></li>
  </ul></li>
  <li><a href="#sec-efficient-ai-compute-efficiency-745c" id="toc-sec-efficient-ai-compute-efficiency-745c" class="nav-link" data-scroll-target="#sec-efficient-ai-compute-efficiency-745c">Compute Efficiency</a>
  <ul class="collapse">
  <li><a href="#sec-efficient-ai-cpus-ai-accelerators-a8d7" id="toc-sec-efficient-ai-cpus-ai-accelerators-a8d7" class="nav-link" data-scroll-target="#sec-efficient-ai-cpus-ai-accelerators-a8d7">From CPUs to AI Accelerators</a></li>
  <li><a href="#sec-efficient-ai-sustainable-computing-energy-awareness-d77a" id="toc-sec-efficient-ai-sustainable-computing-energy-awareness-d77a" class="nav-link" data-scroll-target="#sec-efficient-ai-sustainable-computing-energy-awareness-d77a">Sustainable Computing and Energy Awareness</a></li>
  <li><a href="#sec-efficient-ai-production-deployment-patterns-208a" id="toc-sec-efficient-ai-production-deployment-patterns-208a" class="nav-link" data-scroll-target="#sec-efficient-ai-production-deployment-patterns-208a">Production Deployment Patterns</a></li>
  </ul></li>
  <li><a href="#sec-efficient-ai-data-efficiency-a3ad" id="toc-sec-efficient-ai-data-efficiency-a3ad" class="nav-link" data-scroll-target="#sec-efficient-ai-data-efficiency-a3ad">Data Efficiency</a>
  <ul class="collapse">
  <li><a href="#sec-efficient-ai-maximizing-learning-limited-data-2885" id="toc-sec-efficient-ai-maximizing-learning-limited-data-2885" class="nav-link" data-scroll-target="#sec-efficient-ai-maximizing-learning-limited-data-2885">Maximizing Learning from Limited Data</a></li>
  </ul></li>
  </ul></li>
  <li><a href="#sec-efficient-ai-realworld-efficiency-strategies-8387" id="toc-sec-efficient-ai-realworld-efficiency-strategies-8387" class="nav-link" data-scroll-target="#sec-efficient-ai-realworld-efficiency-strategies-8387">Real-World Efficiency Strategies</a>
  <ul class="collapse">
  <li><a href="#sec-efficient-ai-contextspecific-efficiency-requirements-47e6" id="toc-sec-efficient-ai-contextspecific-efficiency-requirements-47e6" class="nav-link" data-scroll-target="#sec-efficient-ai-contextspecific-efficiency-requirements-47e6">Context-Specific Efficiency Requirements</a></li>
  <li><a href="#sec-efficient-ai-scalability-sustainability-4d30" id="toc-sec-efficient-ai-scalability-sustainability-4d30" class="nav-link" data-scroll-target="#sec-efficient-ai-scalability-sustainability-4d30">Scalability and Sustainability</a></li>
  </ul></li>
  <li><a href="#sec-efficient-ai-efficiency-tradeoffs-challenges-946d" id="toc-sec-efficient-ai-efficiency-tradeoffs-challenges-946d" class="nav-link" data-scroll-target="#sec-efficient-ai-efficiency-tradeoffs-challenges-946d">Efficiency Trade-offs and Challenges</a>
  <ul class="collapse">
  <li><a href="#sec-efficient-ai-fundamental-sources-efficiency-tradeoffs-d16f" id="toc-sec-efficient-ai-fundamental-sources-efficiency-tradeoffs-d16f" class="nav-link" data-scroll-target="#sec-efficient-ai-fundamental-sources-efficiency-tradeoffs-d16f">Fundamental Sources of Efficiency Trade-offs</a>
  <ul class="collapse">
  <li><a href="#sec-efficient-ai-algorithmic-efficiency-vs-compute-requirements-83a7" id="toc-sec-efficient-ai-algorithmic-efficiency-vs-compute-requirements-83a7" class="nav-link" data-scroll-target="#sec-efficient-ai-algorithmic-efficiency-vs-compute-requirements-83a7">Algorithmic Efficiency vs.&nbsp;Compute Requirements</a></li>
  <li><a href="#sec-efficient-ai-compute-efficiency-vs-realtime-needs-a269" id="toc-sec-efficient-ai-compute-efficiency-vs-realtime-needs-a269" class="nav-link" data-scroll-target="#sec-efficient-ai-compute-efficiency-vs-realtime-needs-a269">Compute Efficiency vs.&nbsp;Real-Time Needs</a></li>
  <li><a href="#sec-efficient-ai-data-efficiency-vs-model-generalization-044a" id="toc-sec-efficient-ai-data-efficiency-vs-model-generalization-044a" class="nav-link" data-scroll-target="#sec-efficient-ai-data-efficiency-vs-model-generalization-044a">Data Efficiency vs.&nbsp;Model Generalization</a></li>
  </ul></li>
  <li><a href="#sec-efficient-ai-recurring-tradeoff-patterns-practice-c205" id="toc-sec-efficient-ai-recurring-tradeoff-patterns-practice-c205" class="nav-link" data-scroll-target="#sec-efficient-ai-recurring-tradeoff-patterns-practice-c205">Recurring Trade-off Patterns in Practice</a></li>
  </ul></li>
  <li><a href="#sec-efficient-ai-strategic-tradeoff-management-0ac8" id="toc-sec-efficient-ai-strategic-tradeoff-management-0ac8" class="nav-link" data-scroll-target="#sec-efficient-ai-strategic-tradeoff-management-0ac8">Strategic Trade-off Management</a>
  <ul class="collapse">
  <li><a href="#sec-efficient-ai-environmentdriven-efficiency-priorities-4057" id="toc-sec-efficient-ai-environmentdriven-efficiency-priorities-4057" class="nav-link" data-scroll-target="#sec-efficient-ai-environmentdriven-efficiency-priorities-4057">Environment-Driven Efficiency Priorities</a></li>
  <li><a href="#sec-efficient-ai-dynamic-resource-allocation-inference-d6bc" id="toc-sec-efficient-ai-dynamic-resource-allocation-inference-d6bc" class="nav-link" data-scroll-target="#sec-efficient-ai-dynamic-resource-allocation-inference-d6bc">Dynamic Resource Allocation at Inference</a></li>
  <li><a href="#sec-efficient-ai-endtoend-codesign-automated-optimization-1220" id="toc-sec-efficient-ai-endtoend-codesign-automated-optimization-1220" class="nav-link" data-scroll-target="#sec-efficient-ai-endtoend-codesign-automated-optimization-1220">End-to-End Co-Design and Automated Optimization</a></li>
  <li><a href="#sec-efficient-ai-measuring-monitoring-efficiency-tradeoffs-fd5b" id="toc-sec-efficient-ai-measuring-monitoring-efficiency-tradeoffs-fd5b" class="nav-link" data-scroll-target="#sec-efficient-ai-measuring-monitoring-efficiency-tradeoffs-fd5b">Measuring and Monitoring Efficiency Trade-offs</a></li>
  </ul></li>
  <li><a href="#sec-efficient-ai-engineering-principles-efficient-ai-1206" id="toc-sec-efficient-ai-engineering-principles-efficient-ai-1206" class="nav-link" data-scroll-target="#sec-efficient-ai-engineering-principles-efficient-ai-1206">Engineering Principles for Efficient AI</a>
  <ul class="collapse">
  <li><a href="#sec-efficient-ai-holistic-pipeline-optimization-5bcc" id="toc-sec-efficient-ai-holistic-pipeline-optimization-5bcc" class="nav-link" data-scroll-target="#sec-efficient-ai-holistic-pipeline-optimization-5bcc">Holistic Pipeline Optimization</a></li>
  <li><a href="#sec-efficient-ai-lifecycle-environment-considerations-3abc" id="toc-sec-efficient-ai-lifecycle-environment-considerations-3abc" class="nav-link" data-scroll-target="#sec-efficient-ai-lifecycle-environment-considerations-3abc">Lifecycle and Environment Considerations</a></li>
  </ul></li>
  <li><a href="#sec-efficient-ai-societal-ethical-implications-d0e5" id="toc-sec-efficient-ai-societal-ethical-implications-d0e5" class="nav-link" data-scroll-target="#sec-efficient-ai-societal-ethical-implications-d0e5">Societal and Ethical Implications</a>
  <ul class="collapse">
  <li><a href="#sec-efficient-ai-equity-access-c38d" id="toc-sec-efficient-ai-equity-access-c38d" class="nav-link" data-scroll-target="#sec-efficient-ai-equity-access-c38d">Equity and Access</a></li>
  <li><a href="#sec-efficient-ai-balancing-innovation-efficiency-demands-7a44" id="toc-sec-efficient-ai-balancing-innovation-efficiency-demands-7a44" class="nav-link" data-scroll-target="#sec-efficient-ai-balancing-innovation-efficiency-demands-7a44">Balancing Innovation with Efficiency Demands</a></li>
  <li><a href="#sec-efficient-ai-optimization-limits-20f0" id="toc-sec-efficient-ai-optimization-limits-20f0" class="nav-link" data-scroll-target="#sec-efficient-ai-optimization-limits-20f0">Optimization Limits</a>
  <ul class="collapse">
  <li><a href="#sec-efficient-ai-moores-law-case-study-5767" id="toc-sec-efficient-ai-moores-law-case-study-5767" class="nav-link" data-scroll-target="#sec-efficient-ai-moores-law-case-study-5767">Moore’s Law Case Study</a></li>
  </ul></li>
  </ul></li>
  <li><a href="#sec-efficient-ai-fallacies-pitfalls-f804" id="toc-sec-efficient-ai-fallacies-pitfalls-f804" class="nav-link" data-scroll-target="#sec-efficient-ai-fallacies-pitfalls-f804">Fallacies and Pitfalls</a></li>
  <li><a href="#sec-efficient-ai-summary-66bb" id="toc-sec-efficient-ai-summary-66bb" class="nav-link" data-scroll-target="#sec-efficient-ai-summary-66bb">Summary</a></li>
  <li><a href="#self-check-answers" id="toc-self-check-answers" class="nav-link" data-scroll-target="#self-check-answers">Self-Check Answers</a></li>
  </ul></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content page-columns page-full" id="quarto-document-content"><header id="title-block-header" class="quarto-title-block"><nav class="quarto-page-breadcrumbs quarto-title-breadcrumbs d-none d-lg-block" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="../../../contents/core/efficient_ai/efficient_ai.html">Performance Engineering</a></li><li class="breadcrumb-item"><a href="../../../contents/core/efficient_ai/efficient_ai.html">Efficient AI</a></li></ol></nav></header>





<section id="sec-efficient-ai" class="level1 page-columns page-full">
<h1>Efficient AI</h1>
<div class="{layout-narrow} page-columns page-full">

<div class="no-row-height column-margin column-container"><div class="">
<p><em>DALL·E 3 Prompt: A conceptual illustration depicting efficiency in artificial intelligence using a shipyard analogy. The scene shows a bustling shipyard where containers represent bits or bytes of data. These containers are being moved around efficiently by cranes and vehicles, symbolizing the streamlined and rapid information processing in AI systems. The shipyard is meticulously organized, illustrating the concept of optimal performance within the constraints of limited resources. In the background, ships are docked, representing different platforms and scenarios where AI is applied. The atmosphere should convey advanced technology with an underlying theme of sustainability and wide applicability.</em></p>
</div></div><p> <img src="images/png/cover_efficient_ai.png" class="img-fluid"></p>
</div>
<section id="purpose" class="level2 unnumbered">
<h2 class="unnumbered anchored" data-anchor-id="purpose">Purpose</h2>
<p><em>What key trade-offs shape the pursuit of efficiency in machine learning systems, and why must engineers balance competing objectives?</em></p>
<p>Machine learning system efficiency requires balancing trade-offs across algorithmic complexity, computational resources, and data utilization. Improvements in one dimension often degrade performance in others, creating engineering tensions that require systematic approaches. Understanding these interdependent relationships enables engineers to design systems achieving maximum performance within practical constraints of time, energy, and cost.</p>
<div class="callout callout-style-default callout-tip callout-titled" title="Learning Objectives">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Learning Objectives
</div>
</div>
<div class="callout-body-container callout-body">
<ul>
<li><p>Analyze scaling law relationships to determine optimal resource allocation strategies for computational budget, model size, and dataset requirements</p></li>
<li><p>Compare and contrast algorithmic, compute, and data efficiency trade-offs across cloud, edge, mobile, and TinyML deployment contexts</p></li>
<li><p>Evaluate machine learning systems using efficiency metrics including throughput, latency, energy consumption, and resource utilization</p></li>
<li><p>Apply compression techniques such as pruning, quantization, and knowledge distillation to optimize model performance within resource constraints</p></li>
<li><p>Design context-aware efficiency strategies by prioritizing optimization dimensions based on deployment requirements and operational constraints</p></li>
<li><p>Critique scaling-based approaches by identifying breakdown points and proposing alternative efficiency-driven solutions</p></li>
<li><p>Assess the environmental and accessibility implications of efficiency choices in machine learning system design</p></li>
</ul>
</div>
</div>
</section>
<section id="sec-efficient-ai-efficiency-imperative-d65c" class="level2 page-columns page-full">
<h2 class="anchored" data-anchor-id="sec-efficient-ai-efficiency-imperative-d65c">The Efficiency Imperative</h2>
<p>Machine learning efficiency has evolved from an afterthought to a fundamental discipline as models transitioned from simple statistical approaches to complex, resource-intensive architectures. The gap between theoretical capabilities and practical deployment has widened significantly, creating efficiency constraints that fundamentally affect system feasibility and scalability.</p>
<p>Large-scale language models exemplify this challenge. GPT-3 required training costs estimated at $4.6 million (Lambda Labs estimate) and energy consumption of 1,287 MWh <span class="citation" data-cites="Patterson_et_al_2021">(<a href="#ref-Patterson_et_al_2021" role="doc-biblioref">Patterson et al. 2021</a>)</span>. The operational requirements, including memory footprints exceeding 700GB for inference (350GB for half-precision), create deployment barriers in resource-constrained environments. These constraints reveal a tension between model expressiveness and system practicality that requires rigorous analysis and optimization strategies.</p>
<div class="no-row-height column-margin column-container"></div><p>Efficiency research extends beyond resource optimization to encompass the theoretical foundations of learning system design. Engineers must understand how algorithmic complexity, computational architectures, and data utilization strategies interact to determine system viability. These interdependencies create multi-objective optimization problems where improvements in one dimension may degrade performance in others.</p>
<p>This chapter establishes the framework for analyzing efficiency in machine learning systems within Part III’s performance engineering curriculum. The efficiency principles here inform the optimization techniques in <strong><a href="../optimizations/optimizations.html#sec-model-optimizations">Chapter 10: Model Optimizations</a></strong>, where quantization and pruning methods realize algorithmic efficiency goals, the hardware acceleration strategies in <strong><a href="../hw_acceleration/hw_acceleration.html#sec-ai-acceleration">Chapter 11: AI Acceleration</a></strong> that maximize compute efficiency, and the measurement methodologies in <strong><a href="../benchmarking/benchmarking.html#sec-benchmarking-ai">Chapter 12: Benchmarking AI</a></strong> for validating efficiency improvements.</p>
<div id="quiz-question-sec-efficient-ai-efficiency-imperative-d65c" class="callout callout-quiz-question">
<details class="callout-quiz-question fbx-default closebutton"><summary><strong>Self-Check: Question 1.1</strong></summary><div>
<ol type="1">
<li><p>What is a major challenge in deploying large-scale language models like GPT-3?</p>
<ol type="a">
<li>Lack of data availability</li>
<li>High training costs and energy consumption</li>
<li>Limited algorithmic complexity</li>
<li>Insufficient model expressiveness</li>
</ol></li>
<li><p>Explain the tension between model expressiveness and system practicality in machine learning systems.</p></li>
<li><p>Which of the following is NOT a focus of efficiency research in machine learning systems?</p>
<ol type="a">
<li>Resource optimization</li>
<li>Algorithmic complexity</li>
<li>Data utilization strategies</li>
<li>Increasing model size indefinitely</li>
</ol></li>
</ol>
<p><a href="#quiz-answer-sec-efficient-ai-efficiency-imperative-d65c" class="question-label">See Answers →</a></p>
</div></details>
</div>
</section>
<section id="sec-efficient-ai-defining-system-efficiency-a4b7" class="level2 page-columns page-full">
<h2 class="anchored" data-anchor-id="sec-efficient-ai-defining-system-efficiency-a4b7">Defining System Efficiency</h2>
<p>Consider building a photo search application for a smartphone. You face three competing pressures: the model must be small enough to fit in memory (an algorithmic challenge), it must run fast enough on the phone’s processor without draining the battery (a compute challenge), and it must learn from a user’s personal photos without requiring millions of examples (a data challenge). Efficient AI is the discipline of navigating these interconnected trade-offs.</p>
<p>Addressing these efficiency challenges requires coordinated optimization across three interconnected dimensions that determine system viability.</p>
<div id="callout-definition*-1.1" class="callout callout-definition" title="Definition of Machine Learning System Efficiency">
<p></p><details class="callout-definition fbx-default closebutton" open=""><summary><strong>Definition: </strong>Definition of Machine Learning System Efficiency</summary><div><strong><em>Machine Learning System Efficiency</em></strong> refers to the optimization of machine learning systems across three interconnected dimensions: <em>algorithmic efficiency</em>, <em>compute efficiency</em>, and <em>data efficiency</em>. The goal is to minimize <em>computational, memory, and energy</em> demands while maintaining or improving system performance. This efficiency ensures that machine learning systems are <em>scalable, cost-effective, and sustainable</em>, allowing adaptation to diverse deployment contexts, from <em>cloud data centers</em> to <em>edge devices</em>. Achieving system efficiency requires navigating <em>trade-offs</em> between dimensions, such as balancing <em>model complexity</em> with <em>hardware constraints</em> or reducing <em>data dependency</em> without compromising <em>generalization</em>.<p></p>
</div></details>
</div>
<p>Understanding these interdependencies is necessary for designing systems that achieve maximum performance within practical constraints. Examining how the three dimensions interact in practice reveals how scaling laws expose these constraints.</p>
<section id="sec-efficient-ai-efficiency-interdependencies-5d69" class="level3 page-columns page-full">
<h3 class="anchored" data-anchor-id="sec-efficient-ai-efficiency-interdependencies-5d69">Efficiency Interdependencies</h3>
<p>The three efficiency dimensions are deeply intertwined, creating a complex optimization landscape. Algorithmic efficiency reduces computational requirements through better algorithms and architectures, but may increase development complexity or require specialized hardware. Compute efficiency maximizes hardware utilization through optimized implementations and specialized processors, but may limit model expressiveness or require specific algorithmic approaches. Data efficiency enables learning with fewer examples through improved training procedures and data utilization, but may require more sophisticated algorithms or additional computational resources.</p>
<p>A concrete example illustrates these interconnections through the design of a photo search application for smartphones. The system must fit in 2GB memory (compute constraint), achieve acceptable accuracy with limited training data (data constraint), and complete searches within 50ms (algorithmic constraint). Optimization of any single dimension in isolation proves inadequate:</p>
<p><strong>Algorithmic Efficiency</strong> focuses on the model architecture. Using a compact vision-language model with 50 million parameters instead of a billion-parameter model reduces memory requirements from 4GB to 200MB and cuts inference time from 2 seconds to 100 milliseconds. However, accuracy decreases from 92% to 85%, necessitating careful evaluation of trade-off acceptability.</p>
<p><strong>Compute Efficiency</strong> addresses hardware utilization. The optimized model runs efficiently on smartphone processors, consuming only 10% battery per hour. Techniques like 8-bit quantization reduce computation while maintaining quality, and batch processing<a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a> handles multiple queries simultaneously. However, these optimizations necessitate algorithmic modifications to support reduced precision operations.</p>
<div class="no-row-height column-margin column-container"><div id="fn1"><p><sup>1</sup>&nbsp;<strong>Batch Processing</strong>: Processing multiple inputs together to amortize computational overhead and maximize GPU utilization. Mobile vision models achieve 3-5× speedup with batch size 8 vs.&nbsp;individual processing, but introduces 50-200ms latency as queries wait for batch completion—a classic throughput vs.&nbsp;latency trade-off in ML systems.</p></div></div><p><strong>Data Efficiency</strong> shapes how the model learns. Rather than requiring millions of labeled image-text pairs, the system leverages pre-trained foundation models and adapts using only thousands of user-specific examples. Continuous learning from user interactions provides implicit feedback without explicit labeling. This data efficiency necessitates more sophisticated algorithmic approaches and careful management of computational resources during adaptation.</p>
<p>Synergy between these dimensions produces emergent benefits: the smaller model (algorithmic efficiency) enables on-device processing (compute efficiency), which facilitates learning from private user data (data efficiency) without transmitting personal images to remote servers. This integration provides enhanced performance and privacy protection, demonstrating how efficiency enables capabilities unattainable with less efficient approaches.</p>
<p>These interdependencies appear across all deployment contexts, from cloud systems with abundant resources to edge devices with severe constraints. As illustrated in <a href="#fig-interdependece" class="quarto-xref">Figure&nbsp;1</a>, understanding these relationships is essential before examining how scaling laws reveal fundamental efficiency limits.</p>
<div id="fig-interdependece" class="quarto-float quarto-figure quarto-figure-center anchored" data-fig-env="figure" data-fig-pos="htb">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-interdependece-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<a href="0a1d2fa659071c598c859bdc07adfe7d1f646873.svg" class="lightbox" data-gallery="quarto-lightbox-gallery-1" title="Figure&nbsp;1: : Efficiency Interdependencies: The three efficiency dimensions (algorithmic, compute, and data) overlap and influence one another, creating systemic trade-offs in machine learning systems. Optimizing for one efficiency dimension often requires careful consideration of its impact on the others, shaping overall system performance and resource utilization."><img src="efficient_ai_files/mediabag/0a1d2fa659071c598c859bdc07adfe7d1f646873.svg" class="img-fluid figure-img"></a>
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-interdependece-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;1: : <strong>Efficiency Interdependencies</strong>: The three efficiency dimensions (algorithmic, compute, and data) overlap and influence one another, creating systemic trade-offs in machine learning systems. Optimizing for one efficiency dimension often requires careful consideration of its impact on the others, shaping overall system performance and resource utilization.
</figcaption>
</figure>
</div>
<p>With this understanding of efficiency dimension interactions, we can examine why brute-force scaling alone cannot address real-world efficiency requirements. Scaling laws provide the quantitative framework for understanding these limitations.</p>
<div id="quiz-question-sec-efficient-ai-defining-system-efficiency-a4b7" class="callout callout-quiz-question">
<details class="callout-quiz-question fbx-default closebutton"><summary><strong>Self-Check: Question 1.2</strong></summary><div>
<ol type="1">
<li><p>Which of the following best describes the goal of machine learning system efficiency?</p>
<ol type="a">
<li>Maximizing model accuracy regardless of resource constraints.</li>
<li>Optimizing hardware utilization without considering algorithmic complexity.</li>
<li>Focusing solely on reducing data requirements for training.</li>
<li>Minimizing computational, memory, and energy demands while maintaining or improving system performance.</li>
</ol></li>
<li><p>How do the three dimensions of efficiency (algorithmic, compute, data) interact in the design of a smartphone photo search application?</p></li>
<li><p>True or False: Improving compute efficiency always leads to better algorithmic efficiency.</p></li>
<li><p>In the context of data efficiency, which strategy is used to reduce the need for large training datasets?</p>
<ol type="a">
<li>Increasing model parameters to improve learning capacity.</li>
<li>Relying solely on explicit labeling of large datasets.</li>
<li>Using pre-trained models and adapting them with fewer examples.</li>
<li>Focusing on hardware acceleration techniques.</li>
</ol></li>
</ol>
<p><a href="#quiz-answer-sec-efficient-ai-defining-system-efficiency-a4b7" class="question-label">See Answers →</a></p>
</div></details>
</div>
</section>
</section>
<section id="sec-efficient-ai-ai-scaling-laws-a043" class="level2 page-columns page-full">
<h2 class="anchored" data-anchor-id="sec-efficient-ai-ai-scaling-laws-a043">AI Scaling Laws</h2>
<p>Machine learning systems have followed a consistent pattern: increasing model scale through parameters, training data, and computational resources typically improves performance. This empirical observation has driven progress across natural language processing, computer vision, and speech recognition, where larger models trained on extensive datasets consistently achieve state-of-the-art results.</p>
<p>These scaling laws can be seen as the quantitative expression of Richard Sutton’s “Bitter Lesson” from <strong><a href="../introduction/introduction.html#sec-introduction">Chapter 1: Introduction</a></strong>: performance in machine learning is primarily driven by leveraging general methods at massive scale. The predictable power-law relationships show <em>how</em> computation, when scaled, yields better models.</p>
<p>This scaling trajectory raises critical questions about efficiency and sustainability. As computational demands grow exponentially and data requirements increase, questions emerge regarding when scaling costs outweigh performance benefits. Researchers have developed scaling laws<a href="#fn2" class="footnote-ref" id="fnref2" role="doc-noteref"><sup>2</sup></a> that quantify how model performance relates to training resources, revealing why efficiency becomes increasingly important as systems expand in complexity.</p>
<div class="no-row-height column-margin column-container"><div id="fn2"><p><sup>2</sup>&nbsp;<strong>Scaling Laws</strong>: Empirical relationships discovered by OpenAI showing that language model performance follows predictable power-law relationships with model size (N), dataset size (D), and compute budget (C). These laws enable researchers to predict performance and optimal resource allocation before expensive training runs.</p></div></div><p>This section introduces scaling laws, examines their manifestation across different dimensions, and analyzes their implications for system design, establishing why the multi-dimensional efficiency optimization framework is a fundamental requirement.</p>
<section id="sec-efficient-ai-empirical-evidence-scaling-laws-0105" class="level3 page-columns page-full">
<h3 class="anchored" data-anchor-id="sec-efficient-ai-empirical-evidence-scaling-laws-0105">Empirical Evidence for Scaling Laws</h3>
<p>The rapid evolution in AI capabilities over the past decade exemplifies this scaling trajectory. GPT-1 (2018) contained 117 million parameters and demonstrated basic sentence completion capabilities. GPT-2 (2019) scaled to 1.5 billion parameters and achieved coherent paragraph generation. GPT-3 (2020) expanded to 175 billion parameters and demonstrated sophisticated text generation across diverse domains. Each increase in model size brought dramatically improved capabilities, but at exponentially increasing costs.</p>
<p>This pattern extends beyond language models. In computer vision, doubling neural network size typically yields consistent accuracy gains when training data increases proportionally. AlexNet (2012) had 60 million parameters, VGG-16 (2014) scaled to 138 million, and large modern vision transformers can exceed 600 million parameters. Each generation achieved better image recognition accuracy, but required proportionally more computational resources and training data.</p>
<p>The scaling hypothesis underlies this progress: larger models possess increased capacity to capture intricate data patterns, facilitating improved accuracy and generalization. However, this scaling trajectory introduces critical resource constraints. Training GPT-3 required approximately 314 sextillion<a href="#fn3" class="footnote-ref" id="fnref3" role="doc-noteref"><sup>3</sup></a> floating-point operations (314 followed by 21 zeros), equivalent to running a modern gaming PC continuously for over 350 years, at substantial financial and environmental costs.</p>
<div class="no-row-height column-margin column-container"><div id="fn3"><p><sup>3</sup>&nbsp;<strong>Sextillion</strong>: A number with 21 zeros (10²¹), representing an almost incomprehensible scale. To put this in perspective, there are estimated 10²² to 10²⁴ stars in the observable universe, making GPT-3’s training computation roughly 1/22nd of counting every star in the cosmos.</p></div></div><p>These resource demands reveal why understanding scaling laws is necessary for efficiency. <a href="#fig-compute-trends" class="quarto-xref">Figure&nbsp;2</a> shows computational demands of training state-of-the-art models escalating at an unsustainable rate, growing faster than Moore’s Law improvements in hardware.</p>
<div id="fig-compute-trends" class="quarto-float quarto-figure quarto-figure-center anchored page-columns page-full">
<figure class="quarto-float quarto-float-fig figure page-columns page-full">
<div aria-describedby="fig-compute-trends-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<a href="images/png/compute-trends.png" class="lightbox" data-gallery="quarto-lightbox-gallery-2" title="Figure&nbsp;2: Model Training Compute Trends: Model training compute is growing at faster and faster rates, especially in the recent deep learning era. Source: [@Sevilla_Heim_Ho_Besiroglu_Hobbhahn_Villalobos_2022.]"><img src="images/png/compute-trends.png" class="img-fluid figure-img"></a>
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-compute-trends-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;2: <strong>Model Training Compute Trends</strong>: Model training compute is growing at faster and faster rates, especially in the recent deep learning era. Source: <span class="citation" data-cites="Sevilla_Heim_Ho_Besiroglu_Hobbhahn_Villalobos_2022">(<a href="#ref-Sevilla_Heim_Ho_Besiroglu_Hobbhahn_Villalobos_2022" role="doc-biblioref">Sevilla et al. 2022a</a>.)</span>
</figcaption>
<div class="no-row-height column-margin column-container"><div id="ref-Sevilla_Heim_Ho_Besiroglu_Hobbhahn_Villalobos_2022" class="csl-entry" role="listitem">
Sevilla, Jaime, Lennart Heim, Anson Ho, Tamay Besiroglu, Marius Hobbhahn, and Pablo Villalobos. 2022a. <span>“Compute Trends Across Three Eras of Machine Learning.”</span> In <em>2022 International Joint Conference on Neural Networks (IJCNN)</em>, 1–8. IEEE. <a href="https://doi.org/10.1109/ijcnn55064.2022.9891914">https://doi.org/10.1109/ijcnn55064.2022.9891914</a>.
</div></div></figure>
</div>
<p>Scaling laws provide a quantitative framework for understanding these trade-offs. They reveal that model performance exhibits predictable patterns as resources increase, following power-law relationships where performance improves consistently but with diminishing returns<a href="#fn4" class="footnote-ref" id="fnref4" role="doc-noteref"><sup>4</sup></a>. These laws show that optimal resource allocation requires coordinating model size, dataset size, and computational budget rather than scaling any single dimension in isolation.</p>
<div class="no-row-height column-margin column-container"><div id="fn4"><p><sup>4</sup>&nbsp;<strong>Diminishing Returns</strong>: Economic principle where each additional input yields progressively smaller output gains. In ML, doubling compute from 1 to 2 hours might improve accuracy by 5%, but doubling from 100 to 200 hours might improve it by only 0.5%.</p></div></div><div class="callout callout-style-default callout-note callout-titled" title="Refresher: Transformer Computational Characteristics">
<div class="callout-header d-flex align-content-center" data-bs-toggle="collapse" data-bs-target=".callout-2-contents" aria-controls="callout-2" aria-expanded="false" aria-label="Toggle callout">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Refresher: Transformer Computational Characteristics
</div>
<div class="callout-btn-toggle d-inline-block border-0 py-1 ps-1 pe-0 float-end"><i class="callout-toggle"></i></div>
</div>
<div id="callout-2" class="callout-2-contents callout-collapse collapse">
<div class="callout-body-container callout-body">
<p>Recall from <strong><a href="../dnn_architectures/dnn_architectures.html#sec-dnn-architectures">Chapter 4: DNN Architectures</a></strong> that transformers process sequences using self-attention mechanisms that compute relationships between all token pairs. This architecture’s computational cost scales quadratically with sequence length, making resource allocation particularly critical for language models. The term “FLOPs” (floating-point operations) quantifies total computational work, while “tokens” represent the individual text units (typically subwords) that models process during training.</p>
</div>
</div>
</div>
</section>
<section id="sec-efficient-ai-computeoptimal-resource-allocation-541a" class="level3 page-columns page-full">
<h3 class="anchored" data-anchor-id="sec-efficient-ai-computeoptimal-resource-allocation-541a">Compute-Optimal Resource Allocation</h3>
<p>Empirical studies of large language models (LLMs) reveal a key insight: for any fixed computational budget, there exists an optimal balance between model size and dataset size (measured in tokens<a href="#fn5" class="footnote-ref" id="fnref5" role="doc-noteref"><sup>5</sup></a>) that minimizes training loss.</p>
<div class="no-row-height column-margin column-container"><div id="fn5"><p><sup>5</sup>&nbsp;<strong>Tokens</strong>: Individual units of text that language models process, created by breaking text into subword pieces using algorithms like Byte-Pair Encoding (BPE). GPT-3 trained on 300 billion tokens while PaLM used 780 billion tokens, requiring text corpora equivalent to millions of books from web crawls and digitized literature.</p></div><div id="fn6"><p><sup>6</sup>&nbsp;<strong>FLOPs</strong>: Floating-Point Operations, measuring computational work performed. Modern deep learning models require 10²²-10²⁴ FLOPs for training: GPT-3 used ~3.14 × 10²³ FLOPs (314 sextillion operations), equivalent to running a high-end gaming PC continuously for over 350 years.</p></div><div id="fn7"><p><sup>7</sup>&nbsp;<strong>Transformer</strong>: Neural network architecture introduced by Vaswani et al. <span class="citation" data-cites="vaswani2017attention">(<a href="#ref-vaswani2017attention" role="doc-biblioref">Chen et al. 2018</a>)</span> that revolutionized NLP through self-attention mechanisms. Unlike sequential RNNs, transformers enable parallel processing during training, forming the foundation of modern large language models including GPT, BERT, T5, and their derivatives.</p><div id="ref-vaswani2017attention" class="csl-entry" role="listitem">
Chen, Mia Xu, Orhan Firat, Ankur Bapna, Melvin Johnson, Wolfgang Macherey, George Foster, Llion Jones, et al. 2018. <span>“The Best of Both Worlds: Combining Recent Advances in Neural Machine Translation.”</span> In <em>Proceedings of the 56th Annual Meeting of the Association for Computational Linguistics (Volume 1: Long Papers)</em>, 5998–6008. Association for Computational Linguistics. <a href="https://doi.org/10.18653/v1/p18-1008">https://doi.org/10.18653/v1/p18-1008</a>.
</div></div><div id="fn8"><p><sup>8</sup>&nbsp;<strong>Autoregressive Models</strong>: Language models that generate text by predicting each token based on all preceding tokens in the sequence. GPT-family models exemplify this approach, generating text left-to-right with causal attention masks to ensure each position only attends to previous positions.</p></div></div><p><a href="#fig-compute-optimal" class="quarto-xref">Figure&nbsp;3</a> illustrates this principle through three related views. The left panel shows ‘IsoFLOP curves,’ where each curve corresponds to a constant number of floating-point operations (FLOPs<a href="#fn6" class="footnote-ref" id="fnref6" role="doc-noteref"><sup>6</sup></a>) during transformer<a href="#fn7" class="footnote-ref" id="fnref7" role="doc-noteref"><sup>7</sup></a> training. The valleys in these curves identify the most efficient model size for each computational budget when training autoregressive<a href="#fn8" class="footnote-ref" id="fnref8" role="doc-noteref"><sup>8</sup></a> language models. The center and right panels reveal how the optimal number of parameters and tokens scales predictably as computational budgets increase, demonstrating the necessity for coordinated scaling to maximize resource utilization.</p>
<div id="fig-compute-optimal" class="quarto-float quarto-figure quarto-figure-center anchored page-columns page-full">
<figure class="quarto-float quarto-float-fig figure page-columns page-full">
<div aria-describedby="fig-compute-optimal-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<a href="images/png/compute_optimal.png" class="lightbox" data-gallery="quarto-lightbox-gallery-3" title="Figure&nbsp;3: Optimal Compute Allocation: For fixed computational budgets, language model performance depends on balancing model size and training data volume; the left panel maps training loss across parameter counts, identifying an efficiency sweet spot for each FLOP level. The center and right panels quantify how optimal parameter counts and token requirements scale predictably with increasing compute, demonstrating the need for coordinated scaling of both model and data to maximize resource utilization in large language models. Source: [@hoffmann2022training]."><img src="images/png/compute_optimal.png" class="img-fluid figure-img"></a>
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-compute-optimal-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;3: <strong>Optimal Compute Allocation</strong>: For fixed computational budgets, language model performance depends on balancing model size and training data volume; the left panel maps training loss across parameter counts, identifying an efficiency sweet spot for each FLOP level. The center and right panels quantify how optimal parameter counts and token requirements scale predictably with increasing compute, demonstrating the need for coordinated scaling of both model and data to maximize resource utilization in large language models. Source: <span class="citation" data-cites="hoffmann2022training">(<a href="#ref-hoffmann2022training" role="doc-biblioref">Hoffmann et al. 2022</a>)</span>.
</figcaption>
<div class="no-row-height column-margin column-container"></div></figure>
</div>
<p><span class="citation" data-cites="kaplan2020scaling">Kaplan et al. (<a href="#ref-kaplan2020scaling" role="doc-biblioref">2020</a>)</span> demonstrated that transformer-based language models scale predictably with three factors: the number of model parameters, the volume of the training dataset (measured in tokens), and the total computational budget (measured in floating-point operations). When these factors are augmented proportionally, models exhibit consistent performance improvements without requiring architectural modifications or task-specific tuning.</p>
<div class="no-row-height column-margin column-container"></div><p>The practical manifestation of these patterns appears clearly in <a href="#fig-kaplan-scaling" class="quarto-xref">Figure&nbsp;4</a>, which presents test loss curves for models spanning from <span class="math inline">\(10^3\)</span> to <span class="math inline">\(10^9\)</span> parameters. The figure reveals two key insights. First, larger models demonstrate superior sample efficiency, achieving target performance levels with fewer training tokens. Second, as computational resources increase, the optimal model size correspondingly grows, with loss decreasing predictably when compute is allocated efficiently.</p>
<div id="fig-kaplan-scaling" class="quarto-float quarto-figure quarto-figure-center anchored page-columns page-full">
<figure class="quarto-float quarto-float-fig figure page-columns page-full">
<div aria-describedby="fig-kaplan-scaling-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<a href="images/png/kaplan_scaling_data_compute.png" class="lightbox" data-gallery="quarto-lightbox-gallery-4" title="Figure&nbsp;4: Scaling Laws &amp; Compute Optimality: Larger models consistently achieve better performance with increased training data and compute, but diminishing returns necessitate careful resource allocation during training. Optimal model size and training duration depend on the available compute budget, as evidenced by the convergence of loss curves at different parameter scales and training token counts. Source: [@kaplan2020scaling]."><img src="images/png/kaplan_scaling_data_compute.png" class="img-fluid figure-img"></a>
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-kaplan-scaling-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;4: <strong>Scaling Laws &amp; Compute Optimality</strong>: Larger models consistently achieve better performance with increased training data and compute, but diminishing returns necessitate careful resource allocation during training. Optimal model size and training duration depend on the available compute budget, as evidenced by the convergence of loss curves at different parameter scales and training token counts. Source: <span class="citation" data-cites="kaplan2020scaling">(<a href="#ref-kaplan2020scaling" role="doc-biblioref">Kaplan et al. 2020</a>)</span>.
</figcaption>
<div class="no-row-height column-margin column-container"><div id="ref-kaplan2020scaling" class="csl-entry" role="listitem">
Kaplan, Jared, Sam McCandlish, Tom Henighan, Tom B. Brown, Benjamin Chess, Rewon Child, Scott Gray, Alec Radford, Jeffrey Wu, and Dario Amodei. 2020. <span>“Scaling Laws for Neural Language Models.”</span> <em>arXiv Preprint arXiv:2001.08361</em>, January. <a href="http://arxiv.org/abs/2001.08361v1">http://arxiv.org/abs/2001.08361v1</a>.
</div></div></figure>
</div>
<p>This theoretical scaling relationship defines optimal compute allocation: for a fixed budget, the relationship <span class="math inline">\(D \propto N^{0.74}\)</span> <span class="citation" data-cites="hoffmann2022training">(<a href="#ref-hoffmann2022training" role="doc-biblioref">Hoffmann et al. 2022</a>)</span> shows that dataset size <span class="math inline">\(D\)</span> and model size <span class="math inline">\(N\)</span> must grow in coordinated proportions. This means that as model size increases, the dataset should grow at roughly three-quarters the rate to maintain compute-optimal efficiency.</p>
<div class="no-row-height column-margin column-container"></div><p>These theoretical predictions assume perfect compute utilization, which becomes challenging in distributed training scenarios. Real-world implementations face communication overhead that scales unfavorably with system size, creating bandwidth bottlenecks that reduce effective utilization. Beyond 100 nodes, communication overhead can reduce expected performance gains by 20-40% depending on workload and interconnect, transforming predicted improvements into more modest real-world results.</p>
</section>
<section id="sec-efficient-ai-mathematical-foundations-operational-regimes-9afe" class="level3 page-columns page-full">
<h3 class="anchored" data-anchor-id="sec-efficient-ai-mathematical-foundations-operational-regimes-9afe">Mathematical Foundations and Operational Regimes</h3>
<p>The predictable patterns observed in scaling behavior can be expressed mathematically using power-law relationships, though understanding the intuition behind these patterns proves more important than precise mathematical formulation for most practitioners.</p>
<div class="callout callout-style-default callout-note callout-titled" title="Formal Mathematical Formulation">
<div class="callout-header d-flex align-content-center" data-bs-toggle="collapse" data-bs-target=".callout-3-contents" aria-controls="callout-3" aria-expanded="false" aria-label="Toggle callout">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Formal Mathematical Formulation
</div>
<div class="callout-btn-toggle d-inline-block border-0 py-1 ps-1 pe-0 float-end"><i class="callout-toggle"></i></div>
</div>
<div id="callout-3" class="callout-3-contents callout-collapse collapse">
<div class="callout-body-container callout-body">
<p>For readers interested in the formal mathematical framework, scaling laws can be expressed as power-law relationships. The general formulation is:</p>
<p><span class="math display">\[
\mathcal{L}(N) = A N^{-\alpha} + B
\]</span></p>
<p>where loss <span class="math inline">\(\mathcal{L}\)</span> decreases as resource quantity <span class="math inline">\(N\)</span> increases, following a power-law decay with rate <span class="math inline">\(\alpha\)</span>, plus a baseline constant <span class="math inline">\(B\)</span>. Here, <span class="math inline">\(\mathcal{L}(N)\)</span> represents the loss achieved with resource quantity <span class="math inline">\(N\)</span>, <span class="math inline">\(A\)</span> and <span class="math inline">\(B\)</span> are task-dependent constants, and <span class="math inline">\(\alpha\)</span> is the scaling exponent that characterizes the rate of performance improvement. A larger value of <span class="math inline">\(\alpha\)</span> signifies more efficient performance improvements with respect to scaling.</p>
</div>
</div>
</div>
<p>These theoretical predictions find strong empirical support across multiple model configurations. <a href="#fig-loss-vs-n-d" class="quarto-xref">Figure&nbsp;5</a> shows that early-stopped test loss varies predictably with both dataset size and model size, and learning curves across configurations can be aligned through appropriate parameterization.</p>
<section id="sec-efficient-ai-resourceconstrained-scaling-regimes-062d" class="level4 page-columns page-full">
<h4 class="anchored" data-anchor-id="sec-efficient-ai-resourceconstrained-scaling-regimes-062d">Resource-Constrained Scaling Regimes</h4>
<p>Applying scaling laws in practice requires recognizing three distinct resource allocation regimes that emerge from trade-offs between compute budget, data availability, and optimal resource allocation. These regimes provide practical guidance for system designers navigating resource constraints.</p>
<p>Compute-limited regimes characterize scenarios where available computational resources restrict scaling potential despite abundant training data. Organizations with limited hardware budgets or strict training time constraints operate within this regime. The optimal strategy involves training smaller models for longer periods, maximizing utilization of available compute through extended training schedules rather than larger architectures. This approach proves particularly relevant for academic institutions, startups, or projects with constrained infrastructure access.</p>
<p>Data-limited regimes emerge when computational resources exceed what can be effectively utilized given dataset constraints. High-resource organizations working with specialized domains, proprietary datasets, or privacy-constrained data often encounter this regime. The optimal strategy involves training larger models for fewer optimization steps, leveraging model capacity to extract maximum information from limited training examples. This regime commonly appears in specialized applications like medical imaging or proprietary commercial datasets.</p>
<p>Optimal regimes (Chinchilla Frontier) represent the balanced allocation of compute and data resources following compute-optimal scaling laws. This regime achieves maximum performance efficiency by scaling model size and training data proportionally, as demonstrated by DeepMind’s Chinchilla model, which outperformed much larger models through optimal resource allocation <span class="citation" data-cites="hoffmann2022training">(<a href="#ref-hoffmann2022training" role="doc-biblioref">Hoffmann et al. 2022</a>)</span>. Operating within this regime requires sophisticated resource planning but delivers superior performance per unit of computational investment.</p>
<div class="no-row-height column-margin column-container"></div><p>Recognizing these regimes enables practitioners to make informed decisions about resource allocation strategies, avoiding common inefficiencies such as over-parameterized models with insufficient training data or under-parameterized models that fail to utilize available computational resources effectively.</p>
<div id="fig-loss-vs-n-d" class="quarto-float quarto-figure quarto-figure-center anchored" data-fig-env="figure" data-fig-pos="htb">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-loss-vs-n-d-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<a href="de2e4205574ea268bcc1883053f7f000bba4f588.svg" class="lightbox" data-gallery="quarto-lightbox-gallery-5" title="Figure&nbsp;5: : Loss vs Model and Dataset Size: Early-stopped test loss varies predictably with both dataset size and model size, highlighting the importance of balanced scaling for optimal performance under fixed compute budgets."><img src="efficient_ai_files/mediabag/de2e4205574ea268bcc1883053f7f000bba4f588.svg" class="img-fluid figure-img"></a>
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-loss-vs-n-d-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;5: : <strong>Loss vs Model and Dataset Size</strong>: Early-stopped test loss varies predictably with both dataset size and model size, highlighting the importance of balanced scaling for optimal performance under fixed compute budgets.
</figcaption>
</figure>
</div>
<p>Scaling laws show that performance improvements follow predictable patterns that change depending on resource availability and exhibit distinct behaviors across different dimensions. Two important types of scaling regimes emerge: <strong>data-driven regimes</strong> that describe how performance changes with dataset size, and <strong>temporal regimes</strong> that describe when in the ML lifecycle we apply additional compute.</p>
</section>
<section id="sec-efficient-ai-datalimited-scaling-regimes-ba1d" class="level4 page-columns page-full">
<h4 class="anchored" data-anchor-id="sec-efficient-ai-datalimited-scaling-regimes-ba1d">Data-Limited Scaling Regimes</h4>
<p>The relationship between generalization error and dataset size exhibits three distinct regimes, as shown in <a href="#fig-data-scaling-regimes" class="quarto-xref">Figure&nbsp;6</a>. When limited examples are available, high generalization error results from inadequate statistical estimates. As data availability increases, generalization error decreases predictably as a function of dataset size, following a power-law relationship that provides the most practical benefit from data scaling. Eventually, performance reaches saturation, approaching a floor determined by inherent data limitations or model capacity, beyond which additional data yields negligible improvements.</p>
<div id="fig-data-scaling-regimes" class="quarto-float quarto-figure quarto-figure-center anchored page-columns page-full" data-fig-env="figure" data-fig-pos="htb">
<figure class="quarto-float quarto-float-fig figure page-columns page-full">
<div aria-describedby="fig-data-scaling-regimes-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<a href="54926858636f497bd98ce136bee5c4785ec5dc9d.svg" class="lightbox" data-gallery="quarto-lightbox-gallery-6" title="Figure&nbsp;6: : Data Scaling Regimes: The relationship between dataset size and generalization error follows distinct scaling regimes. Increasing dataset size initially reduces generalization error following a power-law relationship, but eventually plateaus at an irreducible error floor determined by inherent data limitations or model capacity [@hestness2017deep]. This behavior exposes diminishing returns from data scaling and informs practical decisions about data collection efforts in machine learning systems."><img src="efficient_ai_files/mediabag/54926858636f497bd98ce136bee5c4785ec5dc9d.svg" class="img-fluid figure-img"></a>
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-data-scaling-regimes-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;6: : <strong>Data Scaling Regimes</strong>: The relationship between dataset size and generalization error follows distinct scaling regimes. Increasing dataset size initially reduces generalization error following a power-law relationship, but eventually plateaus at an irreducible error floor determined by inherent data limitations or model capacity <span class="citation" data-cites="hestness2017deep">(<a href="#ref-hestness2017deep" role="doc-biblioref">Hestness et al. 2017</a>)</span>. This behavior exposes diminishing returns from data scaling and informs practical decisions about data collection efforts in machine learning systems.
</figcaption>
<div class="no-row-height column-margin column-container"><div id="ref-hestness2017deep" class="csl-entry" role="listitem">
Hestness, Joel, Sharan Narang, Newsha Ardalani, Gregory Diamos, Heewoo Jun, Hassan Kianinejad, Md. Mostofa Ali Patwary, Yang Yang, and Yanqi Zhou. 2017. <span>“Deep Learning Scaling Is Predictable, Empirically.”</span> <em>arXiv Preprint arXiv:1712.00409</em>, December. <a href="http://arxiv.org/abs/1712.00409v1">http://arxiv.org/abs/1712.00409v1</a>.
</div></div></figure>
</div>
<p>This three-regime pattern manifests across different resource dimensions beyond data alone. Operating within the power-law region provides the most reliable return on resource investment. Reaching this regime requires minimum resource thresholds, while maintaining operation within it demands careful allocation to avoid premature saturation.</p>
</section>
<section id="sec-efficient-ai-temporal-scaling-regimes-e118" class="level4">
<h4 class="anchored" data-anchor-id="sec-efficient-ai-temporal-scaling-regimes-e118">Temporal Scaling Regimes</h4>
<p>While data-driven regimes characterize how performance varies with dataset size, a complementary perspective examines temporal allocation of compute resources within the ML lifecycle. Recent research has identified three distinct <strong>temporal scaling regimes</strong> characterizing different stages of model development and deployment.</p>
<p><strong>Pre-training scaling</strong> encompasses the traditional domain of scaling laws, characterizing how model performance improves with larger architectures, expanded datasets, and increased compute during initial training. Extensive study in foundation models has established clear power-law relationships between resources and capabilities.</p>
<p><strong>Post-training scaling</strong> characterizes improvements achieved after initial training through techniques including fine-tuning, prompt engineering, and task-specific adaptation. This regime has gained prominence with foundation models, where adaptation rather than retraining frequently provides the most efficient path to enhanced performance under moderate resource requirements.</p>
<p><strong>Test-time scaling</strong> characterizes how performance improvements result from additional compute allocation during inference without modifying model parameters. This encompasses methods including ensemble prediction, chain-of-thought prompting, and iterative refinement, enabling models to allocate additional processing time per input.</p>
<p><a href="#fig-scaling-regimes" class="quarto-xref">Figure&nbsp;7</a> shows these temporal regimes exhibit distinct characteristics in computational resource allocation for performance improvement. Pre-training demands massive resources while providing broad capabilities, post-training offers targeted enhancements under moderate requirements, and test-time scaling enables flexible performance-compute trade-offs adjustable per inference.</p>
<div id="fig-scaling-regimes" class="quarto-float quarto-figure quarto-figure-center anchored" data-fig-env="figure" data-fig-pos="htb">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-scaling-regimes-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<a href="78391c07afda8b90af1af45f04f4817ba07d3d3e.svg" class="lightbox" data-gallery="quarto-lightbox-gallery-7" title="Figure&nbsp;7: : Temporal Scaling Regimes: Different temporal scaling regimes offer distinct approaches to improving model performance with varying compute investments. Pre-training establishes broad capabilities through large-scale training from scratch, post-training refines existing models through additional training phases, and test-time scaling dynamically allocates compute during inference to enhance per-sample results. Understanding these regimes clarifies the trade-offs between upfront investment and flexible, on-demand resource allocation for optimal system performance."><img src="efficient_ai_files/mediabag/78391c07afda8b90af1af45f04f4817ba07d3d3e.svg" class="img-fluid figure-img"></a>
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-scaling-regimes-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;7: : <strong>Temporal Scaling Regimes</strong>: Different temporal scaling regimes offer distinct approaches to improving model performance with varying compute investments. Pre-training establishes broad capabilities through large-scale training from scratch, post-training refines existing models through additional training phases, and test-time scaling dynamically allocates compute during inference to enhance per-sample results. Understanding these regimes clarifies the trade-offs between upfront investment and flexible, on-demand resource allocation for optimal system performance.
</figcaption>
</figure>
</div>
<p>Data-driven and temporal scaling regimes are crucial for system design, revealing multiple paths to performance improvement beyond scaling training resources alone. For resource-constrained deployments, post-training and test-time scaling may provide more practical approaches than complete model retraining, while data-efficient techniques enable effective system operation within the power-law regime using smaller datasets.</p>
</section>
</section>
<section id="sec-efficient-ai-practical-applications-system-design-5c97" class="level3 page-columns page-full">
<h3 class="anchored" data-anchor-id="sec-efficient-ai-practical-applications-system-design-5c97">Practical Applications in System Design</h3>
<p>Scaling laws provide powerful insights for practical system design and resource planning. Consistent observation of power-law trends indicates that within well-defined operational regimes, model performance depends predominantly on scale rather than idiosyncratic architectural innovations. However, diminishing returns phenomena indicate that each additional improvement requires exponentially increased resources while delivering progressively smaller benefits.</p>
<p>OpenAI’s development of GPT-3 demonstrates this principle. Rather than conducting expensive architecture searches, the authors applied scaling laws derived from earlier experiments to determine optimal training dataset size and model parameter count <span class="citation" data-cites="brown2020language">(<a href="#ref-brown2020language" role="doc-biblioref">Brown et al. 2020</a>)</span>. They scaled an established transformer architecture along the compute-optimal frontier to 175 billion parameters and approximately 300 billion tokens, enabling advance prediction of model performance and resource requirements. This methodology demonstrated the practical application of scaling laws in large-scale system planning.</p>
<div class="no-row-height column-margin column-container"><div id="ref-brown2020language" class="csl-entry" role="listitem">
Brown, Tom B, Benjamin Mann, Nick Ryder, Melanie Subbiah, Jared Kaplan, Prafulla Dhariwal, Arvind Neelakantan, et al. 2020. <span>“Language Models Are Few-Shot Learners.”</span> <em>Advances in Neural Information Processing Systems</em> 33: 1877–1901.
</div></div><p>Scaling laws serve multiple practical functions in system design. They enable practitioners to estimate returns on investment for different resource allocations during resource budgeting. Under fixed computational budgets, designers can utilize empirical scaling curves to determine optimal performance improvement strategies across model size, dataset expansion, or training duration.</p>
<p>System designers can utilize scaling trends to identify when architectural changes yield significant improvements relative to gains achieved through scaling alone, thereby avoiding exhaustive architecture search. When a model family exhibits favorable scaling behavior, scaling the existing architecture may prove more effective than transitioning to more complex but unvalidated designs.</p>
<p>In edge and embedded environments with constrained resource budgets, understanding performance degradation under model scaling enables designers to select smaller configurations delivering acceptable accuracy within deployment constraints. By quantifying scale-performance trade-offs, scaling laws identify when brute-force scaling becomes inefficient and indicate the necessity for alternative approaches including model compression, efficient knowledge transfer, sparsity techniques, and hardware-aware design.</p>
<p>Scaling laws also function as diagnostic instruments. Performance plateaus despite increased resources may indicate dimensional saturation—such as inadequate data relative to model size—or inefficient computational resource utilization. This diagnostic capability renders scaling laws both predictive and prescriptive, facilitating systematic bottleneck identification and resolution.</p>
</section>
<section id="sec-efficient-ai-sustainability-cost-implications-0473" class="level3 page-columns page-full">
<h3 class="anchored" data-anchor-id="sec-efficient-ai-sustainability-cost-implications-0473">Sustainability and Cost Implications</h3>
<p>Scaling laws illuminate pathways to performance enhancement while revealing rapidly escalating resource demands. As models expand, training and deployment resource requirements grow disproportionately, creating tension between performance gains through scaling and system efficiency.</p>
<p>Training large-scale models necessitates substantial processing power, typically requiring distributed infrastructures<a href="#fn9" class="footnote-ref" id="fnref9" role="doc-noteref"><sup>9</sup></a> comprising hundreds or thousands of accelerators. State-of-the-art language model training may require tens of thousands of GPU-days, consuming millions of kilowatt-hours of electricity. These distributed training systems introduce additional complexity around communication overhead, synchronization, and scaling efficiency, as detailed in <strong><a href="../training/training.html#sec-ai-training">Chapter 8: AI Training</a></strong>. Energy demands have outpaced Moore’s Law improvements, raising critical questions about long-term sustainability.</p>
<div class="no-row-height column-margin column-container"><div id="fn9"><p><sup>9</sup>&nbsp;<strong>Distributed Infrastructure</strong>: Computing systems that spread ML workloads across multiple machines connected by high-speed networks. OpenAI’s GPT-4 training likely used thousands of NVIDIA A100 GPUs connected via InfiniBand, requiring careful orchestration to avoid communication bottlenecks.</p></div></div><p>Large models require extensive, high-quality, diverse datasets to achieve their full potential. Data collection, cleansing, and labeling processes consume considerable time and resources. As models approach saturation of available high-quality data, particularly in natural language processing, additional performance gains through data scaling become increasingly difficult to achieve. This reality underscores data efficiency as a necessary complement to brute-force scaling approaches.</p>
<p>The financial and environmental implications compound these challenges. Training runs for large foundation models can incur millions of dollars in computational expenses, and associated carbon footprints<a href="#fn10" class="footnote-ref" id="fnref10" role="doc-noteref"><sup>10</sup></a> have garnered increasing scrutiny. These costs limit accessibility to cutting-edge research and exacerbate disparities in access to advanced AI systems. The democratization challenges introduced by efficiency barriers connect directly to accessibility goals addressed in <strong><a href="../ai_for_good/ai_for_good.html#sec-ai-good">Chapter 19: AI for Good</a></strong>. Comprehensive approaches to environmental sustainability in ML systems, including carbon footprint measurement and green computing practices, are explored in <strong><a href="../sustainable_ai/sustainable_ai.html#sec-sustainable-ai">Chapter 18: Sustainable AI</a></strong>.</p>
<div class="no-row-height column-margin column-container"><div id="fn10"><p><sup>10</sup>&nbsp;<strong>Carbon Emissions</strong>: Training GPT-3 generated approximately 502 tons of CO₂ equivalent, comparable to annual emissions of 123 gasoline-powered vehicles. Modern ML practices increasingly incorporate carbon tracking using tools like CodeCarbon and the ML CO2 Impact calculator.</p></div></div><p>These trade-offs demonstrate that scaling laws provide valuable frameworks for understanding performance growth but do not constitute unencumbered paths to improvement. Each incremental performance gain requires evaluation against corresponding resource requirements. As systems approach practical scaling limits, emphasis must transition from scaling alone to efficient scaling—a comprehensive approach balancing performance, cost, energy consumption, and environmental impact.</p>
</section>
<section id="sec-efficient-ai-scaling-law-breakdown-conditions-1f8c" class="level3 page-columns page-full">
<h3 class="anchored" data-anchor-id="sec-efficient-ai-scaling-law-breakdown-conditions-1f8c">Scaling Law Breakdown Conditions</h3>
<p>Scaling laws exhibit remarkable consistency within specific operational regimes but possess inherent limitations. As systems expand, they inevitably encounter boundaries where underlying assumptions of smooth, predictable scaling cease to hold. These breakdown points expose critical inefficiencies and emphasize the necessity for refined system design approaches.</p>
<p>For scaling laws to remain valid, model size, dataset size, and computational budget must be augmented in coordinated fashion. Over-investment in one dimension while maintaining others constant often results in suboptimal outcomes. For example, increasing model size without expanding training datasets may induce overfitting, while increasing computational resources without model redesign may lead to inefficient utilization <span class="citation" data-cites="hoffmann2022training">(<a href="#ref-hoffmann2022training" role="doc-biblioref">Hoffmann et al. 2022</a>)</span>.</p>
<div class="no-row-height column-margin column-container"><div id="ref-hoffmann2022training" class="csl-entry" role="listitem">
Hoffmann, Jordan, Sebastian Borgeaud, Arthur Mensch, Elena Buchatskaya, Trevor Cai, Eliza Rutherford, Diego de Las Casas, et al. 2022. <span>“Training Compute-Optimal Large Language Models.”</span> <em>arXiv Preprint arXiv:2203.15556</em>, March. <a href="http://arxiv.org/abs/2203.15556v1">http://arxiv.org/abs/2203.15556v1</a>.
</div></div><p>Large-scale models require carefully tuned training schedules and learning rates to fully utilize available resources. When compute is insufficiently allocated due to premature stopping, batch size misalignment, or ineffective parallelism, models may fail to reach performance potential despite significant infrastructure investment.</p>
<p>Scaling laws presuppose continued performance improvement with sufficient training data. However, in numerous domains, availability of high-quality, human-annotated data is finite. As models consume increasingly large datasets, they reach points of diminishing marginal utility where additional data contributes minimal new information. Beyond this threshold, larger models may exhibit memorization rather than generalization.</p>
<p>As models grow, they demand greater memory bandwidth<a href="#fn11" class="footnote-ref" id="fnref11" role="doc-noteref"><sup>11</sup></a>, interconnect capacity, and I/O throughput. These hardware limitations become increasingly challenging even with specialized accelerators. Distributing trillion-parameter models across clusters necessitates meticulous management of data parallelism, communication overhead, and fault tolerance.</p>
<div class="no-row-height column-margin column-container"><div id="fn11"><p><sup>11</sup>&nbsp;<strong>Memory Bandwidth</strong>: The rate at which data can be read from or written to memory, measured in GB/s. NVIDIA H100 provides 3.35 TB/s memory bandwidth vs.&nbsp;typical DDR5 RAM’s 51 GB/s, a 65× difference critical for handling large model parameters.</p></div></div><p>At extreme scales, models may approach limits of what can be learned from training distributions. Performance on benchmarks may continue improving, but these improvements may no longer reflect meaningful gains in generalization or understanding. Models may become increasingly brittle, susceptible to adversarial examples, or prone to generating plausible but inaccurate outputs.</p>
<p><a href="#tbl-scaling-breakdown" class="quarto-xref">Table&nbsp;1</a> synthesizes the primary causes of scaling failure, outlining typical breakdown types, underlying causes, and representative scenarios as a reference for anticipating inefficiencies and guiding balanced system design.</p>
<div id="tbl-scaling-breakdown" class="quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-tbl figure">
<figcaption class="quarto-float-caption-top quarto-float-caption quarto-float-tbl" id="tbl-scaling-breakdown-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Table&nbsp;1: <strong>Scaling Breakdown Types</strong>: Unbalanced scaling across model size, data volume, and compute resources leads to specific failure modes, such as overfitting or diminishing returns, impacting system performance and efficiency. The table categorizes these breakdowns, identifies their root causes, and provides representative scenarios to guide more effective system design and resource allocation.
</figcaption>
<div aria-describedby="tbl-scaling-breakdown-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<table class="caption-top table">
<colgroup>
<col style="width: 16%">
<col style="width: 17%">
<col style="width: 32%">
<col style="width: 32%">
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;"><strong>Dimension Scaled</strong></th>
<th style="text-align: left;"><strong>Type of Breakdown</strong></th>
<th style="text-align: left;"><strong>Underlying Cause</strong></th>
<th style="text-align: left;"><strong>Example Scenario</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><strong>Model Size</strong></td>
<td style="text-align: left;">Overfitting</td>
<td style="text-align: left;">Model capacity exceeds available data</td>
<td style="text-align: left;">Billion-parameter model on limited dataset</td>
</tr>
<tr class="even">
<td style="text-align: left;"><strong>Data Volume</strong></td>
<td style="text-align: left;">Diminishing Returns</td>
<td style="text-align: left;">Saturation of new or diverse information</td>
<td style="text-align: left;">Scaling web text beyond useful threshold</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><strong>Compute Budget</strong></td>
<td style="text-align: left;">Underutilized Resources</td>
<td style="text-align: left;">Insufficient training steps or inefficient use</td>
<td style="text-align: left;">Large model with truncated training duration</td>
</tr>
<tr class="even">
<td style="text-align: left;"><strong>Imbalanced Scaling</strong></td>
<td style="text-align: left;">Inefficiency</td>
<td style="text-align: left;">Uncoordinated increase in model/data/compute</td>
<td style="text-align: left;">Doubling model size without more data or time</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><strong>All Dimensions</strong></td>
<td style="text-align: left;">Semantic Saturation</td>
<td style="text-align: left;">Exhaustion of learnable patterns in the domain</td>
<td style="text-align: left;">No further gains despite scaling all inputs</td>
</tr>
</tbody>
</table>
</div>
</figure>
</div>
<p>These breakdown points demonstrate that scaling laws describe empirical regularities under specific conditions that become increasingly difficult to maintain at scale. As machine learning systems continue evolving, discerning where and why scaling ceases to be effective becomes necessary, driving development of strategies that enhance performance without relying solely on scale.</p>
</section>
<section id="sec-efficient-ai-integrating-efficiency-scaling-a513" class="level3">
<h3 class="anchored" data-anchor-id="sec-efficient-ai-integrating-efficiency-scaling-a513">Integrating Efficiency with Scaling</h3>
<p>The limitations exposed by scaling laws (data saturation, infrastructure bottlenecks, and diminishing returns) demonstrate that brute-force scaling alone cannot deliver sustainable AI systems. These constraints necessitate a shift from expanding scale to achieving greater efficiency with reduced resources.</p>
<p>This transition requires coordinated optimization across three interconnected dimensions: <strong>algorithmic efficiency</strong> addresses computational intensity through better model design, <strong>compute efficiency</strong> maximizes hardware utilization to translate algorithmic improvements into practical gains, and <strong>data efficiency</strong> extracts maximum information from limited examples as high-quality data becomes scarce. Together, these dimensions provide systematic approaches to achieving performance goals that scaling alone cannot sustainably deliver, while addressing broader concerns about equitable access to AI capabilities and environmental impact.</p>
<p>Having examined how scaling laws reveal fundamental constraints, we now turn to the efficiency framework that provides concrete strategies for operating effectively within these constraints. The following section details how the three efficiency dimensions work together to enable sustainable, accessible machine learning systems.</p>
<div id="quiz-question-sec-efficient-ai-ai-scaling-laws-a043" class="callout callout-quiz-question">
<details class="callout-quiz-question fbx-default closebutton"><summary><strong>Self-Check: Question 1.3</strong></summary><div>
<ol type="1">
<li><p>What is a key insight from scaling laws in machine learning?</p>
<ol type="a">
<li>Model performance improves linearly with increased computational resources.</li>
<li>Larger models always require less training data to achieve state-of-the-art performance.</li>
<li>Performance improvements follow predictable power-law relationships with model size, dataset size, and compute budget.</li>
<li>Scaling laws suggest that model architecture is the primary driver of performance improvements.</li>
</ol></li>
<li><p>Explain the trade-offs involved in scaling machine learning models in terms of computational resources and performance.</p></li>
<li><p>Order the following models by their parameter size: (1) GPT-1, (2) GPT-2, (3) GPT-3.</p></li>
<li><p>True or False: According to scaling laws, increasing model size without increasing dataset size can lead to overfitting.</p></li>
</ol>
<p><a href="#quiz-answer-sec-efficient-ai-ai-scaling-laws-a043" class="question-label">See Answers →</a></p>
</div></details>
</div>
</section>
</section>
<section id="sec-efficient-ai-efficiency-framework-c0de" class="level2 page-columns page-full">
<h2 class="anchored" data-anchor-id="sec-efficient-ai-efficiency-framework-c0de">The Efficiency Framework</h2>
<p>The constraint identified through scaling laws (that continued progress requires systematic efficiency optimization) motivates three complementary efficiency dimensions. Each dimension addresses a specific limitation: algorithmic efficiency tackles computational intensity, compute efficiency addresses hardware utilization gaps, and data efficiency solves the data saturation problem.</p>
<p>Together, these three dimensions provide a systematic framework for addressing the constraints that scaling laws reveal. Targeted optimizations across algorithmic design, hardware utilization, and data usage can achieve what brute-force scaling cannot: sustainable, accessible, high-performance AI systems.</p>
<section id="sec-efficient-ai-multidimensional-efficiency-synergies-ea04" class="level3">
<h3 class="anchored" data-anchor-id="sec-efficient-ai-multidimensional-efficiency-synergies-ea04">Multi-Dimensional Efficiency Synergies</h3>
<p>Optimal performance requires coordinated optimization across multiple dimensions. No single resource—whether model parameters, training data, or compute budget—can be scaled indefinitely to achieve efficiency. Modern techniques demonstrate the potential: 10-100x gains in algorithmic efficiency through optimized architectures, 5-50x improvements in hardware utilization through specialized processors, and 10-1000x reductions in data requirements through advanced learning methods.</p>
<p>The power of this framework emerges from interconnections between dimensions, as depicted in <a href="#fig-evolution-efficiency" class="quarto-xref">Figure&nbsp;8</a>. Algorithmic innovations often enable better hardware utilization, while hardware advances unlock new algorithmic possibilities. Data-efficient techniques reduce computational requirements, while compute-efficient methods enable training on larger datasets. Understanding these synergies is essential for building practical ML systems.</p>
<div id="fig-evolution-efficiency" class="quarto-float quarto-figure quarto-figure-center anchored" data-fig-env="figure" data-fig-pos="htb">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-evolution-efficiency-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<a href="2abdd66045808c7d07317e46f41d4af3ac1aea8a.svg" class="lightbox" data-gallery="quarto-lightbox-gallery-8" title="Figure&nbsp;8: : Historical Efficiency Trends: Algorithmic, computational, and data efficiency have each contributed to substantial gains in AI capabilities, though at different rates and with diminishing returns. Understanding these historical trends clarifies the interplay between these efficiency dimensions and informs strategies for scaling machine learning systems in data-limited environments."><img src="efficient_ai_files/mediabag/2abdd66045808c7d07317e46f41d4af3ac1aea8a.svg" class="img-fluid figure-img"></a>
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-evolution-efficiency-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;8: : <strong>Historical Efficiency Trends</strong>: Algorithmic, computational, and data efficiency have each contributed to substantial gains in AI capabilities, though at different rates and with diminishing returns. Understanding these historical trends clarifies the interplay between these efficiency dimensions and informs strategies for scaling machine learning systems in data-limited environments.
</figcaption>
</figure>
</div>
<p>The specific priorities vary across deployment environments. Cloud systems with abundant resources prioritize scalability and throughput, while edge devices face severe memory and power constraints. Mobile applications must balance performance with battery life, and TinyML deployments demand extreme resource efficiency. Understanding these context-specific patterns enables designers to make informed decisions about which efficiency dimensions to prioritize and how to address inevitable trade-offs between them.</p>
</section>
<section id="sec-efficient-ai-achieving-algorithmic-efficiency-ef15" class="level3 page-columns page-full">
<h3 class="anchored" data-anchor-id="sec-efficient-ai-achieving-algorithmic-efficiency-ef15">Achieving Algorithmic Efficiency</h3>
<p>Algorithmic efficiency achieves maximum performance per unit of computation through optimized model architectures and training procedures. Modern techniques achieve 10-100x improvements in computational requirements while maintaining or improving accuracy, providing the most direct path to practical AI deployment.</p>
<p>The foundation for these improvements lies in a key observation: most neural networks are dramatically overparameterized. The lottery ticket hypothesis reveals that networks contain sparse subnetworks, typically 10-20% of original parameters (though this varies significantly by architecture and task), that achieve comparable accuracy when trained in isolation <span class="citation" data-cites="frankle2019lottery">(<a href="#ref-frankle2019lottery" role="doc-biblioref">Frankle and Carbin 2019</a>)</span>. This discovery transforms compression into a principled approach: large models serve as initialization strategies for finding efficient architectures.</p>
<div class="no-row-height column-margin column-container"><div id="ref-frankle2019lottery" class="csl-entry" role="listitem">
Frankle, Jonathan, and Michael Carbin. 2019. <span>“The Lottery Ticket Hypothesis: Finding Sparse, Trainable Neural Networks.”</span> In <em>International Conference on Learning Representations</em>. <a href="https://openreview.net/forum?id=rJl-b3RcF7">https://openreview.net/forum?id=rJl-b3RcF7</a>.
</div></div><section id="sec-efficient-ai-model-compression-fundamentals-bcc3" class="level4 page-columns page-full">
<h4 class="anchored" data-anchor-id="sec-efficient-ai-model-compression-fundamentals-bcc3">Model Compression Fundamentals</h4>
<p>Three major approaches dominate modern algorithmic efficiency, each targeting different aspects of model inefficiency:</p>
<p><strong>Model Compression</strong> systematically removes redundant components from neural networks. Pruning techniques achieve 2-4x inference speedup with 1-3% accuracy loss by removing unnecessary weights and structures. Research demonstrates that ResNet-50 can be reduced to 20% of original parameters while maintaining 99% of ImageNet accuracy <span class="citation" data-cites="gholami2021survey">(<a href="#ref-gholami2021survey" role="doc-biblioref">Gholami et al. 2021</a>)</span>. The specific pruning algorithms—including magnitude-based selection, structured vs.&nbsp;unstructured approaches, and layer-wise sensitivity analysis—are covered in detail in <strong><a href="../optimizations/optimizations.html#sec-model-optimizations">Chapter 10: Model Optimizations</a></strong>.</p>
<div class="no-row-height column-margin column-container"><div id="ref-gholami2021survey" class="csl-entry" role="listitem">
Gholami, Amir, Sehoon Kim, Zhen Dong, Zhewei Yao, Michael W. Mahoney, and Kurt Keutzer. 2021. <span>“A Survey of Quantization Methods for Efficient Neural Network Inference.”</span> <em>arXiv Preprint arXiv:2103.13630</em>, March. <a href="http://arxiv.org/abs/2103.13630v3">http://arxiv.org/abs/2103.13630v3</a>.
</div><div id="ref-Jacob_et_al_2018" class="csl-entry" role="listitem">
Jacob, Benoit, Skirmantas Kligys, Bo Chen, Menglong Zhu, Matthew Tang, Andrew Howard, Hartwig Adam, and Dmitry Kalenichenko. 2018. <span>“Quantization and Training of Neural Networks for Efficient Integer-Arithmetic-Only Inference.”</span> In <em>2018 IEEE/CVF Conference on Computer Vision and Pattern Recognition</em>, 2704–13. IEEE. <a href="https://doi.org/10.1109/cvpr.2018.00286">https://doi.org/10.1109/cvpr.2018.00286</a>.
</div></div><p><strong>Precision Optimization</strong> reduces computational requirements through quantization, which maps high-precision floating-point values to lower-precision representations. Neural networks demonstrate inherent robustness to precision reduction, with INT8 quantization achieving 4x memory reduction and 2-4x inference speedup while typically maintaining 98-99% of FP32 accuracy <span class="citation" data-cites="Jacob_et_al_2018">(<a href="#ref-Jacob_et_al_2018" role="doc-biblioref">Jacob et al. 2018</a>)</span>. Modern techniques range from simple post-training quantization to sophisticated quantization-aware training. The specific quantization algorithms, calibration methods, and training procedures are detailed in <strong><a href="../optimizations/optimizations.html#sec-model-optimizations">Chapter 10: Model Optimizations</a></strong>.</p>
<p><strong>Knowledge Transfer</strong> distills capabilities from large teacher models into efficient student models. Knowledge distillation<a href="#fn12" class="footnote-ref" id="fnref12" role="doc-noteref"><sup>12</sup></a> achieves 40-60% parameter reduction while retaining 95-97% of original performance, addressing both computational efficiency and data efficiency by requiring fewer training examples. The specific distillation algorithms, loss functions, and training procedures are covered in <strong><a href="../optimizations/optimizations.html#sec-model-optimizations">Chapter 10: Model Optimizations</a></strong>.</p>
<div class="no-row-height column-margin column-container"><div id="fn12"><p><sup>12</sup>&nbsp;<strong>Knowledge Distillation</strong>: Technique where a large “teacher” model transfers knowledge to a smaller “student” model by training the student to mimic the teacher’s output probabilities. DistilBERT achieves ~97% of BERT’s performance on GLUE benchmark with 40% fewer parameters and 60% faster inference through distillation.</p></div></div></section>
<section id="sec-efficient-ai-hardwarealgorithm-codesign-67e8" class="level4">
<h4 class="anchored" data-anchor-id="sec-efficient-ai-hardwarealgorithm-codesign-67e8">Hardware-Algorithm Co-Design</h4>
<p>Algorithmic optimizations alone are insufficient; their practical benefits depend on hardware-software co-design. Optimization techniques must be tailored to target hardware characteristics (memory bandwidth, compute capabilities, and precision support) to achieve real-world speedups. For example, INT8 quantization achieves 2.3x speedup on NVIDIA V100 GPUs with tensor core support but may provide minimal benefit on hardware lacking specialized integer instructions.</p>
<p>Successful co-design requires understanding whether workloads are memory-bound (limited by data movement) or compute-bound (limited by processing capacity), then applying optimizations that address the actual bottleneck. Techniques like operator fusion reduce memory traffic by combining operations, while precision reduction exploits specialized hardware units. While <strong><a href="../optimizations/optimizations.html#sec-model-optimizations">Chapter 10: Model Optimizations</a></strong> covers the algorithmic aspects of hardware-aware optimization, <strong><a href="../hw_acceleration/hw_acceleration.html#sec-ai-acceleration">Chapter 11: AI Acceleration</a></strong> details how systematic co-design approaches leverage specific hardware architectures for maximum efficiency.</p>
</section>
<section id="sec-efficient-ai-architectural-innovation-efficiency-7dd9" class="level4 page-columns page-full">
<h4 class="anchored" data-anchor-id="sec-efficient-ai-architectural-innovation-efficiency-7dd9">Architectural Innovation for Efficiency</h4>
<p>Modern efficiency requires architectures designed for resource constraints. Models like MobileNet<a href="#fn13" class="footnote-ref" id="fnref13" role="doc-noteref"><sup>13</sup></a>, EfficientNet<a href="#fn14" class="footnote-ref" id="fnref14" role="doc-noteref"><sup>14</sup></a>, and SqueezeNet<a href="#fn15" class="footnote-ref" id="fnref15" role="doc-noteref"><sup>15</sup></a> demonstrate that compact designs can deliver high performance through architectural innovations rather than scaling up existing designs.</p>
<div class="no-row-height column-margin column-container"><div id="fn13"><p><sup>13</sup>&nbsp;<strong>MobileNet</strong>: Efficient neural network architecture using depthwise separable convolutions, achieving ~50× fewer parameters than traditional models. MobileNet-v1 has only 4.2M parameters vs.&nbsp;VGG-16’s ~138M, enabling deployment on smartphones with &lt;100MB memory.</p></div><div id="fn14"><p><sup>14</sup>&nbsp;<strong>EfficientNet</strong>: Architecture achieving state-of-the-art accuracy with superior parameter efficiency. EfficientNet-B7 achieves 84.3% ImageNet top-1 accuracy (84.4% in some reports) with 66M parameters, compared to ResNet-152’s 77.0% accuracy with approximately 60M parameters.</p></div><div id="fn15"><p><sup>15</sup>&nbsp;<strong>SqueezeNet</strong>: Compact CNN architecture achieving AlexNet-level accuracy with 50× fewer parameters (1.25M vs.&nbsp;60M). Demonstrated that clever architecture design can dramatically reduce model size without sacrificing performance.</p></div></div><p>Different deployment contexts require different efficiency trade-offs. Cloud inference prioritizes throughput and can tolerate higher memory usage, favoring parallel-friendly operations. Edge deployment prioritizes latency and memory efficiency, requiring architectures that minimize memory access. Mobile deployment constrains energy usage, demanding architectures optimized for energy-efficient operations.</p>
</section>
<section id="sec-efficient-ai-parameterefficient-adaptation-1bce" class="level4 page-columns page-full">
<h4 class="anchored" data-anchor-id="sec-efficient-ai-parameterefficient-adaptation-1bce">Parameter-Efficient Adaptation</h4>
<p>Parameter-efficient fine-tuning<a href="#fn16" class="footnote-ref" id="fnref16" role="doc-noteref"><sup>16</sup></a> techniques demonstrate how the three efficiency dimensions work together. These methods update less than 1% of model parameters while achieving full fine-tuning performance, addressing all three efficiency pillars: algorithmic efficiency through reduced parameter updates, compute efficiency through lower memory requirements and faster training, and data efficiency by leveraging pre-trained representations that require fewer task-specific examples.</p>
<div class="no-row-height column-margin column-container"><div id="fn16"><p><sup>16</sup>&nbsp;<strong>Parameter-Efficient Fine-tuning</strong>: Methods like LoRA and Adapters that update &lt;1% of model parameters while achieving full fine-tuning performance. Reduces memory requirements from gigabytes to megabytes for large model adaptation.</p></div></div><p>The practical impact is transformative: fine-tuning GPT-3 traditionally requires storing gradients for 175 billion parameters, consuming over 700GB of GPU memory. LoRA reduces this to under 10GB by learning low-rank decompositions of weight updates, enabling efficient adaptation on single consumer GPUs while requiring only hundreds of examples rather than thousands for effective adaptation.</p>
<p>As <a href="#fig-algo-efficiency" class="quarto-xref">Figure&nbsp;9</a> shows, the computational resources needed to train a neural network to achieve AlexNet<a href="#fn17" class="footnote-ref" id="fnref17" role="doc-noteref"><sup>17</sup></a>-level performance on ImageNet<a href="#fn18" class="footnote-ref" id="fnref18" role="doc-noteref"><sup>18</sup></a> classification decreased by approximately <span class="math inline">\(44\times\)</span> between 2012 and 2019. This improvement, which halved every 16 months, outpaced hardware efficiency gains of Moore’s Law<a href="#fn19" class="footnote-ref" id="fnref19" role="doc-noteref"><sup>19</sup></a>, demonstrating the role of algorithmic advancements in driving efficiency <span class="citation" data-cites="Hernandez_et_al_2020">(<a href="#ref-Hernandez_et_al_2020" role="doc-biblioref">Hernandez, Brown, et al. 2020</a>)</span>.</p>
<div class="no-row-height column-margin column-container"><div id="fn17"><p><sup>17</sup>&nbsp;<strong>AlexNet</strong>: Groundbreaking CNN by Krizhevsky, Sutskever, and Hinton (2012) that won ImageNet with 15.3% error rate, nearly halving the previous best of 26.2%. Used 60M parameters, two GPUs, and launched the deep learning revolution.</p></div><div id="fn18"><p><sup>18</sup>&nbsp;<strong>ImageNet</strong>: Large-scale visual recognition dataset with 14+ million images across 20,000+ categories. The annual ImageNet Large Scale Visual Recognition Challenge (ILSVRC) drove computer vision breakthroughs from 2010-2017.</p></div><div id="fn19"><p><sup>19</sup>&nbsp;<strong>Moore’s Law</strong>: Intel co-founder Gordon Moore’s 1965 observation that transistor density doubles every ~2 years. Traditional Moore’s Law predicted ~2x transistor density every 18-24 months, though this rate has slowed significantly since ~2015, while AI algorithmic efficiency improved 44x in 7 years (2012-2019).</p></div></div><div id="fig-algo-efficiency" class="quarto-float quarto-figure quarto-figure-center anchored page-columns page-full" data-fig-env="figure" data-fig-pos="htb">
<figure class="quarto-float quarto-float-fig figure page-columns page-full">
<div aria-describedby="fig-algo-efficiency-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<a href="42e5ca2c27671b95ab12272cb46750f6894ba650.svg" class="lightbox" data-gallery="quarto-lightbox-gallery-9" title="Figure&nbsp;9: : Algorithmic Efficiency Progress: Neural network training compute requirements decreased 44× between 2012 and 2019, outpacing hardware improvements and demonstrating the significant impact of algorithmic advancements on model efficiency. Innovations in model architecture and optimization techniques can drive substantial gains in AI system sustainability via this halving of compute every 16 months. Source: [@Hernandez_et_al_2020]."><img src="efficient_ai_files/mediabag/42e5ca2c27671b95ab12272cb46750f6894ba650.svg" class="img-fluid figure-img"></a>
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-algo-efficiency-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;9: : <strong>Algorithmic Efficiency Progress</strong>: Neural network training compute requirements decreased 44× between 2012 and 2019, outpacing hardware improvements and demonstrating the significant impact of algorithmic advancements on model efficiency. Innovations in model architecture and optimization techniques can drive substantial gains in AI system sustainability via this halving of compute every 16 months. Source: <span class="citation" data-cites="Hernandez_et_al_2020">(<a href="#ref-Hernandez_et_al_2020" role="doc-biblioref">Hernandez, Brown, et al. 2020</a>)</span>.
</figcaption>
<div class="no-row-height column-margin column-container"><div id="ref-Hernandez_et_al_2020" class="csl-entry" role="listitem">
Hernandez, Danny, Tom B. Brown, et al. 2020. <span>“Measuring the Algorithmic Efficiency of Neural Networks.”</span> <em>OpenAI Blog</em>. <a href="https://openai.com/research/ai-and-efficiency">https://openai.com/research/ai-and-efficiency</a>.
</div></div></figure>
</div>
<p>The evolution of algorithmic efficiency, from basic compression to hardware-aware optimization and parameter-efficient adaptation, demonstrates the centrality of these techniques to machine learning progress. As the field advances, algorithmic efficiency will remain central to designing systems that are high-performing, scalable, and sustainable.</p>
</section>
</section>
<section id="sec-efficient-ai-compute-efficiency-745c" class="level3 page-columns page-full">
<h3 class="anchored" data-anchor-id="sec-efficient-ai-compute-efficiency-745c">Compute Efficiency</h3>
<p>Compute efficiency focuses on the effective use of hardware and computational resources to train and deploy machine learning models. It encompasses strategies for reducing energy consumption, optimizing processing speed, and leveraging hardware capabilities to achieve scalable and sustainable system performance. While this chapter focuses on efficiency principles and trade-offs, the detailed technical implementation of hardware acceleration—including GPU architectures, TPU design, memory systems, and custom accelerators—is covered in <strong><a href="../hw_acceleration/hw_acceleration.html#sec-ai-acceleration">Chapter 11: AI Acceleration</a></strong>.</p>
<section id="sec-efficient-ai-cpus-ai-accelerators-a8d7" class="level4 page-columns page-full">
<h4 class="anchored" data-anchor-id="sec-efficient-ai-cpus-ai-accelerators-a8d7">From CPUs to AI Accelerators</h4>
<p>Compute efficiency’s evolution reveals why specialized hardware became essential. In the early days of machine learning, Central Processing Units (CPUs) shaped what was possible. CPUs excel at sequential processing and complex decision-making but have limited parallelism, typically 4-16 cores optimized for diverse tasks rather than the repetitive matrix operations that dominate machine learning. Training times for models were measured in days or weeks, as even relatively small datasets pushed hardware boundaries.</p>
<p>This CPU-constrained era ended as deep learning models like AlexNet and ResNet<a href="#fn20" class="footnote-ref" id="fnref20" role="doc-noteref"><sup>20</sup></a> demonstrated the potential of neural networks, quickly surpassing traditional CPU capabilities. As shown in <a href="#fig-comp_efficiency" class="quarto-xref">Figure&nbsp;10</a>, this marked the beginning of exponential growth in compute usage. OpenAI’s analysis reveals that compute used in AI training increased approximately 300,000 times from 2012 to 2018, doubling approximately every 3.4 months during this period—a rate far exceeding Moore’s Law <span class="citation" data-cites="Amodei_et_al_2018">(<a href="#ref-Amodei_et_al_2018" role="doc-biblioref">Amodei, Hernandez, et al. 2018</a>)</span>.</p>
<div class="no-row-height column-margin column-container"><div id="fn20"><p><sup>20</sup>&nbsp;<strong>ResNet</strong>: Residual Network architecture by He et al. <span class="citation" data-cites="he2016deep">(<a href="#ref-he2016deep" role="doc-biblioref">He et al. 2016</a>)</span> enabling training of very deep networks (152+ layers) through skip connections. Won ImageNet 2015 with 3.6% error rate, surpassing human-level performance for the first time.</p><div id="ref-he2016deep" class="csl-entry" role="listitem">
He, Kaiming, Xiangyu Zhang, Shaoqing Ren, and Jian Sun. 2016. <span>“Deep Residual Learning for Image Recognition.”</span> In <em>2016 IEEE Conference on Computer Vision and Pattern Recognition (CVPR)</em>, 770–78. IEEE. <a href="https://doi.org/10.1109/cvpr.2016.90">https://doi.org/10.1109/cvpr.2016.90</a>.
</div></div></div><div id="fig-comp_efficiency" class="quarto-float quarto-figure quarto-figure-center anchored page-columns page-full" data-fig-env="figure" data-fig-pos="htb">
<figure class="quarto-float quarto-float-fig figure page-columns page-full">
<div aria-describedby="fig-comp_efficiency-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<a href="33aa5f6d6d13074068a62908b481e9d47cfefd81.svg" class="lightbox" data-gallery="quarto-lightbox-gallery-10" title="Figure&nbsp;10: : AI Training Compute Growth: AI training experienced a 300,000-fold increase in computational requirements from 2012 to 2019, exceeding the growth rate predicted by Moore’s Law and driving demand for specialized hardware [@Amodei_et_al_2018]. This exponential growth underscores the increasing complexity of AI models and the need for efficient computing infrastructure to support continued progress."><img src="efficient_ai_files/mediabag/33aa5f6d6d13074068a62908b481e9d47cfefd81.svg" class="img-fluid figure-img"></a>
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-comp_efficiency-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;10: : <strong>AI Training Compute Growth</strong>: AI training experienced a 300,000-fold increase in computational requirements from 2012 to 2019, exceeding the growth rate predicted by Moore’s Law and driving demand for specialized hardware <span class="citation" data-cites="Amodei_et_al_2018">(<a href="#ref-Amodei_et_al_2018" role="doc-biblioref">Amodei, Hernandez, et al. 2018</a>)</span>. This exponential growth underscores the increasing complexity of AI models and the need for efficient computing infrastructure to support continued progress.
</figcaption>
<div class="no-row-height column-margin column-container"><div id="ref-Amodei_et_al_2018" class="csl-entry" role="listitem">
Amodei, Dario, Danny Hernandez, et al. 2018. <span>“AI and Compute.”</span> <em>OpenAI Blog</em>. <a href="https://openai.com/research/ai-and-compute">https://openai.com/research/ai-and-compute</a>.
</div></div></figure>
</div>
<p>This rapid growth was driven by adoption of Graphics Processing Units (GPUs), which offered unparalleled parallel processing capabilities. While CPUs might have 16 cores, modern high-end GPUs like the NVIDIA H100 contain over 16,000 CUDA cores<a href="#fn21" class="footnote-ref" id="fnref21" role="doc-noteref"><sup>21</sup></a>. Specialized hardware accelerators such as Google’s Tensor Processing Units (TPUs) further revolutionized compute efficiency by designing chips specifically for machine learning workloads, optimizing for specific data types and operations most common in neural networks.</p>
<div class="no-row-height column-margin column-container"><div id="fn21"><p><sup>21</sup>&nbsp;<strong>CUDA Cores</strong>: NVIDIA’s parallel processing units optimized for floating-point operations. Unlike CPU cores (designed for complex sequential tasks), CUDA cores are simpler and work together, enabling a single H100 GPU to perform 16,896 parallel operations simultaneously for massive speedup in matrix computations.</p></div></div></section>
<section id="sec-efficient-ai-sustainable-computing-energy-awareness-d77a" class="level4 page-columns page-full">
<h4 class="anchored" data-anchor-id="sec-efficient-ai-sustainable-computing-energy-awareness-d77a">Sustainable Computing and Energy Awareness</h4>
<p>As systems scale further, compute efficiency has become closely tied to sustainability. Training state-of-the-art large language models requires massive computational resources, leading to increased attention on environmental impact. The projected electricity usage of data centers, shown in <a href="#fig-datacenter-energy-usage" class="quarto-xref">Figure&nbsp;11</a>, highlights this concern. Between 2010 and 2030, electricity consumption is expected to rise sharply, particularly under worst-case scenarios where it could exceed 8,000 TWh by 2030 <span class="citation" data-cites="jones2018much">(<a href="#ref-jones2018much" role="doc-biblioref">Jones 2018</a>)</span>.</p>
<div class="no-row-height column-margin column-container"></div><div id="fig-datacenter-energy-usage" class="quarto-float quarto-figure quarto-figure-center anchored page-columns page-full" data-fig-env="figure" data-fig-pos="htb">
<figure class="quarto-float quarto-float-fig figure page-columns page-full">
<div aria-describedby="fig-datacenter-energy-usage-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<a href="4c48abde203d26b69977df82d4ef3b8663e9e9d2.svg" class="lightbox" data-gallery="quarto-lightbox-gallery-11" title="Figure&nbsp;11: : Data Center Energy Projections: Between 2010 and 2030, data center electricity usage is projected to increase sharply, particularly under worst-case scenarios where consumption could exceed 8,000 TWh by 2030 [@jones2018much]. This projection underscores the critical need for improved energy efficiency in AI systems."><img src="efficient_ai_files/mediabag/4c48abde203d26b69977df82d4ef3b8663e9e9d2.svg" class="img-fluid figure-img"></a>
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-datacenter-energy-usage-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;11: : <strong>Data Center Energy Projections</strong>: Between 2010 and 2030, data center electricity usage is projected to increase sharply, particularly under worst-case scenarios where consumption could exceed 8,000 TWh by 2030 <span class="citation" data-cites="jones2018much">(<a href="#ref-jones2018much" role="doc-biblioref">Jones 2018</a>)</span>. This projection underscores the critical need for improved energy efficiency in AI systems.
</figcaption>
<div class="no-row-height column-margin column-container"><div id="ref-jones2018much" class="csl-entry" role="listitem">
Jones, Nicola. 2018. <span>“How to Stop Data Centres from Gobbling up the World’s Electricity.”</span> <em>Nature</em> 561 (7722): 163–66. <a href="https://doi.org/10.1038/d41586-018-06610-y">https://doi.org/10.1038/d41586-018-06610-y</a>.
</div></div></figure>
</div>
<p>This dramatic growth underscores urgency for compute efficiency, as even large data centers face energy constraints due to limitations in electrical grid capacity. Efficiency improvements alone may not guarantee environmental benefits due to a phenomenon known as Jevons Paradox.</p>
<p>Consider the invention of the fuel-efficient car. While each car uses less gas per mile, the lower cost of driving encourages people to drive more often and live further from work. The result can be an <em>increase</em> in total gasoline consumption. This is Jevons Paradox: efficiency gains can be offset by increased consumption. In AI, this means making models 10x more efficient might lead to a 100x increase in their use, resulting in a net negative environmental impact if not managed carefully.</p>
<p>Addressing these challenges requires optimizing hardware utilization and minimizing energy consumption in both cloud and edge contexts while being mindful of potential rebound effects from increased deployment.</p>
<p>Key trends include adoption of energy-aware scheduling and resource allocation techniques that distribute workloads efficiently across available hardware <span class="citation" data-cites="Patterson_et_al_2021">(<a href="#ref-Patterson_et_al_2021" role="doc-biblioref">Patterson et al. 2021</a>)</span>. Researchers are also developing methods to dynamically adjust precision levels during training and inference, using lower precision operations (e.g., mixed-precision training) to reduce power consumption without sacrificing accuracy.</p>
<div class="no-row-height column-margin column-container"><div id="ref-Patterson_et_al_2021" class="csl-entry" role="listitem">
Patterson, David, Joseph Gonzalez, Quoc Le, Chen Liang, Lluis-Miquel Munguia, Daniel Rothchild, David So, Maud Texier, and Jeff Dean. 2021. <span>“Carbon Emissions and Large Neural Network Training.”</span> <em>arXiv Preprint arXiv:2104.10350</em>, April. <a href="http://arxiv.org/abs/2104.10350v3">http://arxiv.org/abs/2104.10350v3</a>.
</div><div id="fn22"><p><sup>22</sup>&nbsp;<strong>Model Parallelism</strong>: Distributing model components across multiple processors due to memory constraints. GPT-3 (175B parameters) requires 350GB memory, exceeding A100’s 40GB capacity by 9×, necessitating tensor parallelism where each transformer layer splits across 8-16 GPUs with all-gather communication for activation synchronization.</p></div><div id="fn23"><p><sup>23</sup>&nbsp;<strong>Data Parallelism</strong>: Training method where the same model runs on multiple processors with different data batches. GPT-3 training used data parallelism across thousands of GPUs, processing multiple text sequences simultaneously.</p></div></div><p>Distributed systems achieve compute efficiency by splitting workloads across multiple machines. Techniques such as model parallelism<a href="#fn22" class="footnote-ref" id="fnref22" role="doc-noteref"><sup>22</sup></a> and data parallelism<a href="#fn23" class="footnote-ref" id="fnref23" role="doc-noteref"><sup>23</sup></a> allow large-scale models to be trained more efficiently, leveraging clusters of GPUs or TPUs to maximize throughput while minimizing idle time.</p>
<p>At the edge, compute efficiency addresses growing demand for real-time processing in energy-constrained environments. Innovations such as hardware-aware model optimization, lightweight inference engines, and adaptive computing architectures enable highly efficient edge systems critical for applications like autonomous vehicles and smart home devices.</p>
</section>
<section id="sec-efficient-ai-production-deployment-patterns-208a" class="level4">
<h4 class="anchored" data-anchor-id="sec-efficient-ai-production-deployment-patterns-208a">Production Deployment Patterns</h4>
<p>Real-world efficiency optimization demonstrates practical impact across deployment contexts. Production systems routinely achieve 5-10x efficiency gains through coordinated application of optimization techniques while maintaining 95%+ of original model performance.</p>
<p>Mobile applications achieve 4-7x model size reduction and 3-5x latency improvements through combined quantization, pruning, and distillation, enabling real-time inference on mid-range devices. Modern mobile AI systems distribute workloads across specialized processors (NPU for ultra-low power inference, GPU for parallel compute, CPU for control logic) based on power, performance, and real-time constraints.</p>
<p>Autonomous vehicle systems optimize for safety-critical &lt;10ms latency requirements through hardware-aware architectural design and mixed-precision quantization, processing multiple high-bandwidth sensor streams within strict power and thermal constraints.</p>
<p>Cloud serving infrastructure reduces costs by 70-80% through systematic optimization combining dynamic batching, quantization, and knowledge distillation, serving 4-5x more requests at comparable quality levels.</p>
<p>Edge IoT deployments achieve month-long battery life through extreme model compression and duty-cycle optimization, operating on milliwatt power budgets while maintaining acceptable accuracy for practical applications.</p>
<p>These efficiency gains emerge from systematic optimization strategies that coordinate multiple techniques rather than applying individual optimizations in isolation. The specific optimization sequences, technique combinations, and engineering practices that enable these production results are detailed in <strong><a href="../optimizations/optimizations.html#sec-model-optimizations">Chapter 10: Model Optimizations</a></strong>.</p>
<p>Compute efficiency complements algorithmic and data efficiency. Compact models reduce computational requirements, while efficient data pipelines streamline hardware usage. The evolution of compute efficiency (from early reliance on CPUs through specialized accelerators to sustainable computing practices) remains central to building scalable, accessible, and environmentally responsible machine learning systems.</p>
</section>
</section>
<section id="sec-efficient-ai-data-efficiency-a3ad" class="level3 page-columns page-full">
<h3 class="anchored" data-anchor-id="sec-efficient-ai-data-efficiency-a3ad">Data Efficiency</h3>
<p>Data efficiency focuses on optimizing the amount and quality of data required to train machine learning models effectively. Data efficiency has emerged as a pivotal dimension, driven by rising costs of data collection, storage, and processing, as well as the limits of available high-quality data.</p>
<section id="sec-efficient-ai-maximizing-learning-limited-data-2885" class="level4 page-columns page-full">
<h4 class="anchored" data-anchor-id="sec-efficient-ai-maximizing-learning-limited-data-2885">Maximizing Learning from Limited Data</h4>
<p>In early machine learning, data efficiency was not a primary focus, as datasets were relatively small and manageable. The challenge was often acquiring enough labeled data to train models effectively. Researchers relied on curated datasets such as <a href="https://archive.ics.uci.edu/">UCI’s Machine Learning Repository</a><a href="#fn24" class="footnote-ref" id="fnref24" role="doc-noteref"><sup>24</sup></a>, using feature selection and dimensionality reduction techniques like principal component analysis (PCA)<a href="#fn25" class="footnote-ref" id="fnref25" role="doc-noteref"><sup>25</sup></a> to extract maximum value from limited data.</p>
<div class="no-row-height column-margin column-container"><div id="fn24"><p><sup>24</sup>&nbsp;<strong>UCI Machine Learning Repository</strong>: Established in 1987 by the University of California, Irvine, one of the most widely-used resources for machine learning datasets. Contains over 600 datasets and has been cited in thousands of research papers.</p></div><div id="fn25"><p><sup>25</sup>&nbsp;<strong>Principal Component Analysis (PCA)</strong>: Dimensionality reduction technique invented by Karl Pearson in 1901, identifies the most important directions of variation in data. Reduces computational complexity while preserving 90%+ of data variance in many applications.</p></div></div><p>The advent of deep learning in the 2010s transformed data’s role. Models like AlexNet and GPT-3 demonstrated that larger datasets often led to better performance, marking the beginning of the “big data” era. However, this reliance introduced inefficiencies. Data collection became costly and time-consuming, requiring vast amounts of labeled data for supervised learning.</p>
<p>Researchers developed techniques enhancing data efficiency even as datasets grew. Transfer learning<a href="#fn26" class="footnote-ref" id="fnref26" role="doc-noteref"><sup>26</sup></a> allowed pre-trained models to be fine-tuned on smaller datasets, reducing task-specific data needs <span class="citation" data-cites="yosinski2014transferable">(<a href="#ref-yosinski2014transferable" role="doc-biblioref">Yosinski et al. 2014</a>)</span>. Data augmentation<a href="#fn27" class="footnote-ref" id="fnref27" role="doc-noteref"><sup>27</sup></a> artificially expanded datasets by creating new variations of existing samples. Active learning<a href="#fn28" class="footnote-ref" id="fnref28" role="doc-noteref"><sup>28</sup></a> prioritized labeling only the most informative data points <span class="citation" data-cites="Settles_2009">(<a href="#ref-Settles_2009" role="doc-biblioref">Settles 2012a</a>)</span>.</p>
<div class="no-row-height column-margin column-container"><div id="fn26"><p><sup>26</sup>&nbsp;<strong>Transfer Learning</strong>: Technique where models pre-trained on large datasets are fine-tuned for specific tasks. ImageNet pre-trained models can achieve high accuracy on new vision tasks with &lt;1000 labeled examples vs.&nbsp;millions needed from scratch.</p></div><div id="ref-yosinski2014transferable" class="csl-entry" role="listitem">
Yosinski, Jason, Jeff Clune, Yoshua Bengio, and Hod Lipson. 2014. <span>“How Transferable Are Features in Deep Neural Networks?”</span> <em>Advances in Neural Information Processing Systems</em> 27.
</div><div id="fn27"><p><sup>27</sup>&nbsp;<strong>Data Augmentation</strong>: Artificially expanding datasets through transformations like rotations, crops, or noise. Can improve model performance by 5-15% and reduce overfitting, especially when labeled data is scarce.</p></div><div id="fn28"><p><sup>28</sup>&nbsp;<strong>Active Learning</strong>: Iteratively selecting the most informative samples for labeling to maximize learning efficiency. Can achieve target performance with 50-90% less labeled data compared to random sampling.</p></div><div id="ref-Settles_2009" class="csl-entry" role="listitem">
Settles, Burr. 2012a. <em>Active Learning</em>. <em>Computer Sciences Technical Report</em>. University of Wisconsin–Madison; Springer International Publishing. <a href="https://doi.org/10.1007/978-3-031-01560-1">https://doi.org/10.1007/978-3-031-01560-1</a>.
</div><div id="fn29"><p><sup>29</sup>&nbsp;<strong>Data-Centric AI</strong>: Paradigm shift from model-centric to data-centric development, popularized by Andrew Ng in 2021. Focuses on systematically improving data quality rather than just model architecture, often yielding greater performance gains.</p></div></div><p>As systems continue growing in scale, inefficiencies of large datasets have become apparent. Data-centric AI<a href="#fn29" class="footnote-ref" id="fnref29" role="doc-noteref"><sup>29</sup></a> has emerged as a key paradigm, emphasizing data quality over quantity. This approach focuses on enhancing preprocessing, removing redundancy, and improving labeling efficiency. Research shows that careful curation and filtering can achieve comparable or superior performance while using only a fraction of original data volume <span class="citation" data-cites="penedo2024fineweb">(<a href="#ref-penedo2024fineweb" role="doc-biblioref">Penedo et al. 2024</a>)</span>.</p>
<p>Several techniques support this transition. Self-supervised learning<a href="#fn30" class="footnote-ref" id="fnref30" role="doc-noteref"><sup>30</sup></a> enables models to learn meaningful representations from unlabeled data, reducing dependency on expensive human-labeled datasets. Active learning strategies selectively identify the most informative examples for labeling, while curriculum learning<a href="#fn31" class="footnote-ref" id="fnref31" role="doc-noteref"><sup>31</sup></a> structures training to progress from simple to complex examples, improving learning efficiency.</p>
<div class="no-row-height column-margin column-container"><div id="fn30"><p><sup>30</sup>&nbsp;<strong>Self-Supervised Learning</strong>: Training method where models create their own labels from input data structure, like predicting masked words in BERT. Enables learning from billions of unlabeled examples.</p></div><div id="fn31"><p><sup>31</sup>&nbsp;<strong>Curriculum Learning</strong>: Training strategy where models learn from easy examples before progressing to harder ones, mimicking human education. Can improve convergence speed by 25-50% and final model performance.</p></div><div id="fn32"><p><sup>32</sup>&nbsp;<strong>Foundation Models</strong>: Large-scale, general-purpose AI models trained on broad data that can be adapted for many tasks. Term coined by Stanford HAI in 2021, includes models like GPT-3, BERT, and DALL-E.</p></div></div><p>Data efficiency is particularly important in foundation models<a href="#fn32" class="footnote-ref" id="fnref32" role="doc-noteref"><sup>32</sup></a>. As these models grow in scale and capability, they approach limits of available high-quality training data, especially for language tasks, as shown in <a href="#fig-running-out-of-human-data" class="quarto-xref">Figure&nbsp;12</a>. This scarcity drives innovation in data processing and curation techniques.</p>
<div id="fig-running-out-of-human-data" class="quarto-float quarto-figure quarto-figure-center anchored page-columns page-full">
<figure class="quarto-float quarto-float-fig figure page-columns page-full">
<div aria-describedby="fig-running-out-of-human-data-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<a href="images/png/running_out_of_data.png" class="lightbox" data-gallery="quarto-lightbox-gallery-12" title="Figure&nbsp;12: Dataset Growth: Foundation models are increasingly trained on vast datasets, reflecting the growing stock of human-generated text. This trend underscores the challenge of data scarcity in maintaining model performance as scale increases. Source: @villalobos_ho_sevilla_besiroglu_heim_hobbhahn_2024."><img src="images/png/running_out_of_data.png" class="img-fluid figure-img"></a>
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-running-out-of-human-data-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;12: <strong>Dataset Growth</strong>: Foundation models are increasingly trained on vast datasets, reflecting the growing stock of human-generated text. This trend underscores the challenge of data scarcity in maintaining model performance as scale increases. Source: <span class="citation" data-cites="villalobos_ho_sevilla_besiroglu_heim_hobbhahn_2024">Sevilla et al. (<a href="#ref-villalobos_ho_sevilla_besiroglu_heim_hobbhahn_2024" role="doc-biblioref">2022b</a>)</span>.
</figcaption>
<div class="no-row-height column-margin column-container"><div id="ref-villalobos_ho_sevilla_besiroglu_heim_hobbhahn_2024" class="csl-entry" role="listitem">
———. 2022b. <span>“Compute Trends Across Three Eras of Machine Learning.”</span> In <em>2022 International Joint Conference on Neural Networks (IJCNN)</em>, 1–8. IEEE. <a href="https://doi.org/10.1109/ijcnn55064.2022.9891914">https://doi.org/10.1109/ijcnn55064.2022.9891914</a>.
</div></div></figure>
</div>
<p>Evidence for data quality’s impact appears across different deployment scales. In Tiny ML<a href="#fn33" class="footnote-ref" id="fnref33" role="doc-noteref"><sup>33</sup></a> applications, datasets like Wake Vision demonstrate how performance critically depends on careful data curation <span class="citation" data-cites="banbury2024wakevisiontailoreddataset">(<a href="#ref-banbury2024wakevisiontailoreddataset" role="doc-biblioref">Banbury et al. 2024</a>)</span>. At larger scales, research on language models trained on web-scale datasets shows that intelligent filtering and selection strategies significantly improve performance on downstream tasks <span class="citation" data-cites="penedo2024fineweb">(<a href="#ref-penedo2024fineweb" role="doc-biblioref">Penedo et al. 2024</a>)</span>. <strong><a href="../benchmarking/benchmarking.html#sec-benchmarking-ai">Chapter 12: Benchmarking AI</a></strong> establishes rigorous methodologies for measuring these data quality improvements.</p>
<div class="no-row-height column-margin column-container"><div id="fn33"><p><sup>33</sup>&nbsp;<strong>TinyML</strong>: Machine learning on microcontrollers and edge devices with &lt;1KB-1MB memory and &lt;1mW power consumption. Enables AI in IoT devices, wearables, and sensors where traditional ML deployment is impossible.</p></div><div id="ref-banbury2024wakevisiontailoreddataset" class="csl-entry" role="listitem">
Banbury, Colby, Emil Njor, Andrea Mattia Garavagno, Mark Mazumder, Matthew Stewart, Pete Warden, Manjunath Kudlur, Nat Jeffries, Xenofon Fafoutis, and Vijay Janapa Reddi. 2024. <span>“Wake Vision: A Tailored Dataset and Benchmark Suite for TinyML Computer Vision Applications,”</span> May. <a href="http://arxiv.org/abs/2405.00892v5">http://arxiv.org/abs/2405.00892v5</a>.
</div><div id="ref-penedo2024fineweb" class="csl-entry" role="listitem">
Penedo, Guilherme, Hynek Kydlı́ček, Loubna Ben allal, Anton Lozhkov, Margaret Mitchell, Colin Raffel, Leandro Von Werra, and Thomas Wolf. 2024. <span>“The FineWeb Datasets: Decanting the Web for the Finest Text Data at Scale.”</span> <em>arXiv Preprint arXiv:2406.17557</em>, June. <a href="http://arxiv.org/abs/2406.17557v2">http://arxiv.org/abs/2406.17557v2</a>.
</div></div><p>This modern era of data efficiency represents a shift in how systems approach data utilization. By focusing on quality over quantity and developing sophisticated techniques for data selection and processing, the field is moving toward more sustainable and effective approaches to model training and deployment. Data efficiency is integral to scalable systems, impacting both model and compute efficiency. Smaller, higher-quality datasets reduce training times and computational demands while enabling better generalization. These principles complement the privacy-preserving techniques explored in <strong><a href="../privacy_security/privacy_security.html#sec-security-privacy">Chapter 15: Security & Privacy</a></strong>, where minimizing data requirements enhances both efficiency and user privacy protection.</p>
<div id="quiz-question-sec-efficient-ai-efficiency-framework-c0de" class="callout callout-quiz-question">
<details class="callout-quiz-question fbx-default closebutton"><summary><strong>Self-Check: Question 1.4</strong></summary><div>
<ol type="1">
<li><p>Which of the following best describes the role of algorithmic efficiency in the efficiency framework?</p>
<ol type="a">
<li>Reducing the amount of data needed for training</li>
<li>Improving the utilization of hardware resources</li>
<li>Maximizing performance per unit of computation</li>
<li>Enhancing the scalability of cloud systems</li>
</ol></li>
<li><p>Explain how coordinated optimization across algorithmic, compute, and data efficiency can lead to sustainable AI systems.</p></li>
<li><p>True or False: In mobile applications, data efficiency is prioritized over compute efficiency due to battery life constraints.</p></li>
<li><p>What is a common trade-off when optimizing for algorithmic efficiency in edge devices?</p>
<ol type="a">
<li>Increased data requirements</li>
<li>Reduced model accuracy</li>
<li>Higher computational intensity</li>
<li>Increased hardware utilization</li>
</ol></li>
<li><p>How might you apply the efficiency framework in designing an ML system for autonomous vehicles?</p></li>
</ol>
<p><a href="#quiz-answer-sec-efficient-ai-efficiency-framework-c0de" class="question-label">See Answers →</a></p>
</div></details>
</div>
</section>
</section>
</section>
<section id="sec-efficient-ai-realworld-efficiency-strategies-8387" class="level2">
<h2 class="anchored" data-anchor-id="sec-efficient-ai-realworld-efficiency-strategies-8387">Real-World Efficiency Strategies</h2>
<p>Having explored each efficiency dimension individually and their interconnections, we examine how these dimensions manifest across different deployment contexts. The efficiency of machine learning systems emerges from understanding relationships between algorithmic, compute, and data efficiency in specific operational environments.</p>
<section id="sec-efficient-ai-contextspecific-efficiency-requirements-47e6" class="level3">
<h3 class="anchored" data-anchor-id="sec-efficient-ai-contextspecific-efficiency-requirements-47e6">Context-Specific Efficiency Requirements</h3>
<p>The specific priorities and trade-offs vary dramatically across deployment environments. As our opening examples illustrated, these range from cloud systems with abundant resources to edge devices with severe memory and power constraints. <a href="#tbl-deployment-efficiency-priorities" class="quarto-xref">Table&nbsp;2</a> maps how these constraints translate into efficiency optimization priorities.</p>
<div id="tbl-deployment-efficiency-priorities" class="quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-tbl figure">
<figcaption class="quarto-float-caption-top quarto-float-caption quarto-float-tbl" id="tbl-deployment-efficiency-priorities-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Table&nbsp;2: <strong>Efficiency Optimization Priorities by Deployment Context</strong>: Each environment demands different trade-offs between algorithmic, compute, and data optimization strategies based on unique constraints. Cloud systems prioritize scalability, edge deployments focus on real-time performance, mobile applications balance performance with battery life, and TinyML demands extreme resource efficiency.
</figcaption>
<div aria-describedby="tbl-deployment-efficiency-priorities-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<table class="caption-top table">
<colgroup>
<col style="width: 13%">
<col style="width: 20%">
<col style="width: 26%">
<col style="width: 37%">
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;"><strong>Deployment Context</strong></th>
<th style="text-align: left;"><strong>Primary Constraints</strong></th>
<th style="text-align: left;"><strong>Efficiency Priorities</strong></th>
<th style="text-align: left;"><strong>Representative Applications</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><strong>Cloud</strong></td>
<td style="text-align: left;">Cost at scale, energy consumption</td>
<td style="text-align: left;">Throughput, scalability, operational efficiency</td>
<td style="text-align: left;">Large language model APIs, recommendation engines, video processing</td>
</tr>
<tr class="even">
<td style="text-align: left;"><strong>Edge</strong></td>
<td style="text-align: left;">Latency, local compute capacity, connectivity</td>
<td style="text-align: left;">Real-time performance, power efficiency</td>
<td style="text-align: left;">Autonomous vehicles, industrial automation, smart cameras</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><strong>Mobile</strong></td>
<td style="text-align: left;">Battery life, memory, thermal limits</td>
<td style="text-align: left;">Energy efficiency, model size, responsiveness</td>
<td style="text-align: left;">Voice assistants, photo enhancement, augmented reality</td>
</tr>
<tr class="even">
<td style="text-align: left;"><strong>TinyML</strong></td>
<td style="text-align: left;">Extreme power/memory constraints</td>
<td style="text-align: left;">Ultra-low power, minimal model size</td>
<td style="text-align: left;">IoT sensors, wearables, environmental monitoring</td>
</tr>
</tbody>
</table>
</div>
</figure>
</div>
<p>Understanding these context-specific patterns enables designers to make informed decisions about which efficiency dimensions to prioritize and how to navigate inevitable trade-offs.</p>
</section>
<section id="sec-efficient-ai-scalability-sustainability-4d30" class="level3">
<h3 class="anchored" data-anchor-id="sec-efficient-ai-scalability-sustainability-4d30">Scalability and Sustainability</h3>
<p>System efficiency serves as a driver of environmental sustainability. When systems are optimized for efficiency, they can be deployed at scale while minimizing environmental footprint. This relationship creates a positive feedback loop, as shown in <a href="#fig-virtuous-efficiency-cycle" class="quarto-xref">Figure&nbsp;13</a>.</p>
<div id="fig-virtuous-efficiency-cycle" class="quarto-float quarto-figure quarto-figure-center anchored" data-fig-env="figure" data-fig-pos="htb">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-virtuous-efficiency-cycle-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<a href="8ff5d037eed695d0dcda2db19bf7a200a9084b98.svg" class="lightbox" data-gallery="quarto-lightbox-gallery-13" title="Figure&nbsp;13: : Efficiency and Sustainability Feedback Loop: Optimized machine learning systems achieve greater scalability, which in turn incentivizes sustainable design practices and further efficiency improvements, creating a reinforcing feedback loop for long-term impact."><img src="efficient_ai_files/mediabag/8ff5d037eed695d0dcda2db19bf7a200a9084b98.svg" class="img-fluid figure-img"></a>
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-virtuous-efficiency-cycle-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;13: : <strong>Efficiency and Sustainability Feedback Loop</strong>: Optimized machine learning systems achieve greater scalability, which in turn incentivizes sustainable design practices and further efficiency improvements, creating a reinforcing feedback loop for long-term impact.
</figcaption>
</figure>
</div>
<p>Efficient systems are inherently scalable. Reducing resource demands through lightweight models, targeted datasets, and optimized compute utilization allows systems to deploy broadly. When efficient systems scale, they amplify their contribution to sustainability by reducing overall energy consumption and computational waste. Sustainability reinforces the need for efficiency, creating a feedback loop that strengthens the entire system.</p>
<div id="quiz-question-sec-efficient-ai-realworld-efficiency-strategies-8387" class="callout callout-quiz-question">
<details class="callout-quiz-question fbx-default closebutton"><summary><strong>Self-Check: Question 1.5</strong></summary><div>
<ol type="1">
<li><p>Which deployment context prioritizes real-time performance and power efficiency due to local compute capacity and connectivity constraints?</p>
<ol type="a">
<li>Edge</li>
<li>Cloud</li>
<li>Mobile</li>
<li>TinyML</li>
</ol></li>
<li><p>Explain how system efficiency contributes to scalability and sustainability in machine learning deployments.</p></li>
<li><p>Order the following deployment contexts by their primary efficiency priority from highest to lowest: (1) Cloud, (2) Edge, (3) Mobile, (4) TinyML.</p></li>
<li><p>True or False: In TinyML deployments, model size is prioritized over power efficiency.</p></li>
</ol>
<p><a href="#quiz-answer-sec-efficient-ai-realworld-efficiency-strategies-8387" class="question-label">See Answers →</a></p>
</div></details>
</div>
</section>
</section>
<section id="sec-efficient-ai-efficiency-tradeoffs-challenges-946d" class="level2">
<h2 class="anchored" data-anchor-id="sec-efficient-ai-efficiency-tradeoffs-challenges-946d">Efficiency Trade-offs and Challenges</h2>
<p>The three efficiency dimensions can work synergistically under favorable conditions, but real-world systems often face scenarios where improving one dimension degrades another. The same resource constraints that make efficiency necessary force difficult choices: reducing model size may sacrifice accuracy, optimizing for real-time performance may increase energy consumption, and curating smaller datasets may limit generalization.</p>
<section id="sec-efficient-ai-fundamental-sources-efficiency-tradeoffs-d16f" class="level3">
<h3 class="anchored" data-anchor-id="sec-efficient-ai-fundamental-sources-efficiency-tradeoffs-d16f">Fundamental Sources of Efficiency Trade-offs</h3>
<p>These tensions manifest in various ways across machine learning systems. Understanding their root causes is essential for addressing design challenges. Each efficiency dimension influences the others, creating a dynamic interplay that shapes system performance.</p>
<section id="sec-efficient-ai-algorithmic-efficiency-vs-compute-requirements-83a7" class="level4">
<h4 class="anchored" data-anchor-id="sec-efficient-ai-algorithmic-efficiency-vs-compute-requirements-83a7">Algorithmic Efficiency vs.&nbsp;Compute Requirements</h4>
<p>Algorithmic efficiency focuses on designing compact models that minimize computational and memory demands. By reducing model size or complexity, deployment on resource-limited devices becomes feasible. Overly simplifying a model can reduce accuracy, especially for complex tasks. To compensate for this loss, additional computational resources may be required during training or deployment, placing strain on compute efficiency.</p>
</section>
<section id="sec-efficient-ai-compute-efficiency-vs-realtime-needs-a269" class="level4">
<h4 class="anchored" data-anchor-id="sec-efficient-ai-compute-efficiency-vs-realtime-needs-a269">Compute Efficiency vs.&nbsp;Real-Time Needs</h4>
<p>Compute efficiency aims to minimize resources required for training and inference, reducing energy consumption, processing time, and memory use. In scenarios requiring real-time responsiveness (autonomous vehicles, augmented reality), compute efficiency becomes harder to maintain. <a href="#fig-efficiency-vs-latency" class="quarto-xref">Figure&nbsp;14</a> illustrates this challenge: real-time systems often require high-performance hardware to process data instantly, conflicting with energy efficiency goals or increasing system costs.</p>
<div id="fig-efficiency-vs-latency" class="quarto-float quarto-figure quarto-figure-center anchored" data-fig-env="figure" data-fig-pos="htb">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-efficiency-vs-latency-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<a href="1ed2becdb8c20bbfe74e21c91c64885a70a192ca.svg" class="lightbox" data-gallery="quarto-lightbox-gallery-14" title="Figure&nbsp;14: : Real-Time System Constraints: Autonomous vehicles demand careful balance between computational efficiency and low latency. Increasing processing power to reduce delay can conflict with energy and cost limitations, yet sacrificing latency compromises safety by increasing reaction time and braking distance."><img src="efficient_ai_files/mediabag/1ed2becdb8c20bbfe74e21c91c64885a70a192ca.svg" class="img-fluid figure-img"></a>
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-efficiency-vs-latency-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;14: : <strong>Real-Time System Constraints</strong>: Autonomous vehicles demand careful balance between computational efficiency and low latency. Increasing processing power to reduce delay can conflict with energy and cost limitations, yet sacrificing latency compromises safety by increasing reaction time and braking distance.
</figcaption>
</figure>
</div>
</section>
<section id="sec-efficient-ai-data-efficiency-vs-model-generalization-044a" class="level4">
<h4 class="anchored" data-anchor-id="sec-efficient-ai-data-efficiency-vs-model-generalization-044a">Data Efficiency vs.&nbsp;Model Generalization</h4>
<p>Data efficiency seeks to minimize the amount of data required to train a model without sacrificing performance. By curating smaller, high-quality datasets, training becomes faster and less resource-intensive. Ideally, this reinforces both algorithmic and compute efficiency. However, reducing dataset size can limit diversity, making it harder for models to generalize to unseen scenarios. To address this, additional compute resources or model complexity may be required, creating tension between data efficiency and broader system goals.</p>
</section>
</section>
<section id="sec-efficient-ai-recurring-tradeoff-patterns-practice-c205" class="level3">
<h3 class="anchored" data-anchor-id="sec-efficient-ai-recurring-tradeoff-patterns-practice-c205">Recurring Trade-off Patterns in Practice</h3>
<p>The trade-offs between efficiency dimensions become particularly evident when examining specific scenarios. Complex models with millions or billions of parameters can achieve higher accuracy by capturing intricate patterns, but require significant computational power and memory. A recommendation system in a cloud data center might use a highly complex model for better recommendations, but at the cost of higher energy consumption and operating costs. On resource-constrained devices like smartphones or autonomous vehicles, compact models may operate efficiently but require more sophisticated data preprocessing or training procedures to compensate for reduced capacity.</p>
<p>Energy efficiency and real-time performance often pull systems in opposite directions. Real-time systems like autonomous vehicles or augmented reality applications rely on high-performance hardware to process large volumes of data quickly, but this typically increases energy consumption. An autonomous vehicle must process sensor data from cameras, LiDAR, and radar in real time to make navigation decisions, requiring specialized accelerators that consume significant energy. In edge deployments with battery power or limited energy sources, this trade-off becomes even more critical.</p>
<p>Larger datasets generally provide greater diversity and coverage, enabling models to capture subtle patterns and reduce overfitting risk. However, computational and memory demands of training on large datasets can be substantial. In resource-constrained environments like TinyML deployments, an IoT device monitoring environmental conditions might need a model that generalizes well across varying conditions, but collecting extensive datasets may be impractical due to storage and computational limitations. Smaller, carefully curated datasets or synthetic data may be used to reduce computational strain, but this risks missing key edge cases.</p>
<p>These trade-offs are not merely academic concerns but practical realities that shape system design decisions across all deployment contexts.</p>
<div id="quiz-question-sec-efficient-ai-efficiency-tradeoffs-challenges-946d" class="callout callout-quiz-question">
<details class="callout-quiz-question fbx-default closebutton"><summary><strong>Self-Check: Question 1.6</strong></summary><div>
<ol type="1">
<li><p>Which of the following best describes the trade-off between algorithmic efficiency and compute requirements?</p>
<ol type="a">
<li>Reducing model size always improves accuracy.</li>
<li>Simplifying models can reduce computational demands but may decrease accuracy.</li>
<li>Increasing model complexity always reduces energy consumption.</li>
<li>Deploying models on resource-limited devices requires no trade-offs.</li>
</ol></li>
<li><p>Explain how real-time performance requirements can conflict with compute efficiency in ML systems.</p></li>
<li><p>In a production system where energy efficiency is critical, which strategy might be prioritized?</p>
<ol type="a">
<li>Using high-performance GPUs for all tasks.</li>
<li>Deploying complex models without considering energy consumption.</li>
<li>Ignoring latency requirements to save energy.</li>
<li>Optimizing models to run on low-power hardware.</li>
</ol></li>
<li><p>In scenarios requiring real-time responsiveness, such as autonomous vehicles, the trade-off between computational efficiency and low latency often requires balancing ________ and energy consumption.</p></li>
<li><p>In your experience with ML systems, how might you address the trade-off between data efficiency and model generalization?</p></li>
</ol>
<p><a href="#quiz-answer-sec-efficient-ai-efficiency-tradeoffs-challenges-946d" class="question-label">See Answers →</a></p>
</div></details>
</div>
</section>
</section>
<section id="sec-efficient-ai-strategic-tradeoff-management-0ac8" class="level2 page-columns page-full">
<h2 class="anchored" data-anchor-id="sec-efficient-ai-strategic-tradeoff-management-0ac8">Strategic Trade-off Management</h2>
<p>The trade-offs inherent in machine learning system design require thoughtful strategies to navigate effectively. Achieving the right balance involves difficult decisions heavily influenced by specific goals and constraints of the deployment environment. Designers can adopt a range of strategies that address unique requirements of different contexts.</p>
<section id="sec-efficient-ai-environmentdriven-efficiency-priorities-4057" class="level3">
<h3 class="anchored" data-anchor-id="sec-efficient-ai-environmentdriven-efficiency-priorities-4057">Environment-Driven Efficiency Priorities</h3>
<p>Efficiency goals are rarely universal. The specific demands of an application or deployment scenario heavily influence which dimension—algorithmic, compute, or data—takes precedence. Prioritizing the right dimensions based on context is the first step in effectively managing trade-offs.</p>
<p>In Mobile ML deployments, battery life is often the primary constraint, placing a premium on compute efficiency. Energy consumption must be minimized to preserve operational time, so lightweight models are prioritized even if it means sacrificing some accuracy or requiring additional data preprocessing.</p>
<p>In Cloud ML systems, scalability and throughput are paramount. These systems must process large volumes of data and serve millions of users simultaneously. While compute resources are more abundant, energy efficiency and operational costs remain important. Algorithmic efficiency plays a critical role in ensuring systems can scale without overwhelming infrastructure.</p>
<p>Edge ML systems present different priorities. Autonomous vehicles or real-time monitoring systems require low-latency processing for safe and reliable operation, making real-time performance and compute efficiency paramount, often at the expense of energy consumption. However, hardware constraints mean these systems must still carefully manage energy and computational resources.</p>
<p><strong>TinyML</strong> deployments demand extreme efficiency due to severe hardware and energy limitations. Algorithmic and data efficiency are top priorities, with models highly compact and capable of operating on microcontrollers with minimal memory and compute power, while training relies on small, carefully curated datasets.</p>
</section>
<section id="sec-efficient-ai-dynamic-resource-allocation-inference-d6bc" class="level3">
<h3 class="anchored" data-anchor-id="sec-efficient-ai-dynamic-resource-allocation-inference-d6bc">Dynamic Resource Allocation at Inference</h3>
<p>System adaptability can be enhanced through dynamic resource allocation during inference. This approach recognizes that resource needs may fluctuate even within specific deployment contexts. By adjusting computational effort at inference time, systems can fine-tune performance to meet immediate demands.</p>
<p>For example, a cloud-based video analysis system might process standard streams with a streamlined model to maintain high throughput, but when a critical event is detected, dynamically allocate more resources to a complex model for higher precision. Similarly, mobile voice assistants might use lightweight models for routine commands to conserve battery, but temporarily activate resource-intensive models for complex queries.</p>
<p>Implementing test-time compute introduces new challenges. Dynamic resource allocation requires sophisticated monitoring and control mechanisms. There are diminishing returns—increasing compute beyond certain thresholds may not yield significant performance improvements. The ability to dynamically increase compute can also create disparities in access to high-performance AI, raising equity concerns. Despite these challenges, test-time compute offers a valuable strategy for enhancing system adaptability.</p>
</section>
<section id="sec-efficient-ai-endtoend-codesign-automated-optimization-1220" class="level3 page-columns page-full">
<h3 class="anchored" data-anchor-id="sec-efficient-ai-endtoend-codesign-automated-optimization-1220">End-to-End Co-Design and Automated Optimization</h3>
<p>Efficient machine learning systems are rarely the product of isolated optimizations. Achieving balance across efficiency dimensions requires an end-to-end co-design perspective, where each system component is designed in tandem with others. This holistic approach aligns model architectures, hardware platforms, and data pipelines to work seamlessly together.</p>
<p>Co-design becomes essential in resource-constrained environments. Models must align precisely with hardware capabilities—8-bit models require hardware support for efficient integer operations, while pruned models benefit from sparse tensor operations. Edge accelerators often optimize specific operations like convolutions, influencing model architecture choices. Detailed hardware architecture considerations are covered comprehensively in <strong><a href="../hw_acceleration/hw_acceleration.html#sec-ai-acceleration">Chapter 11: AI Acceleration</a></strong>.</p>
<p><strong>Automation and optimization tools</strong> help manage the complexity of navigating trade-offs. Automated machine learning (AutoML)<a href="#fn34" class="footnote-ref" id="fnref34" role="doc-noteref"><sup>34</sup></a> enables exploration of different model architectures and hyperparameter configurations. Building on the systematic approach to ML workflows introduced in <strong><a href="../workflow/workflow.html#sec-ai-workflow">Chapter 5: AI Workflow</a></strong>, AutoML tools automate many efficiency optimization decisions that traditionally required extensive manual tuning.</p>
<div class="no-row-height column-margin column-container"><div id="fn34"><p><sup>34</sup>&nbsp;<strong>AutoML</strong>: Automated machine learning that systematically searches through model architectures, hyperparameters, and data preprocessing options. Google’s AutoML achieved 84.3% ImageNet accuracy vs.&nbsp;human experts’ 78.5%, while reducing development time from months to hours.</p></div><div id="fn35"><p><sup>35</sup>&nbsp;<strong>Neural Architecture Search (NAS)</strong>: Automated method for discovering optimal neural network architectures. EfficientNet-B7, discovered via NAS, achieved 84.3% ImageNet accuracy with 37M parameters vs.&nbsp;hand-designed ResNeXt-101’s 80.9% with 84M parameters.</p></div></div><p>Neural architecture search (NAS)<a href="#fn35" class="footnote-ref" id="fnref35" role="doc-noteref"><sup>35</sup></a> takes automation further by designing model architectures tailored to specific hardware or deployment scenarios, evaluating a wide range of architectural possibilities to maximize performance while minimizing computational demands.</p>
<p>Data efficiency also benefits from automation. Tools that automate dataset curation, augmentation, and active learning reduce training dataset size without sacrificing performance, prioritizing high-value data points to speed up training and reduce computational overhead <span class="citation" data-cites="settles2009active">(<a href="#ref-settles2009active" role="doc-biblioref">Settles 2012b</a>)</span>. <strong><a href="../frameworks/frameworks.html#sec-ai-frameworks">Chapter 7: AI Frameworks</a></strong> explores how modern ML frameworks incorporate these automation capabilities.</p>
<div class="no-row-height column-margin column-container"><div id="ref-settles2009active" class="csl-entry" role="listitem">
———. 2012b. <em>Active Learning</em>. <em>University of Wisconsin-Madison Department of Computer Sciences</em>. Vol. 1648. Springer International Publishing. <a href="https://doi.org/10.1007/978-3-031-01560-1">https://doi.org/10.1007/978-3-031-01560-1</a>.
</div></div></section>
<section id="sec-efficient-ai-measuring-monitoring-efficiency-tradeoffs-fd5b" class="level3">
<h3 class="anchored" data-anchor-id="sec-efficient-ai-measuring-monitoring-efficiency-tradeoffs-fd5b">Measuring and Monitoring Efficiency Trade-offs</h3>
<p>Beyond technical automation lies the broader challenge of systematic evaluation. Efficiency optimization necessitates a structured approach assessing trade-offs that extends beyond purely technical considerations. As systems transition from research to production, success criteria must encompass algorithmic performance, economic viability, and operational sustainability.</p>
<p>Costs associated with efficiency improvements manifest across engineering effort (research, experimentation, integration), balanced against ongoing operational expenses of running less efficient systems. Benefits span multiple domains—beyond direct cost reductions, efficient systems often enable qualitatively new capabilities like real-time processing in resource-constrained environments or deployment to edge devices.</p>
<p>This evaluation framework must be complemented by ongoing assessment mechanisms. The dynamic nature of ML systems in production necessitates continuous monitoring of efficiency characteristics. As models evolve, data distributions shift, and infrastructure changes, efficiency properties can degrade. Real-time monitoring enables rapid detection of efficiency regressions, while historical analysis provides insight into longer-term trends, revealing whether efficiency improvements are sustainable under changing conditions.</p>
<div id="quiz-question-sec-efficient-ai-strategic-tradeoff-management-0ac8" class="callout callout-quiz-question">
<details class="callout-quiz-question fbx-default closebutton"><summary><strong>Self-Check: Question 1.7</strong></summary><div>
<ol type="1">
<li><p>Which of the following is a primary concern in mobile ML deployments?</p>
<ol type="a">
<li>Algorithmic accuracy</li>
<li>Scalability</li>
<li>Data efficiency</li>
<li>Compute efficiency</li>
</ol></li>
<li><p>Explain how test-time compute can enhance system adaptability in cloud ML systems.</p></li>
<li><p>Order the following deployment contexts by their primary efficiency priority from highest to lowest: (1) Mobile ML, (2) Cloud ML, (3) Edge ML, (4) TinyML.</p></li>
<li><p>In TinyML deployments, the primary focus is on ____ efficiency due to severe hardware and energy limitations.</p></li>
<li><p>How does co-design contribute to managing trade-offs in resource-constrained ML environments?</p></li>
</ol>
<p><a href="#quiz-answer-sec-efficient-ai-strategic-tradeoff-management-0ac8" class="question-label">See Answers →</a></p>
</div></details>
</div>
</section>
</section>
<section id="sec-efficient-ai-engineering-principles-efficient-ai-1206" class="level2">
<h2 class="anchored" data-anchor-id="sec-efficient-ai-engineering-principles-efficient-ai-1206">Engineering Principles for Efficient AI</h2>
<p>Designing an efficient machine learning system requires a holistic approach. True efficiency emerges when the entire system is considered as a whole, ensuring trade-offs are balanced across all stages of the ML pipeline from data collection to deployment. This end-to-end perspective transforms system design.</p>
<section id="sec-efficient-ai-holistic-pipeline-optimization-5bcc" class="level3">
<h3 class="anchored" data-anchor-id="sec-efficient-ai-holistic-pipeline-optimization-5bcc">Holistic Pipeline Optimization</h3>
<p>Efficiency is achieved not through isolated optimizations but by considering the entire pipeline as a unified whole. Each stage—data collection, model training, hardware deployment, and inference—contributes to overall system efficiency. Decisions at one stage ripple through the rest, influencing performance, resource use, and scalability.</p>
<p>Data collection and preprocessing are starting points. <strong><a href="../data_engineering/data_engineering.html#sec-data-engineering">Chapter 6: Data Engineering</a></strong> provides comprehensive coverage of how data pipeline design decisions cascade through the entire system. Curating smaller, high-quality datasets can reduce computational costs during training while simplifying model design. However, insufficient data diversity may affect generalization, necessitating compensatory measures.</p>
<p>Model training is another critical stage. Architecture choice, optimization techniques, and hyperparameters must consider deployment hardware constraints. A model designed for high-performance cloud systems may emphasize accuracy and scalability, while models for edge devices must balance accuracy with size and energy efficiency.</p>
<p>Deployment and inference demand precise hardware alignment. Each platform offers distinct capabilities—GPUs excel at parallel matrix operations, TPUs optimize specific neural network computations, and microcontrollers provide energy-efficient processing. A smartphone speech recognition system might leverage an NPU’s dedicated convolution units for millisecond-level inference at low power, while an autonomous vehicle’s FPGA processes multiple sensor streams with microsecond-level latency.</p>
<p>An end-to-end perspective ensures trade-offs are addressed holistically rather than shifting inefficiencies between pipeline stages. This systems thinking approach becomes particularly critical when deploying to resource-constrained environments, as explored in <strong><a href="../ondevice_learning/ondevice_learning.html#sec-ondevice-learning">Chapter 14: On-Device Learning</a></strong>.</p>
</section>
<section id="sec-efficient-ai-lifecycle-environment-considerations-3abc" class="level3">
<h3 class="anchored" data-anchor-id="sec-efficient-ai-lifecycle-environment-considerations-3abc">Lifecycle and Environment Considerations</h3>
<p>Efficiency needs differ significantly depending on lifecycle stage and deployment environment—from research prototypes to production systems, from high-performance cloud to resource-constrained edge.</p>
<p>In research, the primary focus is often model performance, with efficiency taking a secondary role. Prototypes are trained using abundant compute resources, enabling exploration of large architectures and extensive hyperparameter tuning. Production systems must prioritize efficiency to operate within practical constraints, often involving significant optimization like model pruning, quantization, or retraining. Production also requires continuous monitoring of efficiency metrics and operational frameworks for managing trade-offs at scale—comprehensive production efficiency management strategies are detailed in <strong><a href="../ops/ops.html#sec-ml-operations">Chapter 13: ML Operations</a></strong>.</p>
<p>Cloud-based systems handle massive workloads with relatively abundant resources, though energy efficiency and operational costs remain critical. The ML systems design principles covered in <strong><a href="../ml_systems/ml_systems.html#sec-ml-systems">Chapter 2: ML Systems</a></strong> provide architectural foundations for building scalable, efficiency-optimized cloud deployments. In contrast, edge and mobile systems operate under strict constraints detailed in our efficiency framework, demanding solutions prioritizing efficiency over raw performance.</p>
<p>Some systems like recommendation engines require frequent retraining to remain effective, depending heavily on data efficiency with actively labeled datasets and sampling strategies. Other systems like embedded models in medical devices require long-term stability with minimal updates. <strong><a href="../robust_ai/robust_ai.html#sec-robust-ai">Chapter 16: Robust AI</a></strong> examines how reliability requirements in critical applications influence efficiency optimization strategies.</p>
<div id="quiz-question-sec-efficient-ai-engineering-principles-efficient-ai-1206" class="callout callout-quiz-question">
<details class="callout-quiz-question fbx-default closebutton"><summary><strong>Self-Check: Question 1.8</strong></summary><div>
<ol type="1">
<li><p>Which of the following best describes the importance of system-level thinking in designing efficient ML systems?</p>
<ol type="a">
<li>Focusing on optimizing individual components separately.</li>
<li>Maximizing the performance of the model at any cost.</li>
<li>Prioritizing hardware-specific optimizations.</li>
<li>Considering the entire ML pipeline as a unified whole.</li>
</ol></li>
<li><p>Explain how decisions made during data collection can impact other stages of the ML pipeline.</p></li>
<li><p>In a production ML system for edge devices, which trade-off is most critical?</p>
<ol type="a">
<li>Balancing model accuracy with size and energy efficiency.</li>
<li>Maximizing model accuracy at the expense of size.</li>
<li>Focusing solely on reducing computational costs.</li>
<li>Prioritizing extensive hyperparameter tuning.</li>
</ol></li>
<li><p>Order the following ML pipeline stages by their typical sequence in achieving system-level efficiency: (1) Model Training, (2) Data Collection, (3) Deployment and Inference.</p></li>
</ol>
<p><a href="#quiz-answer-sec-efficient-ai-engineering-principles-efficient-ai-1206" class="question-label">See Answers →</a></p>
</div></details>
</div>
</section>
</section>
<section id="sec-efficient-ai-societal-ethical-implications-d0e5" class="level2 page-columns page-full">
<h2 class="anchored" data-anchor-id="sec-efficient-ai-societal-ethical-implications-d0e5">Societal and Ethical Implications</h2>
<p>While efficiency in machine learning is often framed as a technical challenge, it is also deeply tied to broader questions about AI systems’ purpose and impact. Designing efficient systems involves navigating not only practical trade-offs but also complex ethical and philosophical considerations. <strong><a href="../responsible_ai/responsible_ai.html#sec-responsible-ai">Chapter 17: Responsible AI</a></strong> provides a comprehensive framework for addressing these ethical considerations.</p>
<section id="sec-efficient-ai-equity-access-c38d" class="level3 page-columns page-full">
<h3 class="anchored" data-anchor-id="sec-efficient-ai-equity-access-c38d">Equity and Access</h3>
<p>Efficiency has the potential to reduce costs, improve scalability, and expand accessibility. However, resources needed to achieve efficiency—advanced hardware, curated datasets, state-of-the-art optimization techniques—are often concentrated in well-funded organizations, creating inequities in who can leverage efficiency gains.</p>
<p>Training costs for state-of-the-art models like GPT-4 and Gemini Ultra require tens to hundreds of millions of dollars worth of compute <span class="citation" data-cites="perrault2024artificial">(<a href="#ref-perrault2024artificial" role="doc-biblioref">Maslej et al. 2024</a>)</span>. Research by <a href="https://oecd.ai/en/">OECD.AI</a> indicates that 90% of global AI computing capacity is centralized in only five countries <span class="citation" data-cites="oecd_ai_2021">(<a href="#ref-oecd_ai_2021" role="doc-biblioref">OECD.AI 2021</a>)</span>. Academic institutions often lack hardware needed to replicate state-of-the-art results, stifling innovation in underfunded sectors. Energy-efficient compute technologies like accelerators for TinyML or Mobile ML present promising avenues for democratization. By enabling powerful processing on low-cost, low-power devices, these technologies allow organizations without high-end infrastructure access to build impactful systems.</p>
<div class="no-row-height column-margin column-container"><div id="ref-perrault2024artificial" class="csl-entry" role="listitem">
Maslej, Nestor, Loredana Fattorini, C. Raymond Perrault, Vanessa Parli, Anka Reuel, Erik Brynjolfsson, John Etchemendy, et al. 2024. <span>“Artificial Intelligence Index Report 2024.”</span> <em>CoRR</em>. <a href="https://doi.org/10.48550/ARXIV.2405.19522">https://doi.org/10.48550/ARXIV.2405.19522</a>.
</div><div id="ref-oecd_ai_2021" class="csl-entry" role="listitem">
OECD.AI. 2021. <span>“Measuring the Geographic Distribution of AI Computing Capacity.”</span> &lt;https://oecd.ai/en/policy-circle/computing-capacity&gt;.
</div></div><p>Data efficiency is essential where high-quality datasets are scarce, but achieving it is unequally distributed. NLP for low-resource languages suffers from lack of sufficient training data, leading to significant performance gaps. Efforts like the Masakhane project building open-source datasets for African languages show how collaborative initiatives can address this, though scaling globally requires greater investment. Democratizing data efficiency requires more open sharing of pre-trained models and datasets. Initiatives like Hugging Face’s open access to transformers or Meta’s No Language Left Behind aim to make state-of-the-art NLP models available worldwide, reducing barriers for data-scarce regions.</p>
<p>Algorithmic efficiency plays a crucial role in democratizing ML by enabling advanced capabilities on low-cost, resource-constrained devices. AI-powered diagnostic tools on smartphones are transforming healthcare in remote areas, while low-power TinyML models enable environmental monitoring in regions without reliable electricity.</p>
<p>Technologies like <a href="https://ai.google.dev/edge/litert">TensorFlow Lite</a> and <a href="https://pytorch.org/mobile/home/">PyTorch Mobile</a> allow developers to deploy lightweight models on everyday devices, expanding access in resource-constrained settings. Open-source efforts to share pre-optimized models like MobileNet or EfficientNet play a critical role by allowing under-resourced organizations to deploy state-of-the-art solutions.</p>
</section>
<section id="sec-efficient-ai-balancing-innovation-efficiency-demands-7a44" class="level3">
<h3 class="anchored" data-anchor-id="sec-efficient-ai-balancing-innovation-efficiency-demands-7a44">Balancing Innovation with Efficiency Demands</h3>
<p>The pursuit of efficiency often brings tension between optimizing for what is known and exploring what is new. Equity concerns are intensified by this tension: resource concentration in well-funded organizations enables expensive exploratory research, while resource-constrained institutions must focus on incremental improvements.</p>
<p>Efficiency often favors established techniques proven to work well. Optimizing neural networks through pruning, quantization, or distillation typically refines existing architectures rather than developing entirely new ones. Consider the shift from traditional ML to deep learning: early neural network research in the 1990s-2000s required significant resources and often failed to outperform simpler methods, yet researchers persisted, eventually leading to breakthroughs defining modern AI.</p>
<p>Pioneering research often requires significant resources. Large language models like GPT-4 or PaLM are not inherently efficient—their training consumes enormous compute and energy. Yet these models have opened entirely new possibilities, prompting advancements that eventually lead to more efficient systems like smaller fine-tuned versions.</p>
<p>This reliance on resource-intensive innovation raises questions about who gets to participate. Well-funded organizations can afford to explore new frontiers, while smaller institutions may be constrained to incremental improvements prioritizing efficiency over novelty.</p>
<p>Efficiency-focused design often requires adhering to strict constraints like reducing model size or latency. While constraints can drive ingenuity, they can also limit exploration scope. However, the drive for efficiency can positively impact innovation—constraints force creative thinking, leading to new methods maximizing performance within tight resource budgets. Techniques like NAS and attention mechanisms arose partly from the need to balance performance and efficiency.</p>
<p>Organizations and researchers must recognize when to prioritize efficiency and when to embrace experimentation risks. Applied systems for real-world deployment may demand strict efficiency, while exploratory research labs can focus on pushing boundaries. The relationship between innovation and efficiency is not adversarial but complementary—efficient systems create foundations for scalable applications, while resource-intensive experimentation drives breakthroughs redefining what’s possible.</p>
</section>
<section id="sec-efficient-ai-optimization-limits-20f0" class="level3 page-columns page-full">
<h3 class="anchored" data-anchor-id="sec-efficient-ai-optimization-limits-20f0">Optimization Limits</h3>
<p>The tensions between equity, innovation, and efficiency ultimately stem from a fundamental characteristic of optimization: diminishing returns. Optimization is central to building efficient ML systems, but it is not infinite. As systems become more refined, each additional improvement requires exponentially more effort, time, or resources while delivering increasingly smaller benefits.</p>
<p>The No Free Lunch (NFL) theorems<a href="#fn36" class="footnote-ref" id="fnref36" role="doc-noteref"><sup>36</sup></a> for optimization illustrate inherent limitations. According to NFL theorems, no single optimization algorithm can outperform all others across every possible problem, implying optimization technique effectiveness is highly problem-specific <span class="citation" data-cites="wolpert1997no">(<a href="#ref-wolpert1997no" role="doc-biblioref">Wolpert and Macready 1997</a>)</span>.</p>
<div class="no-row-height column-margin column-container"><div id="fn36"><p><sup>36</sup>&nbsp;<strong>No Free Lunch (NFL) Theorems</strong>: Mathematical proof by Wolpert and Macready (1997) showing that averaged over all possible optimization problems, every algorithm performs equally well. In ML context, no universal optimization technique exists—methods must be tailored to specific problem domains.</p></div><div id="ref-wolpert1997no" class="csl-entry" role="listitem">
Wolpert, D. H., and W. G. Macready. 1997. <span>“No Free Lunch Theorems for Optimization.”</span> <em>IEEE Transactions on Evolutionary Computation</em> 1 (1): 67–82. <a href="https://doi.org/10.1109/4235.585893">https://doi.org/10.1109/4235.585893</a>.
</div></div><p>For example, compressing an ML model can initially reduce memory and compute requirements significantly with minimal accuracy loss. However, as compression progresses, maintaining performance becomes increasingly challenging. Achieving additional gains may necessitate sophisticated techniques like hardware-specific optimizations or extensive retraining, increasing complexity and cost. These costs extend beyond financial investment to include time, expertise, iterative testing, and potential trade-offs in robustness and generalizability.</p>
<p>The NFL theorems highlight that no universal optimization solution exists, emphasizing need to balance efficiency pursuits with practical considerations. Over-optimization risks wasted resources and reduced adaptability, complicating future updates. Identifying when a system is “good enough” ensures resources are allocated effectively.</p>
<p>Similarly, optimizing datasets for training efficiency may initially save resources, but excessively reducing dataset size risks compromising diversity and weakening generalization. Pushing hardware to performance limits may improve metrics like latency, yet associated reliability concerns and engineering costs can outweigh gains.</p>
<p>Understanding optimization limits is essential for creating systems balancing efficiency with practicality and sustainability. This perspective helps avoid over-optimization and ensures resources are invested in areas with meaningful returns.</p>
<section id="sec-efficient-ai-moores-law-case-study-5767" class="level4 page-columns page-full">
<h4 class="anchored" data-anchor-id="sec-efficient-ai-moores-law-case-study-5767">Moore’s Law Case Study</h4>
<p>One of the most insightful examples of optimization limits appears in Moore’s Law and the economic curve underlying it. While Moore’s Law is celebrated as a predictor of exponential computational power growth, its success relied on intricate economic balance. The relationship between integration and cost provides a compelling analogy for diminishing returns in ML optimization.</p>
<p><a href="#fig-moores-law-plot" class="quarto-xref">Figure&nbsp;15</a> shows relative manufacturing cost per component as the number of components in an integrated circuit increases. Initially, as more components are packed onto a chip, cost per component decreases due to economies of scale—higher integration reduces need for packaging and interconnects. Moving from hundreds to thousands of components drastically reduced costs and improved performance <span class="citation" data-cites="moore2021cramming">(<a href="#ref-moore2021cramming" role="doc-biblioref">Moore 2021</a>)</span>.</p>
<div class="no-row-height column-margin column-container"></div><div id="fig-moores-law-plot" class="quarto-float quarto-figure quarto-figure-center anchored page-columns page-full" data-fig-env="figure" data-fig-pos="htb">
<figure class="quarto-float quarto-float-fig figure page-columns page-full">
<div aria-describedby="fig-moores-law-plot-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<a href="f9f984606d637e71ea667911c29735a879b2f63a.svg" class="lightbox" data-gallery="quarto-lightbox-gallery-15" title="Figure&nbsp;15: : Moore’s Law Economics: Declining per-component manufacturing costs initially drove exponential growth in integrated circuit complexity, but diminishing returns eventually limited further cost reductions. This relationship mirrors optimization challenges in machine learning, where increasing model complexity yields diminishing gains in performance relative to computational expense. Source: [@moore2021cramming]."><img src="efficient_ai_files/mediabag/f9f984606d637e71ea667911c29735a879b2f63a.svg" class="img-fluid figure-img"></a>
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-moores-law-plot-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;15: : <strong>Moore’s Law Economics</strong>: Declining per-component manufacturing costs initially drove exponential growth in integrated circuit complexity, but diminishing returns eventually limited further cost reductions. This relationship mirrors optimization challenges in machine learning, where increasing model complexity yields diminishing gains in performance relative to computational expense. Source: <span class="citation" data-cites="moore2021cramming">(<a href="#ref-moore2021cramming" role="doc-biblioref">Moore 2021</a>)</span>.
</figcaption>
<div class="no-row-height column-margin column-container"><div id="ref-moore2021cramming" class="csl-entry" role="listitem">
Moore, Gordon. 2021. <span>“Cramming More Components onto Integrated Circuits (1965).”</span> In <em>Ideas That Created the Future</em>, 261–66. The MIT Press. <a href="https://doi.org/10.7551/mitpress/12274.003.0027">https://doi.org/10.7551/mitpress/12274.003.0027</a>.
</div></div></figure>
</div>
<p>However, as integration continues, the curve begins to rise. Components packed closer together face reliability issues like increased heat dissipation and signal interference. Addressing these requires more sophisticated manufacturing techniques—advanced lithography, error correction, improved materials—increasing complexity and cost. This U-shaped curve captures the fundamental trade-off: early improvements yield substantial benefits, but beyond a certain point, each additional gain comes at greater cost.</p>
<p>The dynamics mirror ML optimization challenges. Compressing a deep learning model to reduce size and energy consumption follows a similar trajectory. Initial optimizations like pruning redundant parameters or reducing precision often lead to significant savings with minimal accuracy impact. However, as compression progresses, performance losses become harder to recover. Techniques like quantization or hardware-specific tuning can restore some performance, but these add complexity and cost.</p>
<p>Similarly, in data efficiency, reducing training dataset size often improves computational efficiency initially. Yet as datasets shrink further, they may lose diversity, compromising generalization. Addressing this often involves synthetic data or sophisticated augmentation, demanding additional engineering effort.</p>
<p>The Moore’s Law plot serves as a visual reminder that optimization is not infinite. The cost-benefit balance is always context-dependent, and the point of diminishing returns varies based on system goals and constraints. ML practitioners, like semiconductor engineers, must identify when further optimization ceases to provide meaningful benefits. Over-optimization can lead to wasted resources, reduced adaptability, and systems overly specialized to initial conditions.</p>
<div id="quiz-question-sec-efficient-ai-societal-ethical-implications-d0e5" class="callout callout-quiz-question">
<details class="callout-quiz-question fbx-default closebutton"><summary><strong>Self-Check: Question 1.9</strong></summary><div>
<ol type="1">
<li><p>Which of the following best describes a potential ethical challenge in achieving efficiency in AI systems?</p>
<ol type="a">
<li>Concentration of resources in well-funded organizations</li>
<li>Increased computational power</li>
<li>Improved model accuracy</li>
<li>Faster training times</li>
</ol></li>
<li><p>Explain how algorithmic efficiency can contribute to democratizing AI access in resource-constrained environments.</p></li>
<li><p>The No Free Lunch (NFL) theorems suggest that no single optimization algorithm can outperform all others across every possible problem, implying optimization technique effectiveness is highly ____.</p></li>
<li><p>Order the following steps in addressing equity and access in AI systems: (1) Implementing energy-efficient compute technologies, (2) Sharing pre-trained models and datasets, (3) Building open-source datasets for low-resource languages.</p></li>
<li><p>In a production system where resource constraints are significant, which strategy might be prioritized to balance efficiency and innovation?</p>
<ol type="a">
<li>Investing in large-scale exploratory research</li>
<li>Focusing on incremental improvements</li>
<li>Developing entirely new architectures</li>
<li>Prioritizing high-cost infrastructure</li>
</ol></li>
</ol>
<p><a href="#quiz-answer-sec-efficient-ai-societal-ethical-implications-d0e5" class="question-label">See Answers →</a></p>
</div></details>
</div>
</section>
</section>
</section>
<section id="sec-efficient-ai-fallacies-pitfalls-f804" class="level2">
<h2 class="anchored" data-anchor-id="sec-efficient-ai-fallacies-pitfalls-f804">Fallacies and Pitfalls</h2>
<p>Efficiency in AI systems involves complex trade-offs between multiple competing objectives that often pull in different directions. The mathematical elegance of scaling laws can create false confidence about predictable optimization paths, while diverse deployment context requirements create misconceptions about universal efficiency strategies.</p>
<p><strong>Fallacy:</strong> <em>Efficiency optimizations always improve system performance across all metrics.</em></p>
<p>This misconception leads teams to apply efficiency techniques without understanding trade-offs and side effects. Optimizing for computational efficiency might degrade accuracy, improving memory efficiency could increase latency, and reducing model size often requires more complex training procedures. Efficiency gains in one dimension frequently create costs in others that may be unacceptable for specific scenarios. Effective efficiency optimization requires careful analysis of which metrics matter most and acceptance that some performance aspects will necessarily be sacrificed.</p>
<p><strong>Pitfall:</strong> <em>Assuming scaling laws predict efficiency requirements linearly across all model sizes.</em></p>
<p>Teams often extrapolate efficiency requirements based on scaling law relationships without considering breakdown points where these laws no longer apply. Scaling laws provide useful guidance for moderate increases, but fail to account for emergent behaviors, architectural constraints, and infrastructure limitations appearing at extreme scales. Applying scaling law predictions beyond validated ranges can lead to wildly inaccurate resource estimates and deployment failures. Successful efficiency planning requires understanding both utility and limits of scaling law frameworks.</p>
<p><strong>Fallacy:</strong> <em>Edge deployment efficiency requirements are simply scaled-down versions of cloud requirements.</em></p>
<p>This belief assumes edge deployment is merely cloud deployment with smaller models and less computation. Edge environments introduce qualitatively different constraints including real-time processing requirements, power consumption limits, thermal management needs, and connectivity variability. Optimization strategies working in cloud environments often fail catastrophically in edge contexts. Edge efficiency requires different approaches prioritizing predictable performance, energy efficiency, and robust operation under varying conditions.</p>
<p><strong>Pitfall:</strong> <em>Focusing on algorithmic efficiency while ignoring system-level efficiency factors.</em></p>
<p>Many practitioners optimize algorithmic complexity metrics like FLOPs or parameter counts without considering how improvements translate to actual system performance. Real system efficiency depends on memory access patterns, data movement costs, hardware utilization characteristics, and software stack overhead that may not correlate with theoretical complexity metrics. A model with fewer parameters might still perform worse due to irregular memory access patterns or poor hardware mapping. Comprehensive efficiency optimization requires measuring and optimizing actual system performance rather than relying solely on algorithmic complexity indicators.</p>
<div id="quiz-question-sec-efficient-ai-fallacies-pitfalls-f804" class="callout callout-quiz-question">
<details class="callout-quiz-question fbx-default closebutton"><summary><strong>Self-Check: Question 1.10</strong></summary><div>
<ol type="1">
<li><p>Which of the following statements is a common fallacy regarding efficiency optimizations in AI systems?</p>
<ol type="a">
<li>System-level efficiency requires consideration of hardware and software interactions.</li>
<li>Optimizing for one efficiency metric can impact other performance aspects.</li>
<li>Efficiency optimizations always improve system performance across all metrics.</li>
<li>Scaling laws are useful for predicting efficiency requirements within validated ranges.</li>
</ol></li>
<li><p>Explain why assuming scaling laws predict efficiency requirements linearly across all model sizes is a pitfall.</p></li>
<li><p>In a production system where edge deployment is required, which efficiency consideration is most critical?</p>
<ol type="a">
<li>Maximizing computational power regardless of energy consumption.</li>
<li>Prioritizing predictable performance and energy efficiency.</li>
<li>Applying cloud-based optimization strategies directly to edge environments.</li>
<li>Assuming edge deployment is a scaled-down version of cloud deployment.</li>
</ol></li>
<li><p>How might focusing solely on algorithmic efficiency metrics, like FLOPs, lead to suboptimal system performance?</p></li>
</ol>
<p><a href="#quiz-answer-sec-efficient-ai-fallacies-pitfalls-f804" class="question-label">See Answers →</a></p>
</div></details>
</div>
</section>
<section id="sec-efficient-ai-summary-66bb" class="level2">
<h2 class="anchored" data-anchor-id="sec-efficient-ai-summary-66bb">Summary</h2>
<p>Efficiency has emerged as a design principle that transforms how we approach machine learning systems, moving beyond simple performance optimization toward comprehensive resource stewardship. This chapter revealed how scaling laws provide empirical insights into relationships between model performance and computational resources, establishing efficiency as a strategic advantage enabling broader accessibility, sustainability, and innovation. The interdependencies between algorithmic, compute, and data efficiency create a complex landscape where decisions in one dimension cascade throughout the entire system, requiring a holistic perspective balancing trade-offs across the complete ML pipeline.</p>
<p>The practical challenges of designing efficient systems highlight the importance of context-aware decision making, where deployment environments shape efficiency priorities. Cloud systems leverage abundant resources for scalability and throughput, while edge deployments optimize for real-time performance within strict power constraints, and TinyML applications push the boundaries of what’s achievable with minimal resources. These diverse requirements demand sophisticated strategies including end-to-end co-design, automated optimization tools, and careful prioritization based on operational constraints. The emergence of scaling law breakdowns and tension between innovation and efficiency underscore that optimal system design requires addressing not just technical trade-offs but broader considerations of equity, sustainability, and long-term impact.</p>
<div class="callout callout-style-default callout-important callout-titled" title="Key Takeaways">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Key Takeaways
</div>
</div>
<div class="callout-body-container callout-body">
<ul>
<li>Efficiency is a strategic enabler that democratizes access to AI capabilities across diverse deployment contexts</li>
<li>Scaling laws provide predictive frameworks for resource allocation, but their limits reveal opportunities for architectural innovation</li>
<li>Trade-offs between algorithmic, compute, and data efficiency are interconnected and context-dependent, requiring holistic optimization strategies</li>
<li>Automation tools and end-to-end co-design approaches can transform efficiency constraints into opportunities for system synergy</li>
</ul>
</div>
</div>
<p>Having established the three-pillar efficiency framework and explored scaling laws as the quantitative foundation for resource allocation, the following chapters provide the specific engineering techniques to achieve efficiency in each dimension. <strong><a href="../optimizations/optimizations.html#sec-model-optimizations">Chapter 10: Model Optimizations</a></strong> focuses on algorithmic efficiency through systematic approaches to reducing model complexity while preserving performance. The chapter covers quantization techniques that reduce numerical precision, pruning methods that eliminate redundant parameters, and knowledge distillation approaches that transfer capabilities from large models to smaller ones.</p>
<p><strong><a href="../hw_acceleration/hw_acceleration.html#sec-ai-acceleration">Chapter 11: AI Acceleration</a></strong> addresses compute efficiency by exploring how specialized hardware and optimized software implementations maximize performance per unit of computational resource. Topics include GPU optimization, AI accelerator architectures, and system-level optimizations that improve throughput and reduce latency. <strong><a href="../benchmarking/benchmarking.html#sec-benchmarking-ai">Chapter 12: Benchmarking AI</a></strong> provides the measurement methodologies essential for quantifying efficiency gains across all three dimensions, covering performance evaluation frameworks, energy measurement techniques, and comparative analysis methods.</p>
<p>This progression from principles to specific techniques to measurement methodologies reflects the systematic engineering approach necessary for achieving real-world efficiency in machine learning systems. Each subsequent chapter builds upon the foundational understanding established here, creating a comprehensive toolkit for performance engineering that addresses the complex, interconnected trade-offs that define efficient AI system design.</p>
<p>These efficiency principles establish the foundation for the specific optimization techniques explored in <strong><a href="../optimizations/optimizations.html#sec-model-optimizations">Chapter 10: Model Optimizations</a></strong>, where detailed algorithms for quantization, pruning, and knowledge distillation provide concrete tools for achieving the efficiency goals outlined here. As machine learning systems continue scaling in complexity and reach, the principles of efficient design will remain essential for creating systems that are not only performant but also sustainable, accessible, and aligned with broader societal goals of responsible AI development.</p>


<div id="quiz-question-sec-efficient-ai-summary-66bb" class="callout callout-quiz-question">
<details class="callout-quiz-question fbx-default closebutton"><summary><strong>Self-Check: Question 1.11</strong></summary><div>
<ol type="1">
<li><p>Which of the following best describes the role of scaling laws in machine learning system efficiency?</p>
<ol type="a">
<li>They provide a theoretical framework for resource allocation.</li>
<li>They offer empirical insights into the relationship between performance and resources.</li>
<li>They establish a fixed set of rules for designing ML systems.</li>
<li>They ensure that all models perform optimally regardless of resources.</li>
</ol></li>
<li><p>Explain how deployment environments influence the efficiency priorities of machine learning systems.</p></li>
<li><p>In the context of ML system design, what is a primary challenge when balancing algorithmic, compute, and data efficiency?</p>
<ol type="a">
<li>Managing trade-offs where improvements in one area may reduce efficiency in another.</li>
<li>Ensuring all three efficiencies increase simultaneously.</li>
<li>Focusing solely on algorithmic efficiency to solve all system issues.</li>
<li>Ignoring data efficiency as it is less important than compute efficiency.</li>
</ol></li>
<li><p>How might you apply the principles of efficiency discussed in this section to design a sustainable ML system for edge deployment?</p></li>
</ol>
<p><a href="#quiz-answer-sec-efficient-ai-summary-66bb" class="question-label">See Answers →</a></p>
</div></details>
</div>
</section>
<section id="self-check-answers" class="level2">
<h2 class="anchored" data-anchor-id="self-check-answers">Self-Check Answers</h2>
<div id="quiz-answer-sec-efficient-ai-efficiency-imperative-d65c" class="callout callout-quiz-answer">
<details class="callout-quiz-answer fbx-answer closebutton"><summary><strong>Self-Check: Answer 1.1</strong></summary><div>
<ol type="1">
<li><p><strong>What is a major challenge in deploying large-scale language models like GPT-3?</strong></p>
<ol type="a">
<li>Lack of data availability</li>
<li>High training costs and energy consumption</li>
<li>Limited algorithmic complexity</li>
<li>Insufficient model expressiveness</li>
</ol>
<p><em>Answer</em>: The correct answer is B. High training costs and energy consumption. This is correct because large-scale models like GPT-3 require significant resources for training and inference, making deployment challenging in resource-constrained environments. Options B, C, and D do not directly address the deployment challenges discussed.</p>
<p><em>Learning Objective</em>: Understand the resource constraints associated with deploying large-scale language models.</p></li>
<li><p><strong>Explain the tension between model expressiveness and system practicality in machine learning systems.</strong></p>
<p><em>Answer</em>: The tension arises because highly expressive models often require substantial computational and memory resources, which can limit their practicality in real-world deployments, especially in resource-constrained environments. For example, while a model like GPT-3 is expressive, its memory and energy demands pose significant deployment challenges. This is important because it necessitates optimization strategies to balance expressiveness with practical constraints.</p>
<p><em>Learning Objective</em>: Analyze the trade-offs between model expressiveness and system practicality.</p></li>
<li><p><strong>Which of the following is NOT a focus of efficiency research in machine learning systems?</strong></p>
<ol type="a">
<li>Resource optimization</li>
<li>Algorithmic complexity</li>
<li>Data utilization strategies</li>
<li>Increasing model size indefinitely</li>
</ol>
<p><em>Answer</em>: The correct answer is D. Increasing model size indefinitely. This is correct because efficiency research aims to optimize resources and system design, not to increase model size without considering practical constraints. Options A, B, and C are legitimate focuses of efficiency research.</p>
<p><em>Learning Objective</em>: Identify key areas of focus in efficiency research for ML systems.</p></li>
</ol>
<p><a href="#quiz-question-sec-efficient-ai-efficiency-imperative-d65c" class="answer-label">← Back to Questions</a></p>
</div></details>
</div>
<div id="quiz-answer-sec-efficient-ai-defining-system-efficiency-a4b7" class="callout callout-quiz-answer">
<details class="callout-quiz-answer fbx-answer closebutton"><summary><strong>Self-Check: Answer 1.2</strong></summary><div>
<ol type="1">
<li><p><strong>Which of the following best describes the goal of machine learning system efficiency?</strong></p>
<ol type="a">
<li>Maximizing model accuracy regardless of resource constraints.</li>
<li>Optimizing hardware utilization without considering algorithmic complexity.</li>
<li>Focusing solely on reducing data requirements for training.</li>
<li>Minimizing computational, memory, and energy demands while maintaining or improving system performance.</li>
</ol>
<p><em>Answer</em>: The correct answer is D. Minimizing computational, memory, and energy demands while maintaining or improving system performance. This is correct because system efficiency aims to balance resource usage with performance, ensuring scalability and sustainability.</p>
<p><em>Learning Objective</em>: Understand the overarching goal of machine learning system efficiency.</p></li>
<li><p><strong>How do the three dimensions of efficiency (algorithmic, compute, data) interact in the design of a smartphone photo search application?</strong></p>
<p><em>Answer</em>: The three dimensions interact by requiring trade-offs: algorithmic efficiency reduces model size but may decrease accuracy; compute efficiency optimizes hardware usage but might limit model expressiveness; data efficiency reduces training data needs but requires sophisticated algorithms. These interactions ensure the application is viable on constrained devices. For example, a smaller model allows on-device processing, enhancing privacy and reducing data transmission needs. This is important because balancing these efficiencies enables practical and sustainable ML applications.</p>
<p><em>Learning Objective</em>: Analyze the interaction of efficiency dimensions in a practical ML system scenario.</p></li>
<li><p><strong>True or False: Improving compute efficiency always leads to better algorithmic efficiency.</strong></p>
<p><em>Answer</em>: False. Improving compute efficiency focuses on hardware utilization and may require algorithmic modifications, but it does not inherently improve algorithmic efficiency, which is concerned with model architecture and complexity.</p>
<p><em>Learning Objective</em>: Challenge misconceptions about the relationship between compute and algorithmic efficiency.</p></li>
<li><p><strong>In the context of data efficiency, which strategy is used to reduce the need for large training datasets?</strong></p>
<ol type="a">
<li>Increasing model parameters to improve learning capacity.</li>
<li>Relying solely on explicit labeling of large datasets.</li>
<li>Using pre-trained models and adapting them with fewer examples.</li>
<li>Focusing on hardware acceleration techniques.</li>
</ol>
<p><em>Answer</em>: The correct answer is C. Using pre-trained models and adapting them with fewer examples. This is correct because pre-trained models leverage existing knowledge, reducing the need for extensive new data.</p>
<p><em>Learning Objective</em>: Understand strategies for achieving data efficiency in ML systems.</p></li>
</ol>
<p><a href="#quiz-question-sec-efficient-ai-defining-system-efficiency-a4b7" class="answer-label">← Back to Questions</a></p>
</div></details>
</div>
<div id="quiz-answer-sec-efficient-ai-ai-scaling-laws-a043" class="callout callout-quiz-answer">
<details class="callout-quiz-answer fbx-answer closebutton"><summary><strong>Self-Check: Answer 1.3</strong></summary><div>
<ol type="1">
<li><p><strong>What is a key insight from scaling laws in machine learning?</strong></p>
<ol type="a">
<li>Model performance improves linearly with increased computational resources.</li>
<li>Larger models always require less training data to achieve state-of-the-art performance.</li>
<li>Performance improvements follow predictable power-law relationships with model size, dataset size, and compute budget.</li>
<li>Scaling laws suggest that model architecture is the primary driver of performance improvements.</li>
</ol>
<p><em>Answer</em>: The correct answer is C. Performance improvements follow predictable power-law relationships with model size, dataset size, and compute budget. This is correct because scaling laws quantify how these factors affect model performance, showing consistent patterns. Options A, B, and D are incorrect as they misrepresent the nature of scaling laws.</p>
<p><em>Learning Objective</em>: Understand the fundamental insights provided by scaling laws in ML systems.</p></li>
<li><p><strong>Explain the trade-offs involved in scaling machine learning models in terms of computational resources and performance.</strong></p>
<p><em>Answer</em>: Scaling machine learning models involves trade-offs between computational resources and performance. While larger models can capture more complex patterns and improve accuracy, they require exponentially more computational power and data, leading to increased costs and environmental impacts. For example, training GPT-3 required significant computational resources, raising questions about sustainability. This is important because it highlights the need for efficient resource allocation to balance performance gains with practical constraints.</p>
<p><em>Learning Objective</em>: Analyze the trade-offs between computational resources and performance when scaling ML models.</p></li>
<li><p><strong>Order the following models by their parameter size: (1) GPT-1, (2) GPT-2, (3) GPT-3.</strong></p>
<p><em>Answer</em>: The correct order is: (1) GPT-1, (2) GPT-2, (3) GPT-3. GPT-1 had 117 million parameters, GPT-2 scaled to 1.5 billion parameters, and GPT-3 expanded to 175 billion parameters. This sequence illustrates the scaling trajectory in language models, showing how each successive model increased in size and capability.</p>
<p><em>Learning Objective</em>: Understand the progression of model scaling in terms of parameter size in language models.</p></li>
<li><p><strong>True or False: According to scaling laws, increasing model size without increasing dataset size can lead to overfitting.</strong></p>
<p><em>Answer</em>: True. This is true because scaling laws indicate that model performance depends on coordinated increases in model size, dataset size, and compute budget. Increasing model size alone can lead to overfitting if not matched with sufficient data to train effectively.</p>
<p><em>Learning Objective</em>: Recognize the implications of unbalanced scaling in ML systems.</p></li>
</ol>
<p><a href="#quiz-question-sec-efficient-ai-ai-scaling-laws-a043" class="answer-label">← Back to Questions</a></p>
</div></details>
</div>
<div id="quiz-answer-sec-efficient-ai-efficiency-framework-c0de" class="callout callout-quiz-answer">
<details class="callout-quiz-answer fbx-answer closebutton"><summary><strong>Self-Check: Answer 1.4</strong></summary><div>
<ol type="1">
<li><p><strong>Which of the following best describes the role of algorithmic efficiency in the efficiency framework?</strong></p>
<ol type="a">
<li>Reducing the amount of data needed for training</li>
<li>Improving the utilization of hardware resources</li>
<li>Maximizing performance per unit of computation</li>
<li>Enhancing the scalability of cloud systems</li>
</ol>
<p><em>Answer</em>: The correct answer is C. Maximizing performance per unit of computation. Algorithmic efficiency focuses on optimizing model architectures and training procedures to achieve maximum performance with minimal computational resources.</p>
<p><em>Learning Objective</em>: Understand the role of algorithmic efficiency in the efficiency framework.</p></li>
<li><p><strong>Explain how coordinated optimization across algorithmic, compute, and data efficiency can lead to sustainable AI systems.</strong></p>
<p><em>Answer</em>: Coordinated optimization leverages synergies between efficiency dimensions to achieve sustainable AI systems. Algorithmic innovations can enhance hardware utilization, while compute-efficient methods enable training on larger datasets. Data-efficient techniques reduce computational needs. Together, these optimizations overcome limitations of brute-force scaling, leading to high-performance, sustainable AI systems.</p>
<p><em>Learning Objective</em>: Understand the importance of coordinated optimization in achieving sustainable AI systems.</p></li>
<li><p><strong>True or False: In mobile applications, data efficiency is prioritized over compute efficiency due to battery life constraints.</strong></p>
<p><em>Answer</em>: False. In mobile applications, compute efficiency is prioritized due to battery life constraints, as it directly impacts energy consumption and device performance.</p>
<p><em>Learning Objective</em>: Understand the trade-offs and priorities in different deployment environments.</p></li>
<li><p><strong>What is a common trade-off when optimizing for algorithmic efficiency in edge devices?</strong></p>
<ol type="a">
<li>Increased data requirements</li>
<li>Reduced model accuracy</li>
<li>Higher computational intensity</li>
<li>Increased hardware utilization</li>
</ol>
<p><em>Answer</em>: The correct answer is B. Reduced model accuracy. Optimizing for algorithmic efficiency often involves model compression and pruning, which can lead to a slight reduction in accuracy.</p>
<p><em>Learning Objective</em>: Identify trade-offs involved in optimizing for algorithmic efficiency in different deployment contexts.</p></li>
<li><p><strong>How might you apply the efficiency framework in designing an ML system for autonomous vehicles?</strong></p>
<p><em>Answer</em>: In designing an ML system for autonomous vehicles, apply the efficiency framework by optimizing algorithmic efficiency through compact model architectures for real-time processing. Enhance compute efficiency using hardware-aware designs to meet latency and power constraints. Improve data efficiency by using high-quality, curated datasets to reduce training time and ensure robust performance.</p>
<p><em>Learning Objective</em>: Apply the efficiency framework to a real-world ML system scenario.</p></li>
</ol>
<p><a href="#quiz-question-sec-efficient-ai-efficiency-framework-c0de" class="answer-label">← Back to Questions</a></p>
</div></details>
</div>
<div id="quiz-answer-sec-efficient-ai-realworld-efficiency-strategies-8387" class="callout callout-quiz-answer">
<details class="callout-quiz-answer fbx-answer closebutton"><summary><strong>Self-Check: Answer 1.5</strong></summary><div>
<ol type="1">
<li><p><strong>Which deployment context prioritizes real-time performance and power efficiency due to local compute capacity and connectivity constraints?</strong></p>
<ol type="a">
<li>Edge</li>
<li>Cloud</li>
<li>Mobile</li>
<li>TinyML</li>
</ol>
<p><em>Answer</em>: The correct answer is A. Edge. This is correct because edge deployments focus on real-time performance and power efficiency due to constraints like local compute capacity and connectivity. Cloud systems, on the other hand, prioritize throughput and scalability.</p>
<p><em>Learning Objective</em>: Understand the efficiency priorities specific to edge deployment contexts.</p></li>
<li><p><strong>Explain how system efficiency contributes to scalability and sustainability in machine learning deployments.</strong></p>
<p><em>Answer</em>: System efficiency contributes to scalability by reducing resource demands, allowing for broader deployment. Efficient systems minimize energy consumption and computational waste, enhancing sustainability. For example, optimized models require less power, supporting large-scale deployment while reducing environmental impact. This is important because it creates a reinforcing feedback loop that promotes sustainable design practices.</p>
<p><em>Learning Objective</em>: Analyze the relationship between system efficiency, scalability, and sustainability.</p></li>
<li><p><strong>Order the following deployment contexts by their primary efficiency priority from highest to lowest: (1) Cloud, (2) Edge, (3) Mobile, (4) TinyML.</strong></p>
<p><em>Answer</em>: The correct order is: (1) Cloud, (3) Mobile, (2) Edge, (4) TinyML. Cloud prioritizes throughput and scalability, Mobile focuses on energy efficiency and responsiveness, Edge emphasizes real-time performance, and TinyML requires ultra-low power and minimal model size due to extreme constraints.</p>
<p><em>Learning Objective</em>: Classify deployment contexts based on their primary efficiency priorities.</p></li>
<li><p><strong>True or False: In TinyML deployments, model size is prioritized over power efficiency.</strong></p>
<p><em>Answer</em>: False. This is false because in TinyML deployments, both ultra-low power and minimal model size are critical, but power efficiency is often prioritized due to severe power constraints.</p>
<p><em>Learning Objective</em>: Challenge misconceptions about efficiency priorities in TinyML deployments.</p></li>
</ol>
<p><a href="#quiz-question-sec-efficient-ai-realworld-efficiency-strategies-8387" class="answer-label">← Back to Questions</a></p>
</div></details>
</div>
<div id="quiz-answer-sec-efficient-ai-efficiency-tradeoffs-challenges-946d" class="callout callout-quiz-answer">
<details class="callout-quiz-answer fbx-answer closebutton"><summary><strong>Self-Check: Answer 1.6</strong></summary><div>
<ol type="1">
<li><p><strong>Which of the following best describes the trade-off between algorithmic efficiency and compute requirements?</strong></p>
<ol type="a">
<li>Reducing model size always improves accuracy.</li>
<li>Simplifying models can reduce computational demands but may decrease accuracy.</li>
<li>Increasing model complexity always reduces energy consumption.</li>
<li>Deploying models on resource-limited devices requires no trade-offs.</li>
</ol>
<p><em>Answer</em>: The correct answer is B. Simplifying models can reduce computational demands but may decrease accuracy. This is correct because reducing model size or complexity can make deployment feasible on resource-limited devices, but often at the cost of accuracy. Options A, C, and D are incorrect as they do not accurately reflect the trade-offs involved.</p>
<p><em>Learning Objective</em>: Understand the trade-offs between algorithmic efficiency and compute requirements.</p></li>
<li><p><strong>Explain how real-time performance requirements can conflict with compute efficiency in ML systems.</strong></p>
<p><em>Answer</em>: Real-time performance requires high-speed data processing, often necessitating high-performance hardware, which increases energy consumption and system costs. For example, autonomous vehicles need to process sensor data instantly, demanding powerful processors that may not align with energy efficiency goals. This is important because balancing these requirements is critical for designing effective real-time systems.</p>
<p><em>Learning Objective</em>: Analyze the conflict between real-time performance and compute efficiency.</p></li>
<li><p><strong>In a production system where energy efficiency is critical, which strategy might be prioritized?</strong></p>
<ol type="a">
<li>Using high-performance GPUs for all tasks.</li>
<li>Deploying complex models without considering energy consumption.</li>
<li>Ignoring latency requirements to save energy.</li>
<li>Optimizing models to run on low-power hardware.</li>
</ol>
<p><em>Answer</em>: The correct answer is D. Optimizing models to run on low-power hardware. This is correct because in energy-constrained environments, such as edge deployments, it is crucial to design models that can operate efficiently on low-power devices. Options A, B, and D do not appropriately address the need for energy efficiency.</p>
<p><em>Learning Objective</em>: Apply energy efficiency strategies in system design.</p></li>
<li><p><strong>In scenarios requiring real-time responsiveness, such as autonomous vehicles, the trade-off between computational efficiency and low latency often requires balancing ________ and energy consumption.</strong></p>
<p><em>Answer</em>: processing power. This balance is necessary because increasing processing power to achieve low latency can lead to higher energy consumption, impacting the overall system efficiency.</p>
<p><em>Learning Objective</em>: Identify key factors in balancing computational efficiency and latency.</p></li>
<li><p><strong>In your experience with ML systems, how might you address the trade-off between data efficiency and model generalization?</strong></p>
<p><em>Answer</em>: To address this trade-off, one could use techniques like data augmentation or transfer learning to enhance model generalization without needing large datasets. For example, augmenting training data with synthetic examples can improve diversity and generalization. This is important because it allows models to perform well in real-world scenarios with limited data.</p>
<p><em>Learning Objective</em>: Explore strategies to balance data efficiency and model generalization.</p></li>
</ol>
<p><a href="#quiz-question-sec-efficient-ai-efficiency-tradeoffs-challenges-946d" class="answer-label">← Back to Questions</a></p>
</div></details>
</div>
<div id="quiz-answer-sec-efficient-ai-strategic-tradeoff-management-0ac8" class="callout callout-quiz-answer">
<details class="callout-quiz-answer fbx-answer closebutton"><summary><strong>Self-Check: Answer 1.7</strong></summary><div>
<ol type="1">
<li><p><strong>Which of the following is a primary concern in mobile ML deployments?</strong></p>
<ol type="a">
<li>Algorithmic accuracy</li>
<li>Scalability</li>
<li>Data efficiency</li>
<li>Compute efficiency</li>
</ol>
<p><em>Answer</em>: The correct answer is D. Compute efficiency. In mobile ML deployments, battery life is a primary constraint, making compute efficiency crucial to minimize energy consumption.</p>
<p><em>Learning Objective</em>: Understand the primary trade-offs in mobile ML deployments.</p></li>
<li><p><strong>Explain how test-time compute can enhance system adaptability in cloud ML systems.</strong></p>
<p><em>Answer</em>: Test-time compute enhances adaptability by dynamically allocating resources based on immediate demands. For example, a cloud-based video analysis system might use a streamlined model for normal operations but allocate more resources to a complex model during critical events. This allows the system to balance throughput and precision effectively.</p>
<p><em>Learning Objective</em>: Analyze the role of test-time compute in adapting system performance to varying demands.</p></li>
<li><p><strong>Order the following deployment contexts by their primary efficiency priority from highest to lowest: (1) Mobile ML, (2) Cloud ML, (3) Edge ML, (4) TinyML.</strong></p>
<p><em>Answer</em>: The correct order is: (4) TinyML, (1) Mobile ML, (3) Edge ML, (2) Cloud ML. TinyML prioritizes extreme efficiency due to hardware constraints, Mobile ML focuses on compute efficiency to conserve battery, Edge ML emphasizes low-latency processing, and Cloud ML prioritizes scalability and throughput.</p>
<p><em>Learning Objective</em>: Classify deployment contexts based on their primary efficiency priorities.</p></li>
<li><p><strong>In TinyML deployments, the primary focus is on ____ efficiency due to severe hardware and energy limitations.</strong></p>
<p><em>Answer</em>: algorithmic and data. TinyML requires highly compact models and efficient data usage because of limited memory and compute power.</p>
<p><em>Learning Objective</em>: Recall the primary efficiency focus in TinyML deployments.</p></li>
<li><p><strong>How does co-design contribute to managing trade-offs in resource-constrained ML environments?</strong></p>
<p><em>Answer</em>: Co-design aligns model architectures, hardware platforms, and data pipelines, ensuring each component is optimized for the others. In resource-constrained environments, this means designing models that match hardware capabilities, such as using 8-bit models with hardware support for efficient operations, thus optimizing overall system efficiency.</p>
<p><em>Learning Objective</em>: Explain the role of co-design in optimizing ML systems for efficiency.</p></li>
</ol>
<p><a href="#quiz-question-sec-efficient-ai-strategic-tradeoff-management-0ac8" class="answer-label">← Back to Questions</a></p>
</div></details>
</div>
<div id="quiz-answer-sec-efficient-ai-engineering-principles-efficient-ai-1206" class="callout callout-quiz-answer">
<details class="callout-quiz-answer fbx-answer closebutton"><summary><strong>Self-Check: Answer 1.8</strong></summary><div>
<ol type="1">
<li><p><strong>Which of the following best describes the importance of system-level thinking in designing efficient ML systems?</strong></p>
<ol type="a">
<li>Focusing on optimizing individual components separately.</li>
<li>Maximizing the performance of the model at any cost.</li>
<li>Prioritizing hardware-specific optimizations.</li>
<li>Considering the entire ML pipeline as a unified whole.</li>
</ol>
<p><em>Answer</em>: The correct answer is D. Considering the entire ML pipeline as a unified whole. This is correct because system-level thinking ensures that trade-offs are balanced across all stages, leading to overall efficiency. Options A, C, and D focus on isolated or misaligned optimizations.</p>
<p><em>Learning Objective</em>: Understand the significance of system-level thinking in ML system design for efficiency.</p></li>
<li><p><strong>Explain how decisions made during data collection can impact other stages of the ML pipeline.</strong></p>
<p><em>Answer</em>: Decisions during data collection, such as dataset size and quality, affect computational costs and model design complexity. Smaller, high-quality datasets can reduce training costs and simplify models, but may require compensatory measures if diversity is insufficient. This impacts model training and deployment efficiency.</p>
<p><em>Learning Objective</em>: Analyze the impact of data collection decisions on the entire ML pipeline.</p></li>
<li><p><strong>In a production ML system for edge devices, which trade-off is most critical?</strong></p>
<ol type="a">
<li>Balancing model accuracy with size and energy efficiency.</li>
<li>Maximizing model accuracy at the expense of size.</li>
<li>Focusing solely on reducing computational costs.</li>
<li>Prioritizing extensive hyperparameter tuning.</li>
</ol>
<p><em>Answer</em>: The correct answer is A. Balancing model accuracy with size and energy efficiency. This is critical because edge devices have limited resources, requiring models to be both accurate and efficient in terms of size and power consumption. Options A, C, and D do not address the constraints of edge devices.</p>
<p><em>Learning Objective</em>: Understand trade-offs in designing ML systems for resource-constrained environments.</p></li>
<li><p><strong>Order the following ML pipeline stages by their typical sequence in achieving system-level efficiency: (1) Model Training, (2) Data Collection, (3) Deployment and Inference.</strong></p>
<p><em>Answer</em>: The correct order is: (2) Data Collection, (1) Model Training, (3) Deployment and Inference. This sequence reflects the typical progression from gathering and preparing data, to training models, and finally deploying them for inference, each stage impacting the next.</p>
<p><em>Learning Objective</em>: Reinforce understanding of the ML pipeline stages and their sequence.</p></li>
</ol>
<p><a href="#quiz-question-sec-efficient-ai-engineering-principles-efficient-ai-1206" class="answer-label">← Back to Questions</a></p>
</div></details>
</div>
<div id="quiz-answer-sec-efficient-ai-societal-ethical-implications-d0e5" class="callout callout-quiz-answer">
<details class="callout-quiz-answer fbx-answer closebutton"><summary><strong>Self-Check: Answer 1.9</strong></summary><div>
<ol type="1">
<li><p><strong>Which of the following best describes a potential ethical challenge in achieving efficiency in AI systems?</strong></p>
<ol type="a">
<li>Concentration of resources in well-funded organizations</li>
<li>Increased computational power</li>
<li>Improved model accuracy</li>
<li>Faster training times</li>
</ol>
<p><em>Answer</em>: The correct answer is A. Concentration of resources in well-funded organizations. This is correct because achieving efficiency often requires significant resources, which are typically concentrated in a few organizations, leading to inequities in access and innovation.</p>
<p><em>Learning Objective</em>: Understand the ethical challenges associated with resource allocation in AI efficiency.</p></li>
<li><p><strong>Explain how algorithmic efficiency can contribute to democratizing AI access in resource-constrained environments.</strong></p>
<p><em>Answer</em>: Algorithmic efficiency allows advanced AI capabilities to be deployed on low-cost, resource-constrained devices, such as smartphones or edge devices. For example, AI-powered diagnostic tools on smartphones can provide healthcare access in remote areas. This is important because it enables organizations with limited resources to implement impactful AI solutions.</p>
<p><em>Learning Objective</em>: Analyze how algorithmic efficiency can enhance accessibility in under-resourced regions.</p></li>
<li><p><strong>The No Free Lunch (NFL) theorems suggest that no single optimization algorithm can outperform all others across every possible problem, implying optimization technique effectiveness is highly ____.</strong></p>
<p><em>Answer</em>: problem-specific. The NFL theorems indicate that optimization methods must be tailored to specific problem domains.</p>
<p><em>Learning Objective</em>: Recall the implications of the No Free Lunch theorems in optimization.</p></li>
<li><p><strong>Order the following steps in addressing equity and access in AI systems: (1) Implementing energy-efficient compute technologies, (2) Sharing pre-trained models and datasets, (3) Building open-source datasets for low-resource languages.</strong></p>
<p><em>Answer</em>: The correct order is: (3) Building open-source datasets for low-resource languages, (2) Sharing pre-trained models and datasets, (1) Implementing energy-efficient compute technologies. This sequence reflects the process of first addressing data scarcity, then facilitating access to models, and finally deploying efficient technologies.</p>
<p><em>Learning Objective</em>: Understand the sequential approach to enhancing equity and access in AI systems.</p></li>
<li><p><strong>In a production system where resource constraints are significant, which strategy might be prioritized to balance efficiency and innovation?</strong></p>
<ol type="a">
<li>Investing in large-scale exploratory research</li>
<li>Focusing on incremental improvements</li>
<li>Developing entirely new architectures</li>
<li>Prioritizing high-cost infrastructure</li>
</ol>
<p><em>Answer</em>: The correct answer is B. Focusing on incremental improvements. This is correct because resource-constrained environments often require prioritizing efficiency through incremental advancements rather than costly exploratory research.</p>
<p><em>Learning Objective</em>: Evaluate strategies for balancing efficiency and innovation in resource-constrained environments.</p></li>
</ol>
<p><a href="#quiz-question-sec-efficient-ai-societal-ethical-implications-d0e5" class="answer-label">← Back to Questions</a></p>
</div></details>
</div>
<div id="quiz-answer-sec-efficient-ai-fallacies-pitfalls-f804" class="callout callout-quiz-answer">
<details class="callout-quiz-answer fbx-answer closebutton"><summary><strong>Self-Check: Answer 1.10</strong></summary><div>
<ol type="1">
<li><p><strong>Which of the following statements is a common fallacy regarding efficiency optimizations in AI systems?</strong></p>
<ol type="a">
<li>System-level efficiency requires consideration of hardware and software interactions.</li>
<li>Optimizing for one efficiency metric can impact other performance aspects.</li>
<li>Efficiency optimizations always improve system performance across all metrics.</li>
<li>Scaling laws are useful for predicting efficiency requirements within validated ranges.</li>
</ol>
<p><em>Answer</em>: The correct answer is C. Efficiency optimizations always improve system performance across all metrics. This is a fallacy because optimizing for one metric often involves trade-offs that can negatively impact other metrics. The other options are correct statements about efficiency considerations.</p>
<p><em>Learning Objective</em>: Identify and understand common misconceptions about efficiency optimizations in AI systems.</p></li>
<li><p><strong>Explain why assuming scaling laws predict efficiency requirements linearly across all model sizes is a pitfall.</strong></p>
<p><em>Answer</em>: Assuming scaling laws predict efficiency requirements linearly is a pitfall because these laws do not account for emergent behaviors and constraints at extreme scales. For example, architectural constraints and infrastructure limitations can lead to inaccurate resource estimates. This is important because relying solely on scaling laws can result in deployment failures.</p>
<p><em>Learning Objective</em>: Understand the limitations of scaling laws in predicting efficiency requirements for AI systems.</p></li>
<li><p><strong>In a production system where edge deployment is required, which efficiency consideration is most critical?</strong></p>
<ol type="a">
<li>Maximizing computational power regardless of energy consumption.</li>
<li>Prioritizing predictable performance and energy efficiency.</li>
<li>Applying cloud-based optimization strategies directly to edge environments.</li>
<li>Assuming edge deployment is a scaled-down version of cloud deployment.</li>
</ol>
<p><em>Answer</em>: The correct answer is B. Prioritizing predictable performance and energy efficiency. This is critical because edge environments have unique constraints such as real-time processing and power limits. The other options overlook these specific requirements.</p>
<p><em>Learning Objective</em>: Recognize the unique efficiency considerations required for edge deployments in AI systems.</p></li>
<li><p><strong>How might focusing solely on algorithmic efficiency metrics, like FLOPs, lead to suboptimal system performance?</strong></p>
<p><em>Answer</em>: Focusing solely on algorithmic efficiency metrics can lead to suboptimal system performance because it ignores system-level factors like memory access patterns and hardware utilization. For example, a model with low FLOPs might perform poorly if it causes inefficient data movement. This highlights the need for comprehensive system-level optimization.</p>
<p><em>Learning Objective</em>: Understand the importance of considering both algorithmic and system-level efficiency factors in AI systems.</p></li>
</ol>
<p><a href="#quiz-question-sec-efficient-ai-fallacies-pitfalls-f804" class="answer-label">← Back to Questions</a></p>
</div></details>
</div>
<div id="quiz-answer-sec-efficient-ai-summary-66bb" class="callout callout-quiz-answer">
<details class="callout-quiz-answer fbx-answer closebutton"><summary><strong>Self-Check: Answer 1.11</strong></summary><div>
<ol type="1">
<li><p><strong>Which of the following best describes the role of scaling laws in machine learning system efficiency?</strong></p>
<ol type="a">
<li>They provide a theoretical framework for resource allocation.</li>
<li>They offer empirical insights into the relationship between performance and resources.</li>
<li>They establish a fixed set of rules for designing ML systems.</li>
<li>They ensure that all models perform optimally regardless of resources.</li>
</ol>
<p><em>Answer</em>: The correct answer is B. They offer empirical insights into the relationship between performance and resources. Scaling laws help predict how changes in computational resources affect model performance, guiding efficiency strategies.</p>
<p><em>Learning Objective</em>: Understand the role of scaling laws in informing efficiency strategies in ML systems.</p></li>
<li><p><strong>Explain how deployment environments influence the efficiency priorities of machine learning systems.</strong></p>
<p><em>Answer</em>: Deployment environments dictate efficiency priorities based on their specific constraints and requirements. For instance, cloud systems prioritize scalability, while edge deployments focus on power efficiency and real-time performance. This context-aware decision-making ensures that efficiency strategies align with operational needs.</p>
<p><em>Learning Objective</em>: Analyze how different deployment contexts affect efficiency priorities in ML systems.</p></li>
<li><p><strong>In the context of ML system design, what is a primary challenge when balancing algorithmic, compute, and data efficiency?</strong></p>
<ol type="a">
<li>Managing trade-offs where improvements in one area may reduce efficiency in another.</li>
<li>Ensuring all three efficiencies increase simultaneously.</li>
<li>Focusing solely on algorithmic efficiency to solve all system issues.</li>
<li>Ignoring data efficiency as it is less important than compute efficiency.</li>
</ol>
<p><em>Answer</em>: The correct answer is A. Managing trade-offs where improvements in one area may reduce efficiency in another. Balancing these efficiencies requires careful consideration of how changes in one dimension affect the others.</p>
<p><em>Learning Objective</em>: Understand the trade-offs involved in balancing different types of efficiency in ML systems.</p></li>
<li><p><strong>How might you apply the principles of efficiency discussed in this section to design a sustainable ML system for edge deployment?</strong></p>
<p><em>Answer</em>: To design a sustainable ML system for edge deployment, prioritize power efficiency and real-time performance. Use end-to-end co-design and automated optimization tools to balance algorithmic, compute, and data efficiency. This approach ensures the system meets operational constraints while remaining sustainable and accessible.</p>
<p><em>Learning Objective</em>: Apply efficiency principles to design sustainable ML systems for specific deployment contexts.</p></li>
</ol>
<p><a href="#quiz-question-sec-efficient-ai-summary-66bb" class="answer-label">← Back to Questions</a></p>
</div></details>
</div>

</section>
</section>


<a onclick="window.scrollTo(0, 0); return false;" role="button" id="quarto-back-to-top"><i class="bi bi-arrow-up"></i> Back to top</a></main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    // Ensure there is a toggle, if there isn't float one in the top right
    if (window.document.querySelector('.quarto-color-scheme-toggle') === null) {
      const a = window.document.createElement('a');
      a.classList.add('top-right');
      a.classList.add('quarto-color-scheme-toggle');
      a.href = "";
      a.onclick = function() { try { window.quartoToggleColorScheme(); } catch {} return false; };
      const i = window.document.createElement("i");
      i.classList.add('bi');
      a.appendChild(i);
      window.document.body.appendChild(a);
    }
    setColorSchemeToggle(hasAlternateSentinel())
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
        const codeEl = trigger.previousElementSibling.cloneNode(true);
        for (const childEl of codeEl.children) {
          if (isCodeAnnotation(childEl)) {
            childEl.remove();
          }
        }
        return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp('/' + window.location.host + '/');
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
            // target, if specified
            link.setAttribute("target", "_blank");
            if (link.getAttribute("rel") === null) {
              link.setAttribute("rel", "noopener");
            }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
  });
  </script>
<nav class="page-navigation">
  <div class="nav-page nav-page-previous">
      <a href="../../../contents/core/training/training.html" class="pagination-link" aria-label="AI Training">
        <i class="bi bi-arrow-left-short"></i> <span class="nav-page-text">AI Training</span>
      </a>          
  </div>
  <div class="nav-page nav-page-next">
      <a href="../../../contents/core/optimizations/optimizations.html" class="pagination-link" aria-label="Model Optimizations">
        <span class="nav-page-text">Model Optimizations</span> <i class="bi bi-arrow-right-short"></i>
      </a>
  </div>
</nav>
</div> <!-- /content -->
<footer class="footer">
  <div class="nav-footer">
    <div class="nav-footer-left">
<p>© 2024 Harvard University. Licensed under <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC-BY-NC-SA 4.0</a></p>
</div>   
    <div class="nav-footer-center">
<p>Written, edited and curated by Prof.&nbsp;Vijay Janapa Reddi (Harvard University)</p>
</div>
    <div class="nav-footer-right">
      <ul class="footer-items list-unstyled">
    <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/harvard-edge/cs249r_book">
      <i class="bi bi-github" role="img" aria-label="View source on GitHub">
</i> 
    </a>
  </li>  
    <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/harvard-edge/cs249r_book">
      <i class="bi bi-star" role="img" aria-label="Star this repository">
</i> 
    </a>
  </li>  
    <li class="nav-item">
    <a class="nav-link" href="https://www.netlify.com">
<p><img src="https://www.netlify.com/v3/img/components/netlify-color-accent.svg" alt="Deploys by Netlify" style="height: 15px; vertical-align: middle; margin-left: 3px;"></p>
</a>
  </li>  
</ul>
    </div>
  </div>
</footer>
<script>var lightboxQuarto = GLightbox({"closeEffect":"zoom","descPosition":"bottom","loop":false,"openEffect":"zoom","selector":".lightbox"});
(function() {
  let previousOnload = window.onload;
  window.onload = () => {
    if (previousOnload) {
      previousOnload();
    }
    lightboxQuarto.on('slide_before_load', (data) => {
      const { slideIndex, slideNode, slideConfig, player, trigger } = data;
      const href = trigger.getAttribute('href');
      if (href !== null) {
        const imgEl = window.document.querySelector(`a[href="${href}"] img`);
        if (imgEl !== null) {
          const srcAttr = imgEl.getAttribute("src");
          if (srcAttr && srcAttr.startsWith("data:")) {
            slideConfig.href = srcAttr;
          }
        }
      } 
    });
  
    lightboxQuarto.on('slide_after_load', (data) => {
      const { slideIndex, slideNode, slideConfig, player, trigger } = data;
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(slideNode);
      }
    });
  
  };
  
})();
          </script>




</body></html>