<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.7.31">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>ML Systems Textbook</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for citations */
div.csl-bib-body { }
div.csl-entry {
  clear: both;
  margin-bottom: 0em;
}
.hanging-indent div.csl-entry {
  margin-left:2em;
  text-indent:-2em;
}
div.csl-left-margin {
  min-width:2em;
  float:left;
}
div.csl-right-inline {
  margin-left:2em;
  padding-left:1em;
}
div.csl-indent {
  margin-left: 2em;
}</style>


<script src="../../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../../">
<link href="../../../contents/core/data_engineering/data_engineering.html" rel="next">
<link href="../../../contents/core/dnn_architectures/dnn_architectures.html" rel="prev">
<link href="../../../assets/images/icons/favicon.png" rel="icon" type="image/png">
<script src="../../../site_libs/quarto-html/quarto.js" type="module"></script>
<script src="../../../site_libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="../../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../../site_libs/quarto-html/quarto-syntax-highlighting-ae75ed80ef5b3e74590777de1ac3d8c3.css" rel="stylesheet" class="quarto-color-scheme" id="quarto-text-highlighting-styles">
<link href="../../../site_libs/quarto-html/quarto-syntax-highlighting-dark-ae75ed80ef5b3e74590777de1ac3d8c3.css" rel="stylesheet" class="quarto-color-scheme quarto-color-alternate" id="quarto-text-highlighting-styles">
<link href="../../../site_libs/quarto-html/quarto-syntax-highlighting-ae75ed80ef5b3e74590777de1ac3d8c3.css" rel="stylesheet" class="quarto-color-scheme-extra" id="quarto-text-highlighting-styles">
<script src="../../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../../site_libs/bootstrap/bootstrap-0769fbf68cc3e722256a1e1e51d908bf.min.css" rel="stylesheet" append-hash="true" class="quarto-color-scheme" id="quarto-bootstrap" data-mode="light">
<link href="../../../site_libs/bootstrap/bootstrap-dark-b3207de211d0ae0f80cf70030995c04d.min.css" rel="stylesheet" append-hash="true" class="quarto-color-scheme quarto-color-alternate" id="quarto-bootstrap" data-mode="light">
<link href="../../../site_libs/bootstrap/bootstrap-0769fbf68cc3e722256a1e1e51d908bf.min.css" rel="stylesheet" append-hash="true" class="quarto-color-scheme-extra" id="quarto-bootstrap" data-mode="light">
<link href="../../../site_libs/quarto-contrib/foldbox/foldbox.css" rel="stylesheet">
<script src="../../../site_libs/quarto-contrib/glightbox/glightbox.min.js"></script>
<link href="../../../site_libs/quarto-contrib/glightbox/glightbox.min.css" rel="stylesheet">
<link href="../../../site_libs/quarto-contrib/glightbox/lightbox.css" rel="stylesheet">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>
<script async="" src="https://www.googletagmanager.com/gtag/js?id=G-M21L0CBCVN"></script>

<script type="text/javascript">

window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'G-M21L0CBCVN', { 'anonymize_ip': true});
</script>
<script type="application/json" class="js-hypothesis-config">
{
  "theme": "clean",
  "openSidebar": false
}
</script>
<script async="" src="https://hypothes.is/embed.js"></script>
<script>
  window.document.addEventListener("DOMContentLoaded", function (_event) {
    document.body.classList.add('hypothesis-enabled');
  });
</script>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">

<script async="" src="https://www.googletagmanager.com/gtag/js?id=G-M21L0CBCVN"></script>
<script type="module" src="../../../tools/scripts/ai_menu/dist/bundle.js" defer=""></script>
<script type="module" src="../../../tools/scripts/ai_menu/dist/sqlite3-opfs-async-proxy-B_ImRJXp.js"></script>
<script type="module" src="../../../tools/scripts/ai_menu/dist/sqlite3-worker1-bundler-friendly-CbDNa4by.js"></script>
<script type="module" src="../../../tools/scripts/ai_menu/dist/worker-voUF5YDa.js"></script>
<script src="../../../assets/scripts/sidebar-auto-collapse.js" defer=""></script>
<style>
.callout-resource-videos {
  --color1: #E0F2F1;
  --color2: #20B2AA;
}
.callout-definition {
  --color1: #F0F4F8;
  --color2: #1B4F72;
}
.callout-chapter-connection {
  --color1: #FDF2F7;
  --color2: #A51C30;
}
.callout-resource-slides {
  --color1: #E0F2F1;
  --color2: #20B2AA;
}
.callout-quiz-answer {
  --color1: #E8F2EA;
  --color2: #4a7c59;
}
.callout-code {
  --color1: #F2F4F8;
  --color2: #D1D7E0;
}
.callout-example {
  --color1: #F0F8F6;
  --color2: #148F77;
}
.callout-resource-exercises {
  --color1: #E0F2F1;
  --color2: #20B2AA;
}
.callout-quiz-question {
  --color1: #F0F0F8;
  --color2: #5B4B8A;
}
</style>
<style>
details.callout-resource-videos > summary::before {
  background-image: url("../../../assets/images/icons/callouts/icon_callout-resource-videos.png");
}
details.callout-definition > summary::before {
  background-image: url("../../../assets/images/icons/callouts/icon_callout-definition.png");
}
details.callout-chapter-connection > summary::before {
  background-image: url("../../../assets/images/icons/callouts/icon_callout-chapter-connection.png");
}
details.callout-resource-slides > summary::before {
  background-image: url("../../../assets/images/icons/callouts/icon_callout-resource-slides.png");
}
details.callout-quiz-answer > summary::before {
  background-image: url("../../../assets/images/icons/callouts/icon_callout-quiz-answer.png");
}
details.callout-code > summary::before {
  background-image: url("../../../assets/images/icons/callouts/icon_callout-code.png");
}
details.callout-example > summary::before {
  background-image: url("../../../assets/images/icons/callouts/icon_callout-example.png");
}
details.callout-resource-exercises > summary::before {
  background-image: url("../../../assets/images/icons/callouts/icon_callout-resource-exercises.png");
}
details.callout-quiz-question > summary::before {
  background-image: url("../../../assets/images/icons/callouts/icon_callout-quiz-question.png");
}
</style>


</head>

<body class="nav-sidebar floating nav-fixed slimcontent quarto-light"><script id="quarto-html-before-body" type="application/javascript">
    const toggleBodyColorMode = (bsSheetEl) => {
      const mode = bsSheetEl.getAttribute("data-mode");
      const bodyEl = window.document.querySelector("body");
      if (mode === "dark") {
        bodyEl.classList.add("quarto-dark");
        bodyEl.classList.remove("quarto-light");
      } else {
        bodyEl.classList.add("quarto-light");
        bodyEl.classList.remove("quarto-dark");
      }
    }
    const toggleBodyColorPrimary = () => {
      const bsSheetEl = window.document.querySelector("link#quarto-bootstrap:not([rel=disabled-stylesheet])");
      if (bsSheetEl) {
        toggleBodyColorMode(bsSheetEl);
      }
    }
    const setColorSchemeToggle = (alternate) => {
      const toggles = window.document.querySelectorAll('.quarto-color-scheme-toggle');
      for (let i=0; i < toggles.length; i++) {
        const toggle = toggles[i];
        if (toggle) {
          if (alternate) {
            toggle.classList.add("alternate");
          } else {
            toggle.classList.remove("alternate");
          }
        }
      }
    };
    const toggleColorMode = (alternate) => {
      // Switch the stylesheets
      const primaryStylesheets = window.document.querySelectorAll('link.quarto-color-scheme:not(.quarto-color-alternate)');
      const alternateStylesheets = window.document.querySelectorAll('link.quarto-color-scheme.quarto-color-alternate');
      manageTransitions('#quarto-margin-sidebar .nav-link', false);
      if (alternate) {
        // note: dark is layered on light, we don't disable primary!
        enableStylesheet(alternateStylesheets);
        for (const sheetNode of alternateStylesheets) {
          if (sheetNode.id === "quarto-bootstrap") {
            toggleBodyColorMode(sheetNode);
          }
        }
      } else {
        disableStylesheet(alternateStylesheets);
        enableStylesheet(primaryStylesheets)
        toggleBodyColorPrimary();
      }
      manageTransitions('#quarto-margin-sidebar .nav-link', true);
      // Switch the toggles
      setColorSchemeToggle(alternate)
      // Hack to workaround the fact that safari doesn't
      // properly recolor the scrollbar when toggling (#1455)
      if (navigator.userAgent.indexOf('Safari') > 0 && navigator.userAgent.indexOf('Chrome') == -1) {
        manageTransitions("body", false);
        window.scrollTo(0, 1);
        setTimeout(() => {
          window.scrollTo(0, 0);
          manageTransitions("body", true);
        }, 40);
      }
    }
    const disableStylesheet = (stylesheets) => {
      for (let i=0; i < stylesheets.length; i++) {
        const stylesheet = stylesheets[i];
        stylesheet.rel = 'disabled-stylesheet';
      }
    }
    const enableStylesheet = (stylesheets) => {
      for (let i=0; i < stylesheets.length; i++) {
        const stylesheet = stylesheets[i];
        if(stylesheet.rel !== 'stylesheet') { // for Chrome, which will still FOUC without this check
          stylesheet.rel = 'stylesheet';
        }
      }
    }
    const manageTransitions = (selector, allowTransitions) => {
      const els = window.document.querySelectorAll(selector);
      for (let i=0; i < els.length; i++) {
        const el = els[i];
        if (allowTransitions) {
          el.classList.remove('notransition');
        } else {
          el.classList.add('notransition');
        }
      }
    }
    const isFileUrl = () => {
      return window.location.protocol === 'file:';
    }
    const hasAlternateSentinel = () => {
      let styleSentinel = getColorSchemeSentinel();
      if (styleSentinel !== null) {
        return styleSentinel === "alternate";
      } else {
        return false;
      }
    }
    const setStyleSentinel = (alternate) => {
      const value = alternate ? "alternate" : "default";
      if (!isFileUrl()) {
        window.localStorage.setItem("quarto-color-scheme", value);
      } else {
        localAlternateSentinel = value;
      }
    }
    const getColorSchemeSentinel = () => {
      if (!isFileUrl()) {
        const storageValue = window.localStorage.getItem("quarto-color-scheme");
        return storageValue != null ? storageValue : localAlternateSentinel;
      } else {
        return localAlternateSentinel;
      }
    }
    const toggleGiscusIfUsed = (isAlternate, darkModeDefault) => {
      const baseTheme = document.querySelector('#giscus-base-theme')?.value ?? 'light';
      const alternateTheme = document.querySelector('#giscus-alt-theme')?.value ?? 'dark';
      let newTheme = '';
      if(authorPrefersDark) {
        newTheme = isAlternate ? baseTheme : alternateTheme;
      } else {
        newTheme = isAlternate ? alternateTheme : baseTheme;
      }
      const changeGiscusTheme = () => {
        // From: https://github.com/giscus/giscus/issues/336
        const sendMessage = (message) => {
          const iframe = document.querySelector('iframe.giscus-frame');
          if (!iframe) return;
          iframe.contentWindow.postMessage({ giscus: message }, 'https://giscus.app');
        }
        sendMessage({
          setConfig: {
            theme: newTheme
          }
        });
      }
      const isGiscussLoaded = window.document.querySelector('iframe.giscus-frame') !== null;
      if (isGiscussLoaded) {
        changeGiscusTheme();
      }
    };
    const authorPrefersDark = false;
    const darkModeDefault = authorPrefersDark;
      document.querySelector('link#quarto-text-highlighting-styles.quarto-color-scheme-extra').rel = 'disabled-stylesheet';
      document.querySelector('link#quarto-bootstrap.quarto-color-scheme-extra').rel = 'disabled-stylesheet';
    let localAlternateSentinel = darkModeDefault ? 'alternate' : 'default';
    // Dark / light mode switch
    window.quartoToggleColorScheme = () => {
      // Read the current dark / light value
      let toAlternate = !hasAlternateSentinel();
      toggleColorMode(toAlternate);
      setStyleSentinel(toAlternate);
      toggleGiscusIfUsed(toAlternate, darkModeDefault);
      window.dispatchEvent(new Event('resize'));
    };
    // Switch to dark mode if need be
    if (hasAlternateSentinel()) {
      toggleColorMode(true);
    } else {
      toggleColorMode(false);
    }
  </script>

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-md " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a href="../../../index.html" class="navbar-brand navbar-brand-logo">
    <img src="../../../assets/images/icons/favicon.png" alt="" class="navbar-logo">
    </a>
    <a class="navbar-brand" href="../../../index.html">
    <span class="navbar-title">Machine Learning Systems</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item">
    <a class="nav-link active" href="../../../contents/labs/labs.html" aria-current="page"> <i class="bi bi-code" role="img">
</i> 
<span class="menu-text">Labs</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../../contents/labs/kits.html"> <i class="bi bi-box" role="img">
</i> 
<span class="menu-text">Kits</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="https://mlsysbook.ai/pdf" target="_blank"> <i class="bi bi-file-pdf" role="img">
</i> 
<span class="menu-text">PDF</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="https://mlsysbook.ai/epub" target="_blank"> <i class="bi bi-book" role="img">
</i> 
<span class="menu-text">EPUB</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="https://github.com/harvard-edge/cs249r_book" target="_blank"> <i class="bi bi-star" role="img">
</i> 
<span class="menu-text">Star</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="https://opencollective.com/mlsysbook" target="_blank"> <i class="bi bi-heart" role="img">
</i> 
<span class="menu-text">Support</span></a>
  </li>  
  <li class="nav-item dropdown ">
    <a class="nav-link dropdown-toggle" href="#" id="nav-menu-github" role="link" data-bs-toggle="dropdown" aria-expanded="false">
      <i class="bi bi-github" role="img">
</i> 
 <span class="menu-text">GitHub</span>
    </a>
    <ul class="dropdown-menu dropdown-menu-end" aria-labelledby="nav-menu-github">    
        <li>
    <a class="dropdown-item" href="https://github.com/harvard-edge/cs249r_book" target="_blank"><i class="bi bi-pencil" role="img">
</i> 
 <span class="dropdown-text">Edit this page</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="https://github.com/harvard-edge/cs249r_book/issues/new" target="_blank"><i class="bi bi-bug" role="img">
</i> 
 <span class="dropdown-text">Report an issue</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="https://github.com/harvard-edge/cs249r_book/discussions" target="_blank"><i class="bi bi-chat" role="img">
</i> 
 <span class="dropdown-text">Discussions</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="https://github.com/harvard-edge/cs249r_book" target="_blank"><i class="bi bi-code" role="img">
</i> 
 <span class="dropdown-text">View source</span></a>
  </li>  
    </ul>
  </li>
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
  <a href="" class="quarto-color-scheme-toggle quarto-navigation-tool  px-1" onclick="window.quartoToggleColorScheme(); return false;" title="Toggle dark mode"><i class="bi"></i></a>
</div>
      </div> <!-- /container-fluid -->
    </nav>
  <nav class="quarto-secondary-nav">
    <div class="container-fluid d-flex">
      <button type="button" class="quarto-btn-toggle btn" data-bs-toggle="collapse" role="button" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
        <i class="bi bi-layout-text-sidebar-reverse"></i>
      </button>
        <nav class="quarto-page-breadcrumbs" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="../../../contents/core/workflow/workflow.html">Design Principles</a></li><li class="breadcrumb-item"><a href="../../../contents/core/workflow/workflow.html">AI Workflow</a></li></ol></nav>
        <a class="flex-grow-1" role="navigation" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">      
        </a>
    </div>
  </nav>
  <div id="quarto-announcement" data-announcement-id="232692330cd6951db05a2d53296deb1e" class="alert alert-primary hidden"><i class="bi bi-megaphone quarto-announcement-icon"></i><div class="quarto-announcement-content">
<p style="margin: 0 0 12px 0; padding: 8px 12px; background: rgba(255,193,7,0.2); border: 1px solid #ffc107; border-radius: 4px; font-weight: 600;"><i class="bi bi-exclamation-triangle-fill" style="margin-right: 6px; color: #856404;"></i><strong>🚧 DEVELOPMENT PREVIEW</strong> - Built from dev@<code style="background: rgba(0,0,0,0.1); padding: 2px 4px; border-radius: 3px; font-size: 0.9em;">5a271b2a</code> • 2025-10-25 19:08 UTC • <a href="https://mlsysbook.ai" style="color: #856404; text-decoration: underline;"><em>Stable version →</em></a></p>
<p>🎉 <strong>Coming 2026:</strong> <em>Machine Learning Systems</em> will be published by <strong>MIT Press</strong>. <a href="https://www.linkedin.com/posts/vijay-janapa-reddi-63a6a173_tinyml-tikz-ai-activity-7338324711145136128-6WU-?utm_source=share&amp;utm_medium=member_desktop&amp;rcm=ACoAAA-V7E4BcYtyZgLSeGhXC2t9jRSlmazfp-I">See the news →</a><br></p>
<p>✨ <strong>Enhanced Content:</strong> Major improvements to chapters, new examples, and more! <a href="../../../contents/frontmatter/changelog/changelog.html">See changelog →</a><br></p>
<p>🚀 <strong>Sneak Peek:</strong> <a href="https://mlsysbook.github.io/TinyTorch/intro.html">Tiny🔥Torch</a>. Exercises to build your own machine learning system from scratch!<br></p>
<p>📦 <strong>New Hardware:</strong> <a href="../../../contents/labs/kits.html">Seeed TinyML Kit</a>. Latest hands-on learning platform.</p>
</div><i class="bi bi-x-lg quarto-announcement-action" style="display: none;"></i></div>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse collapse-horizontal quarto-sidebar-collapse-item sidebar-navigation floating overflow-auto">
    <div class="sidebar-menu-container"> 
    <ul class="list-unstyled mt-1">
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Homepage</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../contents/frontmatter/foreword.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Foreword</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../contents/frontmatter/about/about.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">About the Book</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../contents/frontmatter/changelog/changelog.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Book Changelog</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../contents/frontmatter/acknowledgements/acknowledgements.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Acknowledgements</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../contents/frontmatter/socratiq/socratiq.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">SocratiQ AI</span></a>
  </div>
</li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-1" role="navigation" aria-expanded="true">
 <span class="menu-text">Systems Foundations</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-1" role="navigation" aria-expanded="true" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-1" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../contents/core/introduction/introduction.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Introduction</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../contents/core/ml_systems/ml_systems.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">ML Systems</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../contents/core/dl_primer/dl_primer.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">DL Primer</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../contents/core/dnn_architectures/dnn_architectures.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">DNN Architectures</span></a>
  </div>
</li>
      </ul>
  </li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-2" role="navigation" aria-expanded="true">
 <span class="menu-text">Design Principles</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-2" role="navigation" aria-expanded="true" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-2" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../contents/core/workflow/workflow.html" class="sidebar-item-text sidebar-link active">
 <span class="menu-text">AI Workflow</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../contents/core/data_engineering/data_engineering.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Data Engineering</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../contents/core/frameworks/frameworks.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">AI Frameworks</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../contents/core/training/training.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">AI Training</span></a>
  </div>
</li>
      </ul>
  </li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-3" role="navigation" aria-expanded="true">
 <span class="menu-text">Performance Engineering</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-3" role="navigation" aria-expanded="true" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-3" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../contents/core/efficient_ai/efficient_ai.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Efficient AI</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../contents/core/optimizations/optimizations.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Model Optimizations</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../contents/core/hw_acceleration/hw_acceleration.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">AI Acceleration</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../contents/core/benchmarking/benchmarking.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Benchmarking AI</span></a>
  </div>
</li>
      </ul>
  </li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-4" role="navigation" aria-expanded="true">
 <span class="menu-text">Robust Deployment</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-4" role="navigation" aria-expanded="true" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-4" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../contents/core/ops/ops.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">ML Operations</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../contents/core/ondevice_learning/ondevice_learning.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">On-Device Learning</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../contents/core/privacy_security/privacy_security.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Security &amp; Privacy</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../contents/core/robust_ai/robust_ai.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Robust AI</span></a>
  </div>
</li>
      </ul>
  </li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-5" role="navigation" aria-expanded="true">
 <span class="menu-text">Trustworthy Systems</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-5" role="navigation" aria-expanded="true" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-5" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../contents/core/responsible_ai/responsible_ai.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Responsible AI</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../contents/core/sustainable_ai/sustainable_ai.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Sustainable AI</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../contents/core/ai_for_good/ai_for_good.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">AI for Good</span></a>
  </div>
</li>
      </ul>
  </li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-6" role="navigation" aria-expanded="true">
 <span class="menu-text">Frontiers of ML Systems</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-6" role="navigation" aria-expanded="true" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-6" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../contents/core/frontiers/frontiers.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">AGI Systems</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../contents/core/conclusion/conclusion.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Conclusion</span></a>
  </div>
</li>
      </ul>
  </li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-7" role="navigation" aria-expanded="true">
 <span class="menu-text">Hands-on Labs</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-7" role="navigation" aria-expanded="true" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-7" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../contents/labs/labs.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Getting Started</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../contents/labs/kits.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Hardware Kits</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../contents/labs/ide_setup.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">IDE Setup</span></a>
  </div>
</li>
      </ul>
  </li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-8" role="navigation" aria-expanded="true">
 <span class="menu-text">Arduino</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-8" role="navigation" aria-expanded="true" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-8" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../contents/labs/arduino/nicla_vision/nicla_vision.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Overview</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../contents/labs/arduino/nicla_vision/setup/setup.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Setup</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../contents/labs/arduino/nicla_vision/image_classification/image_classification.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Image Classification</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../contents/labs/arduino/nicla_vision/object_detection/object_detection.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Object Detection</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../contents/labs/arduino/nicla_vision/kws/kws.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Keyword Spotting (KWS)</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../contents/labs/arduino/nicla_vision/motion_classification/motion_classification.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Motion Classification and Anomaly Detection</span></a>
  </div>
</li>
      </ul>
  </li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-9" role="navigation" aria-expanded="true">
 <span class="menu-text">Seeed XIAO ESP32S3</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-9" role="navigation" aria-expanded="true" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-9" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../contents/labs/seeed/xiao_esp32s3/xiao_esp32s3.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Overview</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../contents/labs/seeed/xiao_esp32s3/setup/setup.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Setup</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../contents/labs/seeed/xiao_esp32s3/image_classification/image_classification.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Image Classification</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../contents/labs/seeed/xiao_esp32s3/object_detection/object_detection.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Object Detection</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../contents/labs/seeed/xiao_esp32s3/kws/kws.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Keyword Spotting (KWS)</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../contents/labs/seeed/xiao_esp32s3/motion_classification/motion_classification.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Motion Classification and Anomaly Detection</span></a>
  </div>
</li>
      </ul>
  </li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-10" role="navigation" aria-expanded="true">
 <span class="menu-text">Grove Vision</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-10" role="navigation" aria-expanded="true" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-10" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../contents/labs/seeed/grove_vision_ai_v2/grove_vision_ai_v2.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Overview</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../contents/labs/seeed/grove_vision_ai_v2/setup_and_no_code_apps/setup_and_no_code_apps.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Setup and No-Code Applications</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../contents/labs/seeed/grove_vision_ai_v2/image_classification/image_classification.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Image Classification</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../contents/labs/seeed/grove_vision_ai_v2/object_detection/object_detection.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Object Detection</span></a>
  </div>
</li>
      </ul>
  </li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-11" role="navigation" aria-expanded="true">
 <span class="menu-text">Raspberry Pi</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-11" role="navigation" aria-expanded="true" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-11" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../contents/labs/raspi/raspi.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Overview</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../contents/labs/raspi/setup/setup.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Setup</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../contents/labs/raspi/image_classification/image_classification.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Image Classification</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../contents/labs/raspi/object_detection/object_detection.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Object Detection</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../contents/labs/raspi/llm/llm.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Small Language Models (SLM)</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../contents/labs/raspi/vlm/vlm.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Vision-Language Models (VLM)</span></a>
  </div>
</li>
      </ul>
  </li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-12" role="navigation" aria-expanded="true">
 <span class="menu-text">Shared</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-12" role="navigation" aria-expanded="true" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-12" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../contents/labs/shared/shared.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Overview</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../contents/labs/shared/kws_feature_eng/kws_feature_eng.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">KWS Feature Engineering</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../contents/labs/shared/dsp_spectral_features_block/dsp_spectral_features_block.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">DSP Spectral Features</span></a>
  </div>
</li>
      </ul>
  </li>
        <li class="px-0"><hr class="sidebar-divider hi "></li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-13" role="navigation" aria-expanded="true">
 <span class="menu-text">Glossary</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-13" role="navigation" aria-expanded="true" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-13" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../contents/backmatter/glossary/glossary.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Complete Glossary</span></a>
  </div>
</li>
      </ul>
  </li>
    </ul>
    </div>
</nav>
<div id="quarto-sidebar-glass" class="quarto-sidebar-collapse-item" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item"></div>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active" data-toc-expanded="99">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#sec-ai-workflow" id="toc-sec-ai-workflow" class="nav-link active" data-scroll-target="#sec-ai-workflow">AI Workflow</a>
  <ul>
  <li><a href="#purpose" id="toc-purpose" class="nav-link" data-scroll-target="#purpose">Purpose</a></li>
  <li><a href="#sec-ai-workflow-systematic-framework-ml-development-1fc3" id="toc-sec-ai-workflow-systematic-framework-ml-development-1fc3" class="nav-link" data-scroll-target="#sec-ai-workflow-systematic-framework-ml-development-1fc3">Systematic Framework for ML Development</a></li>
  <li><a href="#sec-ai-workflow-understanding-ml-lifecycle-8445" id="toc-sec-ai-workflow-understanding-ml-lifecycle-8445" class="nav-link" data-scroll-target="#sec-ai-workflow-understanding-ml-lifecycle-8445">Understanding the ML Lifecycle</a></li>
  <li><a href="#sec-ai-workflow-ml-vs-traditional-software-development-0f90" id="toc-sec-ai-workflow-ml-vs-traditional-software-development-0f90" class="nav-link" data-scroll-target="#sec-ai-workflow-ml-vs-traditional-software-development-0f90">ML vs Traditional Software Development</a></li>
  <li><a href="#sec-ai-workflow-six-core-lifecycle-stages-fab9" id="toc-sec-ai-workflow-six-core-lifecycle-stages-fab9" class="nav-link" data-scroll-target="#sec-ai-workflow-six-core-lifecycle-stages-fab9">Six Core Lifecycle Stages</a>
  <ul class="collapse">
  <li><a href="#sec-ai-workflow-case-study-diabetic-retinopathy-screening-system-dbf7" id="toc-sec-ai-workflow-case-study-diabetic-retinopathy-screening-system-dbf7" class="nav-link" data-scroll-target="#sec-ai-workflow-case-study-diabetic-retinopathy-screening-system-dbf7">Case Study: Diabetic Retinopathy Screening System</a>
  <ul class="collapse">
  <li><a href="#sec-ai-workflow-research-success-clinical-reality-77c2" id="toc-sec-ai-workflow-research-success-clinical-reality-77c2" class="nav-link" data-scroll-target="#sec-ai-workflow-research-success-clinical-reality-77c2">From Research Success to Clinical Reality</a></li>
  <li><a href="#sec-ai-workflow-systems-engineering-lessons-144a" id="toc-sec-ai-workflow-systems-engineering-lessons-144a" class="nav-link" data-scroll-target="#sec-ai-workflow-systems-engineering-lessons-144a">Systems Engineering Lessons</a></li>
  </ul></li>
  </ul></li>
  <li><a href="#sec-ai-workflow-problem-definition-stage-3e18" id="toc-sec-ai-workflow-problem-definition-stage-3e18" class="nav-link" data-scroll-target="#sec-ai-workflow-problem-definition-stage-3e18">Problem Definition Stage</a>
  <ul class="collapse">
  <li><a href="#sec-ai-workflow-balancing-competing-constraints-0c62" id="toc-sec-ai-workflow-balancing-competing-constraints-0c62" class="nav-link" data-scroll-target="#sec-ai-workflow-balancing-competing-constraints-0c62">Balancing Competing Constraints</a></li>
  <li><a href="#sec-ai-workflow-collaborative-problem-definition-process-a19c" id="toc-sec-ai-workflow-collaborative-problem-definition-process-a19c" class="nav-link" data-scroll-target="#sec-ai-workflow-collaborative-problem-definition-process-a19c">Collaborative Problem Definition Process</a></li>
  <li><a href="#sec-ai-workflow-adapting-definitions-scale-b2ee" id="toc-sec-ai-workflow-adapting-definitions-scale-b2ee" class="nav-link" data-scroll-target="#sec-ai-workflow-adapting-definitions-scale-b2ee">Adapting Definitions for Scale</a></li>
  </ul></li>
  <li><a href="#sec-ai-workflow-data-collection-preparation-stage-a0aa" id="toc-sec-ai-workflow-data-collection-preparation-stage-a0aa" class="nav-link" data-scroll-target="#sec-ai-workflow-data-collection-preparation-stage-a0aa">Data Collection &amp; Preparation Stage</a>
  <ul class="collapse">
  <li><a href="#sec-ai-workflow-bridging-laboratory-realworld-data-6ebf" id="toc-sec-ai-workflow-bridging-laboratory-realworld-data-6ebf" class="nav-link" data-scroll-target="#sec-ai-workflow-bridging-laboratory-realworld-data-6ebf">Bridging Laboratory and Real-World Data</a></li>
  <li><a href="#sec-ai-workflow-data-infrastructure-distributed-deployment-66ad" id="toc-sec-ai-workflow-data-infrastructure-distributed-deployment-66ad" class="nav-link" data-scroll-target="#sec-ai-workflow-data-infrastructure-distributed-deployment-66ad">Data Infrastructure for Distributed Deployment</a></li>
  <li><a href="#sec-ai-workflow-managing-data-scale-61c3" id="toc-sec-ai-workflow-managing-data-scale-61c3" class="nav-link" data-scroll-target="#sec-ai-workflow-managing-data-scale-61c3">Managing Data at Scale</a></li>
  <li><a href="#sec-ai-workflow-quality-assurance-validation-1bd4" id="toc-sec-ai-workflow-quality-assurance-validation-1bd4" class="nav-link" data-scroll-target="#sec-ai-workflow-quality-assurance-validation-1bd4">Quality Assurance and Validation</a></li>
  </ul></li>
  <li><a href="#sec-ai-workflow-model-development-training-stage-05ec" id="toc-sec-ai-workflow-model-development-training-stage-05ec" class="nav-link" data-scroll-target="#sec-ai-workflow-model-development-training-stage-05ec">Model Development &amp; Training Stage</a>
  <ul class="collapse">
  <li><a href="#sec-ai-workflow-balancing-performance-deployment-constraints-6488" id="toc-sec-ai-workflow-balancing-performance-deployment-constraints-6488" class="nav-link" data-scroll-target="#sec-ai-workflow-balancing-performance-deployment-constraints-6488">Balancing Performance and Deployment Constraints</a></li>
  <li><a href="#sec-ai-workflow-constraintdriven-development-process-a8f3" id="toc-sec-ai-workflow-constraintdriven-development-process-a8f3" class="nav-link" data-scroll-target="#sec-ai-workflow-constraintdriven-development-process-a8f3">Constraint-Driven Development Process</a></li>
  <li><a href="#sec-ai-workflow-prototype-productionscale-development-104e" id="toc-sec-ai-workflow-prototype-productionscale-development-104e" class="nav-link" data-scroll-target="#sec-ai-workflow-prototype-productionscale-development-104e">From Prototype to Production-Scale Development</a></li>
  </ul></li>
  <li><a href="#sec-ai-workflow-deployment-integration-stage-7f90" id="toc-sec-ai-workflow-deployment-integration-stage-7f90" class="nav-link" data-scroll-target="#sec-ai-workflow-deployment-integration-stage-7f90">Deployment &amp; Integration Stage</a>
  <ul class="collapse">
  <li><a href="#sec-ai-workflow-technical-operational-requirements-7574" id="toc-sec-ai-workflow-technical-operational-requirements-7574" class="nav-link" data-scroll-target="#sec-ai-workflow-technical-operational-requirements-7574">Technical and Operational Requirements</a></li>
  <li><a href="#sec-ai-workflow-phased-rollout-integration-process-0a43" id="toc-sec-ai-workflow-phased-rollout-integration-process-0a43" class="nav-link" data-scroll-target="#sec-ai-workflow-phased-rollout-integration-process-0a43">Phased Rollout and Integration Process</a></li>
  <li><a href="#sec-ai-workflow-multisite-deployment-challenges-283d" id="toc-sec-ai-workflow-multisite-deployment-challenges-283d" class="nav-link" data-scroll-target="#sec-ai-workflow-multisite-deployment-challenges-283d">Multi-Site Deployment Challenges</a></li>
  <li><a href="#sec-ai-workflow-ensuring-clinicalgrade-reliability-bff5" id="toc-sec-ai-workflow-ensuring-clinicalgrade-reliability-bff5" class="nav-link" data-scroll-target="#sec-ai-workflow-ensuring-clinicalgrade-reliability-bff5">Ensuring Clinical-Grade Reliability</a></li>
  </ul></li>
  <li><a href="#sec-ai-workflow-monitoring-maintenance-stage-c6f7" id="toc-sec-ai-workflow-monitoring-maintenance-stage-c6f7" class="nav-link" data-scroll-target="#sec-ai-workflow-monitoring-maintenance-stage-c6f7">Monitoring &amp; Maintenance Stage</a>
  <ul class="collapse">
  <li><a href="#sec-ai-workflow-production-monitoring-dynamic-systems-e716" id="toc-sec-ai-workflow-production-monitoring-dynamic-systems-e716" class="nav-link" data-scroll-target="#sec-ai-workflow-production-monitoring-dynamic-systems-e716">Production Monitoring for Dynamic Systems</a></li>
  <li><a href="#sec-ai-workflow-continuous-improvement-feedback-loops-3b51" id="toc-sec-ai-workflow-continuous-improvement-feedback-loops-3b51" class="nav-link" data-scroll-target="#sec-ai-workflow-continuous-improvement-feedback-loops-3b51">Continuous Improvement Through Feedback Loops</a></li>
  <li><a href="#sec-ai-workflow-distributed-system-monitoring-scale-90d6" id="toc-sec-ai-workflow-distributed-system-monitoring-scale-90d6" class="nav-link" data-scroll-target="#sec-ai-workflow-distributed-system-monitoring-scale-90d6">Distributed System Monitoring at Scale</a></li>
  <li><a href="#sec-ai-workflow-anticipating-preventing-system-degradation-b0b9" id="toc-sec-ai-workflow-anticipating-preventing-system-degradation-b0b9" class="nav-link" data-scroll-target="#sec-ai-workflow-anticipating-preventing-system-degradation-b0b9">Anticipating and Preventing System Degradation</a></li>
  </ul></li>
  <li><a href="#sec-ai-workflow-integrating-systems-thinking-principles-6bfc" id="toc-sec-ai-workflow-integrating-systems-thinking-principles-6bfc" class="nav-link" data-scroll-target="#sec-ai-workflow-integrating-systems-thinking-principles-6bfc">Integrating Systems Thinking Principles</a>
  <ul class="collapse">
  <li><a href="#sec-ai-workflow-decisions-cascade-system-4927" id="toc-sec-ai-workflow-decisions-cascade-system-4927" class="nav-link" data-scroll-target="#sec-ai-workflow-decisions-cascade-system-4927">How Decisions Cascade Through the System</a></li>
  <li><a href="#sec-ai-workflow-orchestrating-feedback-across-multiple-timescales-310d" id="toc-sec-ai-workflow-orchestrating-feedback-across-multiple-timescales-310d" class="nav-link" data-scroll-target="#sec-ai-workflow-orchestrating-feedback-across-multiple-timescales-310d">Orchestrating Feedback Across Multiple Timescales</a></li>
  <li><a href="#sec-ai-workflow-understanding-systemlevel-behaviors-2762" id="toc-sec-ai-workflow-understanding-systemlevel-behaviors-2762" class="nav-link" data-scroll-target="#sec-ai-workflow-understanding-systemlevel-behaviors-2762">Understanding System-Level Behaviors</a></li>
  <li><a href="#sec-ai-workflow-multidimensional-resource-tradeoffs-bb50" id="toc-sec-ai-workflow-multidimensional-resource-tradeoffs-bb50" class="nav-link" data-scroll-target="#sec-ai-workflow-multidimensional-resource-tradeoffs-bb50">Multi-Dimensional Resource Trade-offs</a></li>
  <li><a href="#sec-ai-workflow-engineering-discipline-ml-systems-b4e3" id="toc-sec-ai-workflow-engineering-discipline-ml-systems-b4e3" class="nav-link" data-scroll-target="#sec-ai-workflow-engineering-discipline-ml-systems-b4e3">Engineering Discipline for ML Systems</a></li>
  </ul></li>
  <li><a href="#sec-ai-workflow-fallacies-pitfalls-6c5b" id="toc-sec-ai-workflow-fallacies-pitfalls-6c5b" class="nav-link" data-scroll-target="#sec-ai-workflow-fallacies-pitfalls-6c5b">Fallacies and Pitfalls</a></li>
  <li><a href="#sec-ai-workflow-summary-84ad" id="toc-sec-ai-workflow-summary-84ad" class="nav-link" data-scroll-target="#sec-ai-workflow-summary-84ad">Summary</a></li>
  <li><a href="#self-check-answers" id="toc-self-check-answers" class="nav-link" data-scroll-target="#self-check-answers">Self-Check Answers</a></li>
  </ul></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content page-columns page-full" id="quarto-document-content"><header id="title-block-header" class="quarto-title-block"><nav class="quarto-page-breadcrumbs quarto-title-breadcrumbs d-none d-lg-block" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="../../../contents/core/workflow/workflow.html">Design Principles</a></li><li class="breadcrumb-item"><a href="../../../contents/core/workflow/workflow.html">AI Workflow</a></li></ol></nav></header>





<section id="sec-ai-workflow" class="level1 page-columns page-full">
<h1>AI Workflow</h1>
<div class="{layout-narrow} page-columns page-full">

<div class="no-row-height column-margin column-container"><div class="">
<p><em>DALL·E 3 Prompt: Create a rectangular illustration of a stylized flowchart representing the AI workflow/pipeline. From left to right, depict the stages as follows: ‘Data Collection’ with a database icon, ‘Data Preprocessing’ with a filter icon, ‘Model Design’ with a brain icon, ‘Training’ with a weight icon, ‘Evaluation’ with a checkmark, and ‘Deployment’ with a rocket. Connect each stage with arrows to guide the viewer horizontally through the AI processes, emphasizing these steps’ sequential and interconnected nature.</em></p>
</div></div><p> <img src="images/png/cover_ai_workflow.png" class="img-fluid"></p>
</div>
<section id="purpose" class="level2 unnumbered">
<h2 class="unnumbered anchored" data-anchor-id="purpose">Purpose</h2>
<p><em>What systematic framework guides the engineering of machine learning systems from initial development through production deployment?</em></p>
<p>Production machine learning systems require systematic thinking and structured frameworks. Workflows organize ML development into standardized stages: data collection, model development, validation, and deployment. These structured processes manage data quality and consistency, coordinate model training and experimentation, automate optimization pipelines, and orchestrate deployment across environments. These systematic approaches transform experimental intuition into engineering discipline, establishing the mental framework for ML systems. This disciplined foundation enables reproducible system development, quality standard maintenance, and informed decision-making across the entire ML lifecycle.</p>
<div class="callout callout-style-default callout-tip callout-titled" title="Learning Objectives">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Learning Objectives
</div>
</div>
<div class="callout-body-container callout-body">
<ul>
<li><p>Compare ML lifecycle stages to traditional software development processes, identifying at least three fundamental differences.</p></li>
<li><p>Analyze the six core ML lifecycle stages (problem definition through maintenance) and their interconnected feedback relationships.</p></li>
<li><p>Apply systems thinking principles to trace how constraint propagation affects decisions across multiple lifecycle stages.</p></li>
<li><p>Evaluate trade-offs between model performance and deployment constraints using specific quantitative metrics.</p></li>
<li><p>Design data collection strategies that account for real-world deployment environments and operational requirements.</p></li>
<li><p>Implement monitoring frameworks that capture multi-scale feedback loops from production ML systems.</p></li>
<li><p>Assess the impact of problem definition decisions on subsequent model development and deployment choices.</p></li>
<li><p>Construct deployment architectures that balance computational efficiency with performance requirements in resource-constrained environments.</p></li>
</ul>
</div>
</div>
</section>
<section id="sec-ai-workflow-systematic-framework-ml-development-1fc3" class="level2 page-columns page-full">
<h2 class="anchored" data-anchor-id="sec-ai-workflow-systematic-framework-ml-development-1fc3">Systematic Framework for ML Development</h2>
<p>Building upon Part I’s foundational principles (system characteristics, deployment environments, mathematical frameworks, and architectural patterns), this chapter advances from component-level analysis to system-level engineering. The transition from theoretical understanding to operational implementation requires a systematic framework governing production machine learning system development.</p>
<p>This chapter introduces the machine learning workflow as the governing methodology for systematic ML system development. Traditional software engineering proceeds through deterministic requirement-to-implementation pathways, while machine learning systems development exhibits fundamentally different characteristics. ML systems evolve through iterative experimentation<a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a> where models extract patterns from data, performance metrics undergo statistical validation, and deployment constraints create feedback mechanisms that inform earlier development phases. This empirical, data-centric approach requires specialized workflow methodologies that accommodate uncertainty, coordinate parallel development streams, and establish continuous improvement mechanisms.</p>
<div class="no-row-height column-margin column-container"><div id="fn1"><p><sup>1</sup>&nbsp;<strong>Scientific Method in ML Development</strong>: ML development follows scientific methodology more than traditional software engineering: hypothesize (model architecture choices), experiment (train and validate), analyze results (performance metrics), and iterate based on findings. This differs from deterministic software where requirements map directly to implementation. The “experiment-driven development” approach emerged from academic research labs in the 1990s-2000s but became essential for production ML when Google, Facebook, and others discovered that empirical validation outperformed theoretical predictions in complex, real-world systems.</p></div></div><p>The systematic framework presented here establishes the theoretical foundation for understanding Part II’s design principles. This workflow perspective clarifies the rationale for specialized data engineering pipelines (Chapter 6), the role of software frameworks in enabling iterative methodologies (Chapter 7), and the integration of model training within comprehensive system lifecycles (Chapter 8). Without this conceptual scaffolding, subsequent technical components appear as disparate tools rather than integrated elements within a coherent engineering discipline.</p>
<p>The chapter employs diabetic retinopathy screening system development as a pedagogical case study, demonstrating how workflow principles bridge laboratory research and clinical deployment. This example illustrates the intricate interdependencies among data acquisition strategies, architectural design decisions, deployment constraint management, and operational requirement fulfillment that characterize production-scale ML systems. These systematic patterns generalize beyond medical applications, exemplifying the engineering discipline required for reliable machine learning system operation across diverse domains.</p>
<div id="quiz-question-sec-ai-workflow-systematic-framework-ml-development-1fc3" class="callout callout-quiz-question">
<details class="callout-quiz-question fbx-default closebutton"><summary><strong>Self-Check: Question 1.1</strong></summary><div>
<ol type="1">
<li><p>How does the machine learning workflow differ from traditional software engineering processes?</p>
<ol type="a">
<li>ML workflow is iterative and data-centric, involving experimentation and empirical validation.</li>
<li>ML workflow is deterministic and follows a strict requirement-to-implementation path.</li>
<li>ML workflow does not involve any feedback mechanisms.</li>
<li>ML workflow is identical to traditional software engineering.</li>
</ol></li>
<li><p>Why is iterative experimentation crucial in the development of machine learning systems?</p></li>
<li><p>What role do feedback mechanisms play in the ML system development workflow?</p>
<ol type="a">
<li>They are unnecessary as ML systems are static once deployed.</li>
<li>They are used to finalize the initial model without further changes.</li>
<li>They only apply to traditional software engineering.</li>
<li>They inform earlier development phases and help refine models.</li>
</ol></li>
<li><p>In the context of ML system development, how might the diabetic retinopathy screening system case study illustrate the workflow principles discussed?</p></li>
</ol>
<p><a href="#quiz-answer-sec-ai-workflow-systematic-framework-ml-development-1fc3" class="question-label">See Answers →</a></p>
</div></details>
</div>
</section>
<section id="sec-ai-workflow-understanding-ml-lifecycle-8445" class="level2 page-columns page-full">
<h2 class="anchored" data-anchor-id="sec-ai-workflow-understanding-ml-lifecycle-8445">Understanding the ML Lifecycle</h2>
<p>The machine learning lifecycle is a structured, iterative process that guides the development, evaluation, and improvement of machine learning systems. This approach integrates systematic experimentation, evaluation, and adaptation over time <span class="citation" data-cites="amershi2019software">(<a href="#ref-amershi2019software" role="doc-biblioref">Amershi et al. 2019</a>)</span>, building upon decades of structured development approaches <span class="citation" data-cites="chapman2000crisp">(<a href="#ref-chapman2000crisp" role="doc-biblioref">Chapman et al. 2000</a>)</span><a href="#fn2" class="footnote-ref" id="fnref2" role="doc-noteref"><sup>2</sup></a> while addressing the unique challenges of data-driven systems.</p>
<div class="no-row-height column-margin column-container"><div id="ref-chapman2000crisp" class="csl-entry" role="listitem">
Chapman, Pete, Julian Clinton, Randy Kerber, Thomas Khabaza, Thomas Reinartz, Colin Shearer, and Rudiger Wirth. 2000. <span>“CRISP-DM 1.0: Step-by-Step Data Mining Guide.”</span> <em>SPSS Inc</em>, 78. <a href="https://www.the-modeling-agency.com/crisp-dm.pdf">https://www.the-modeling-agency.com/crisp-dm.pdf</a>.
</div><div id="fn2"><p><sup>2</sup>&nbsp;<strong>CRISP-DM (Cross-Industry Standard Process for Data Mining)</strong>: A methodology developed in 1996 by a consortium including IBM, SPSS, and Daimler-Chrysler to provide a standard framework for data mining projects. CRISP-DM defined six phases: Business Understanding, Data Understanding, Data Preparation, Modeling, Evaluation, and Deployment. While predating modern ML, CRISP-DM established the iterative, data-centric workflow principles that evolved into today’s MLOps practices, influencing 90% of data mining projects by 2010 and serving as the foundation for ML lifecycle frameworks like Team Data Science Process (TDSP) and KDD.</p></div><div id="fn3"><p><sup>3</sup>&nbsp;<strong>Systems Thinking</strong>: A holistic approach to analysis that focuses on the ways that a system’s constituent parts interrelate and how systems work over time and within larger systems. Developed by MIT’s Jay Forrester in the 1950s for industrial dynamics, systems thinking became crucial for ML engineering because models, data, infrastructure, and operations interact in complex ways that produce emergent behaviors. Unlike traditional software where components can be optimized independently, ML systems require understanding interdependencies—how data quality affects model performance, how model complexity influences deployment constraints, and how monitoring insights drive system evolution.</p></div></div><p>Understanding this lifecycle requires a systems thinking<a href="#fn3" class="footnote-ref" id="fnref3" role="doc-noteref"><sup>3</sup></a> approach recognizing four fundamental patterns: constraint propagation (how decisions in one stage influence all others), multi-scale feedback loops (how systems adapt across different timescales), emergent complexity (how system-wide behaviors differ from component behaviors), and resource optimization (how trade-offs create interdependencies). These patterns, explored throughout our diabetic retinopathy case study, provide the analytical framework for understanding why ML systems demand integrated engineering approaches rather than sequential component optimization.</p>
<div id="callout-definition*-1.1" class="callout callout-definition" title="Definition of the Machine Learning Lifecycle">
<p></p><details class="callout-definition fbx-default closebutton" open=""><summary><strong>Definition: </strong>Definition of the Machine Learning Lifecycle</summary><div><strong><em>The Machine Learning (ML) Lifecycle</em></strong> is a <em>structured, iterative process</em> that defines the <em>key stages</em> involved in the <em>development, deployment, and refinement</em> of ML systems. It encompasses <em>interconnected steps</em> such as <em>problem formulation, data collection, model training, evaluation, deployment, and monitoring</em>. The lifecycle focuses on <em>feedback loops and continuous improvement</em>, ensuring that systems remain <em>robust, scalable, and responsive</em> to <em>changing requirements and real-world conditions</em>.<p></p>
</div></details>
</div>
<p><a href="#fig-ml-lifecycle" class="quarto-xref">Figure&nbsp;1</a> visualizes this complete lifecycle through two parallel pipelines: the data pipeline (green, top row) transforms raw inputs through collection, ingestion, analysis, labeling, validation, and preparation into ML-ready datasets. The model development pipeline (blue, bottom row) takes these datasets through training, evaluation, validation, and deployment to create production systems. The critical insight lies in their interconnections—the curved feedback arrows show how deployment insights trigger data refinements, creating continuous improvement cycles that distinguish ML from traditional linear development.</p>
<div id="fig-ml-lifecycle" class="quarto-float quarto-figure quarto-figure-center anchored" data-fig-env="figure" data-fig-pos="htb">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-ml-lifecycle-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<a href="03bbeaedbd5366f135a9b5e0ac5ecbb9aab154a3.svg" class="lightbox" data-gallery="quarto-lightbox-gallery-1" title="Figure&nbsp;1: ML Lifecycle Stages: The prominent feedback arrows (shown as thick curved lines with bold colors) emphasize the iterative nature of machine learning development, where monitoring insights continuously inform data refinements, evaluation results trigger model improvements, and deployment experiences reshape data collection strategies. These visual feedback loops represent the primary drivers of the ML lifecycle, distinguishing it from linear development approaches where later stages rarely influence earlier phases."><img src="workflow_files/mediabag/03bbeaedbd5366f135a9b5e0ac5ecbb9aab154a3.svg" class="img-fluid figure-img"></a>
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-ml-lifecycle-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;1: <strong>ML Lifecycle Stages</strong>: The prominent feedback arrows (shown as thick curved lines with bold colors) emphasize the iterative nature of machine learning development, where monitoring insights continuously inform data refinements, evaluation results trigger model improvements, and deployment experiences reshape data collection strategies. These visual feedback loops represent the primary drivers of the ML lifecycle, distinguishing it from linear development approaches where later stages rarely influence earlier phases.
</figcaption>
</figure>
</div>
<p>This workflow framework serves as scaffolding for the technical chapters ahead. The data pipeline illustrated here receives comprehensive treatment in <strong><a href="../data_engineering/data_engineering.html#sec-data-engineering">Chapter 6: Data Engineering</a></strong>, which addresses how to ensure data quality and manage data throughout the ML lifecycle. Model training expands into <strong><a href="../training/training.html#sec-ai-training">Chapter 8: AI Training</a></strong>, covering how to efficiently train models at scale. The software frameworks that enable this iterative development process are detailed in <strong><a href="../frameworks/frameworks.html#sec-ai-frameworks">Chapter 7: AI Frameworks</a></strong>. Deployment and ongoing operations extend into <strong><a href="../ops/ops.html#sec-ml-operations">Chapter 13: ML Operations</a></strong>, addressing how systems maintain performance in production. This chapter establishes how these pieces interconnect before we explore each in depth—understanding the complete system makes the specialized components meaningful.</p>
<p>This chapter focuses on the conceptual stages of the ML lifecycle—the “what” and “why” of the development process. The operational implementation of this lifecycle through automation, tooling, and infrastructure—the “how”—is the domain of MLOps, which we will explore in detail in <strong><a href="../ops/ops.html#sec-ml-operations">Chapter 13: ML Operations</a></strong>. This distinction is crucial: the lifecycle provides the systematic framework for understanding ML development stages, while MLOps provides the operational practices for implementing these stages at scale. Understanding this lifecycle foundation makes the specialized MLOps tools and practices meaningful rather than appearing as disparate operational concerns.</p>
<div id="quiz-question-sec-ai-workflow-understanding-ml-lifecycle-8445" class="callout callout-quiz-question">
<details class="callout-quiz-question fbx-default closebutton"><summary><strong>Self-Check: Question 1.2</strong></summary><div>
<ol type="1">
<li><p>Which of the following best describes the role of feedback loops in the ML lifecycle?</p>
<ol type="a">
<li>They ensure that each stage of the lifecycle is completed before moving to the next.</li>
<li>They are used to validate the final model before deployment.</li>
<li>They allow for continuous improvement by informing earlier stages with insights from later stages.</li>
<li>They help in maintaining a linear development process.</li>
</ol></li>
<li><p>Explain how systems thinking applies to the machine learning lifecycle and why it is important.</p></li>
<li><p>Order the following stages of the ML lifecycle from data collection to deployment: (1) Model Training, (2) Data Preparation, (3) Model Evaluation, (4) Data Collection, (5) ML System Deployment.</p></li>
<li><p>True or False: The ML lifecycle is a linear process where each stage is independent of the others.</p></li>
</ol>
<p><a href="#quiz-answer-sec-ai-workflow-understanding-ml-lifecycle-8445" class="question-label">See Answers →</a></p>
</div></details>
</div>
</section>
<section id="sec-ai-workflow-ml-vs-traditional-software-development-0f90" class="level2 page-columns page-full">
<h2 class="anchored" data-anchor-id="sec-ai-workflow-ml-vs-traditional-software-development-0f90">ML vs Traditional Software Development</h2>
<p>Machine learning requires specialized lifecycle approaches because ML development differs fundamentally from traditional software engineering. Traditional lifecycles consist of sequential phases: requirements gathering, system design, implementation, testing, and deployment <span class="citation" data-cites="royce1970managing">(<a href="#ref-royce1970managing" role="doc-biblioref">Royce 1987</a>)</span><a href="#fn4" class="footnote-ref" id="fnref4" role="doc-noteref"><sup>4</sup></a>. Each phase produces specific artifacts that serve as inputs to subsequent phases. In financial software development, the requirements phase produces detailed specifications for transaction processing, security protocols, and regulatory compliance. These specifications translate directly into system behavior through explicit programming, contrasting sharply with the probabilistic nature of ML systems explored throughout <strong><a href="../introduction/introduction.html#sec-introduction">Chapter 1: Introduction</a></strong>.</p>
<div class="no-row-height column-margin column-container"><div id="ref-royce1970managing" class="csl-entry" role="listitem">
Royce, W. W. 1987. <span>“Managing the Development of Large Software Systems: Concepts and Techniques.”</span> In <em>Proceedings of IEEE WESCON</em>, 26:328–39. IEEE. <a href="http://dl.acm.org/citation.cfm?id=41801">http://dl.acm.org/citation.cfm?id=41801</a>.
</div><div id="fn4"><p><sup>4</sup>&nbsp;<strong>Waterfall Model</strong>: A sequential software development methodology introduced by Winston Royce in 1970, where development flows through distinct phases (requirements → design → implementation → testing → deployment) like water flowing down stairs. Each phase must be completed before the next begins, with formal documentation and approval gates. While criticized for inflexibility, waterfall dominated enterprise software development for decades and still suits projects with stable, well-understood requirements. The model’s linear approach contrasts starkly with ML development’s inherent uncertainty and need for experimentation.</p></div><div id="fn5"><p><sup>5</sup>&nbsp;<strong>ML-Based Fraud Detection Evolution</strong>: Traditional rule-based fraud systems had 60-80% accuracy and generated 10-40% false positives. Modern ML fraud detection achieves 85-95% accuracy with 1-5% false positive rates by analyzing hundreds of behavioral features <span class="citation" data-cites="stripe2019machine">(<a href="#ref-stripe2019machine" role="doc-biblioref">Arsene, Dumitrache, and Mihu 2015</a>)</span>. However, this improvement comes with new challenges: fraudsters adapt to ML patterns within 3-6 months, requiring continuous model retraining that rule-based systems never needed <span class="citation" data-cites="stripe2019machine">(<a href="#ref-stripe2019machine" role="doc-biblioref">Arsene, Dumitrache, and Mihu 2015</a>)</span>.</p></div></div><p>Machine learning systems require a fundamentally different approach. The deterministic nature of conventional software, where behavior is explicitly programmed, contrasts with the probabilistic nature of ML systems. Consider financial transaction processing: traditional systems follow predetermined rules (if account balance &gt; transaction amount, then allow transaction), while ML-based fraud detection systems<a href="#fn5" class="footnote-ref" id="fnref5" role="doc-noteref"><sup>5</sup></a> learn to recognize suspicious patterns from historical transaction data. This shift from explicit programming to learned behavior reshapes the development lifecycle, altering how we approach system reliability and robustness as detailed in <strong><a href="../robust_ai/robust_ai.html#sec-robust-ai">Chapter 16: Robust AI</a></strong>.</p>
<p>These fundamental differences in system behavior introduce new dynamics that alter how lifecycle stages interact. These systems require ongoing refinement through continuous feedback loops that enable insights from deployment to inform earlier development phases. Machine learning systems are inherently dynamic and must adapt to changing data distributions and objectives through continuous deployment<a href="#fn6" class="footnote-ref" id="fnref6" role="doc-noteref"><sup>6</sup></a> practices.</p>
<div class="no-row-height column-margin column-container"><div id="fn6"><p><sup>6</sup>&nbsp;<strong>Continuous Deployment</strong>: Software engineering practice where code changes are automatically deployed to production after passing automated tests, enabling multiple deployments per day instead of monthly releases. Popularized by companies like Netflix (2008) and Etsy (2009), continuous deployment reduces deployment risk through small, frequent changes rather than large, infrequent releases. However, ML systems require specialized continuous deployment because models need statistical validation, gradual rollouts with A/B testing, and rollback mechanisms based on performance metrics rather than just functional correctness.</p></div><div id="fn7"><p><sup>7</sup>&nbsp;<strong>Data Versioning Challenges</strong>: Unlike code, which changes through discrete edits, data can change gradually through drift, suddenly through schema changes, or subtly through quality degradation. Traditional version control systems like Git struggle with large datasets, leading to specialized tools like Git LFS and DVC.</p></div></div><p>These contrasts become clearer when we examine the specific differences across development lifecycle dimensions. The key distinctions are summarized in <a href="#tbl-sw-ml-cycles" class="quarto-xref">Table&nbsp;1</a> below. These differences reflect the core challenge of working with data as a first-class citizen in system design, something traditional software engineering methodologies were not designed to handle<a href="#fn7" class="footnote-ref" id="fnref7" role="doc-noteref"><sup>7</sup></a>.</p>
<div id="tbl-sw-ml-cycles" class="quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-tbl figure">
<figcaption class="quarto-float-caption-top quarto-float-caption quarto-float-tbl" id="tbl-sw-ml-cycles-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Table&nbsp;1: <strong>Traditional vs ML Development</strong>: Traditional software and machine learning systems diverge in their development processes due to the data-driven and iterative nature of ML. Machine learning lifecycles emphasize experimentation and evolving objectives, requiring feedback loops between stages, whereas traditional software follows a linear progression with predefined specifications.
</figcaption>
<div aria-describedby="tbl-sw-ml-cycles-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<table class="caption-top table">
<colgroup>
<col style="width: 22%">
<col style="width: 34%">
<col style="width: 41%">
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;"><strong>Aspect</strong></th>
<th style="text-align: left;"><strong>Traditional Software Lifecycles</strong></th>
<th style="text-align: left;"><strong>Machine Learning Lifecycles</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><strong>Problem Definition</strong></td>
<td style="text-align: left;">Precise functional specifications are defined upfront.</td>
<td style="text-align: left;">Performance-driven objectives evolve as the problem space is explored.</td>
</tr>
<tr class="even">
<td style="text-align: left;"><strong>Development Process</strong></td>
<td style="text-align: left;">Linear progression of feature implementation.</td>
<td style="text-align: left;">Iterative experimentation with data, features and models.</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><strong>Testing and</strong></td>
<td style="text-align: left;">Deterministic, binary pass/fail</td>
<td style="text-align: left;">Statistical validation and metrics that</td>
</tr>
<tr class="even">
<td style="text-align: left;"><strong>Validation</strong></td>
<td style="text-align: left;">testing criteria.</td>
<td style="text-align: left;">involve uncertainty.</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><strong>Deployment</strong></td>
<td style="text-align: left;">Behavior remains static until explicitly updated.</td>
<td style="text-align: left;">Performance may change over time due to shifts in data distributions.</td>
</tr>
<tr class="even">
<td style="text-align: left;"><strong>Maintenance</strong></td>
<td style="text-align: left;">Maintenance involves modifying code to address bugs or add features.</td>
<td style="text-align: left;">Continuous monitoring, updating data pipelines, retraining models, and adapting to new data distributions.</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><strong>Feedback Loops</strong></td>
<td style="text-align: left;">Minimal; later stages rarely impact earlier phases.</td>
<td style="text-align: left;">Frequent; insights from deployment and monitoring often refine earlier stages like data preparation and model design.</td>
</tr>
</tbody>
</table>
</div>
</figure>
</div>
<p>These six dimensions reveal a fundamental pattern: machine learning systems replace deterministic specifications with probabilistic optimization, static behavior with dynamic adaptation, and isolated development with continuous feedback. This shift explains why traditional project management approaches fail when applied to ML projects without modification.</p>
<p>Experimentation in machine learning differs fundamentally from testing in traditional software. In ML, experimentation constitutes the core development process itself, not simply bug detection. It involves systematically testing hypotheses about data sources, feature engineering approaches, model architectures, and hyperparameters to yield optimal performance. This represents a scientific process of discovery, not merely a quality assurance step. Traditional software testing verifies code behavior according to predetermined specifications, while ML experimentation explores uncertain spaces to discover optimal combinations producing the best empirical results.</p>
<p>These differences emphasize the need for robust ML lifecycle frameworks that accommodate iterative development, dynamic behavior, and data-driven decision-making. Understanding these distinctions enables examination of how ML projects unfold through their lifecycle stages, each presenting unique challenges that traditional software methodologies cannot adequately address.</p>
<p>This foundation enables exploration of the specific stages comprising the ML lifecycle and how they address these unique challenges.</p>
<div id="quiz-question-sec-ai-workflow-ml-vs-traditional-software-development-0f90" class="callout callout-quiz-question">
<details class="callout-quiz-question fbx-default closebutton"><summary><strong>Self-Check: Question 1.3</strong></summary><div>
<ol type="1">
<li><p>Which of the following best describes a key difference between traditional software development and machine learning development?</p>
<ol type="a">
<li>Traditional software development follows a linear progression with predefined specifications, whereas ML development involves iterative experimentation and evolving objectives.</li>
<li>ML development relies on deterministic specifications, while traditional development is probabilistic.</li>
<li>Traditional software development is iterative, while ML development is linear.</li>
<li>ML development does not require feedback loops, unlike traditional software development.</li>
</ol></li>
<li><p>Explain why continuous feedback loops are crucial in the machine learning development lifecycle.</p></li>
<li><p>Order the following dimensions of development lifecycle differences between traditional software and ML systems: (1) Deployment, (2) Testing and Validation, (3) Feedback Loops.</p></li>
</ol>
<p><a href="#quiz-answer-sec-ai-workflow-ml-vs-traditional-software-development-0f90" class="question-label">See Answers →</a></p>
</div></details>
</div>
</section>
<section id="sec-ai-workflow-six-core-lifecycle-stages-fab9" class="level2 page-columns page-full">
<h2 class="anchored" data-anchor-id="sec-ai-workflow-six-core-lifecycle-stages-fab9">Six Core Lifecycle Stages</h2>
<p>AI systems require specialized development approaches. The specific stages that comprise the ML lifecycle provide this specialized framework. These stages operate as an integrated framework where each builds upon previous foundations while preparing for subsequent phases.</p>
<p>Moving from the detailed pipeline view in <a href="#fig-ml-lifecycle" class="quarto-xref">Figure&nbsp;1</a>, we now present a higher-level conceptual perspective. <a href="#fig-lifecycle-overview" class="quarto-xref">Figure&nbsp;2</a> consolidates these detailed pipelines into six major lifecycle stages, providing a simplified framework for understanding the overall progression of ML system development. This abstraction helps us reason about the broader phases without getting lost in pipeline-specific details. Where the earlier figure emphasized the parallel processing of data and models, this conceptual view emphasizes the sequential progression through major development phases—though as we’ll explore, these phases remain interconnected through continuous feedback.</p>
<p><a href="#fig-lifecycle-overview" class="quarto-xref">Figure&nbsp;2</a> illustrates the six core stages that characterize successful AI system development: Problem Definition establishes objectives and constraints, Data Collection &amp; Preparation encompasses the entire data pipeline, Model Development &amp; Training covers model creation, Evaluation &amp; Validation ensures quality, Deployment &amp; Integration brings systems to production, and Monitoring &amp; Maintenance ensures continued effectiveness. These stages operate through continuous feedback loops, with insights from later stages frequently informing refinements in earlier phases. This cyclical nature reflects the experimental and data-driven characteristics that distinguish ML development from conventional software engineering.</p>
<div id="fig-lifecycle-overview" class="quarto-float quarto-figure quarto-figure-center anchored" data-fig-env="figure" data-fig-pos="htb">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-lifecycle-overview-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<a href="9b58b3aa72de00d638019e0cdf45f488ecf3911f.svg" class="lightbox" data-gallery="quarto-lightbox-gallery-2" title="Figure&nbsp;2: ML System Lifecycle: The continuous feedback loop (emphasized by the prominent return path from monitoring back to data collection) drives iterative development that defines successful machine learning systems. This cycle progresses through problem definition, data preparation, model building, evaluation, deployment, and ongoing monitoring, but the large feedback arrow illustrates how insights from later stages continuously inform and refine earlier phases, enabling adaptation to changing requirements and data distributions."><img src="workflow_files/mediabag/9b58b3aa72de00d638019e0cdf45f488ecf3911f.svg" class="img-fluid figure-img"></a>
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-lifecycle-overview-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;2: <strong>ML System Lifecycle</strong>: The continuous feedback loop (emphasized by the prominent return path from monitoring back to data collection) drives iterative development that defines successful machine learning systems. This cycle progresses through problem definition, data preparation, model building, evaluation, deployment, and ongoing monitoring, but the large feedback arrow illustrates how insights from later stages continuously inform and refine earlier phases, enabling adaptation to changing requirements and data distributions.
</figcaption>
</figure>
</div>
<p>The lifecycle begins with problem definition and requirements gathering, where teams clearly define the problem to be solved, establish measurable performance objectives, and identify key constraints. Precise problem definition ensures alignment between the system’s goals and the desired outcomes, setting the foundation for all subsequent work.</p>
<p>Building on this foundation, the next stage assembles the data resources needed to realize these objectives. Data collection and preparation includes gathering relevant data, cleaning it, and preparing it for model training. This process involves curating diverse datasets, ensuring high-quality labeling, and developing preprocessing pipelines to address variations in the data. The complexities of this stage are explored in <strong><a href="../data_engineering/data_engineering.html#sec-data-engineering">Chapter 6: Data Engineering</a></strong>.</p>
<p>With data resources in place, the development process creates models that can learn from these resources. Model development and training involves selecting appropriate algorithms, designing model architectures, and training models using the prepared data. Success depends on choosing techniques suited to the problem and iterating on the model design for optimal performance. Advanced training approaches and distributed training strategies are detailed in <strong><a href="../training/training.html#sec-ai-training">Chapter 8: AI Training</a></strong>, while the underlying architectures are covered in <strong><a href="../dnn_architectures/dnn_architectures.html#sec-dnn-architectures">Chapter 4: DNN Architectures</a></strong>.</p>
<p>Once models are trained, rigorous evaluation ensures they meet performance requirements before deployment. This evaluation and validation stage involves rigorously testing the model’s performance against predefined metrics and validating its behavior in different scenarios, ensuring the model is accurate, reliable, and robust in real-world conditions.</p>
<p>With validation complete, models transition from development environments to operational systems through careful deployment processes. Deployment and integration requires addressing practical challenges such as system compatibility, scalability, and operational constraints across different deployment contexts ranging from cloud to edge environments, as explored in <strong><a href="../ml_systems/ml_systems.html#sec-ml-systems">Chapter 2: ML Systems</a></strong>.</p>
<p>The final stage recognizes that deployed systems require ongoing oversight to maintain performance and adapt to changing conditions. This monitoring and maintenance stage focuses on continuously tracking the system’s performance in real-world environments and updating it as necessary. Effective monitoring ensures the system remains relevant and accurate over time, adapting to changes in data, requirements, or external conditions.</p>
<section id="sec-ai-workflow-case-study-diabetic-retinopathy-screening-system-dbf7" class="level3 page-columns page-full">
<h3 class="anchored" data-anchor-id="sec-ai-workflow-case-study-diabetic-retinopathy-screening-system-dbf7">Case Study: Diabetic Retinopathy Screening System</h3>
<p>To ground these lifecycle principles in reality, we examine the development of diabetic retinopathy (DR) screening systems from initial research to widespread clinical deployment <span class="citation" data-cites="gulshan2016deep">(<a href="#ref-gulshan2016deep" role="doc-biblioref">Gulshan et al. 2016</a>)</span>. Throughout this chapter, we use this case as a pedagogical vehicle to demonstrate how lifecycle stages interconnect in practice, showing how decisions in one phase influence subsequent stages.</p>
<div class="no-row-height column-margin column-container"></div><p><em>Note: While this narrative draws from documented experiences with diabetic retinopathy screening deployments, including Google’s work, we have adapted and synthesized details to illustrate common challenges encountered in healthcare AI systems. Our goal is educational—demonstrating lifecycle principles through a realistic example—rather than providing a documentary account of any specific project. The technical choices, constraints, and solutions presented represent typical patterns in medical AI development that illuminate broader systems thinking principles.</em></p>
<section id="sec-ai-workflow-research-success-clinical-reality-77c2" class="level4 page-columns page-full">
<h4 class="anchored" data-anchor-id="sec-ai-workflow-research-success-clinical-reality-77c2">From Research Success to Clinical Reality</h4>
<p>The DR screening challenge initially appeared straightforward: develop an AI system to analyze retinal images and detect signs of diabetic retinopathy with accuracy comparable to expert ophthalmologists. Initial research results achieved expert-level performance in controlled laboratory conditions. However, the journey from research success to clinical impact revealed AI lifecycle complexity, where technical excellence must integrate with operational realities, regulatory requirements, and real-world deployment constraints.</p>
<p>The scale of this medical challenge explains why AI-assisted screening became medically essential, not merely technically interesting. Diabetic retinopathy affects over 100 million people worldwide and represents a leading cause of preventable blindness<a href="#fn8" class="footnote-ref" id="fnref8" role="doc-noteref"><sup>8</sup></a>. <a href="#fig-eye-dr" class="quarto-xref">Figure&nbsp;3</a> shows the clinical challenge: distinguishing healthy retinas from those showing early signs of retinopathy, such as the characteristic hemorrhages visible as dark red spots. While this appears to be a straightforward image classification problem, the path from laboratory success to clinical deployment illustrates every aspect of the AI lifecycle complexity.</p>
<div class="no-row-height column-margin column-container"><div id="fn8"><p><sup>8</sup>&nbsp;<strong>Diabetic Retinopathy Global Impact</strong>: Affects approximately 93-103 million people worldwide, with 22.27% to 35% of diabetic patients developing some form of retinopathy <span class="citation" data-cites="who2019classification">(<a href="#ref-who2019classification" role="doc-biblioref">Steinmetz et al. 2024</a>)</span>. In developing countries, up to 90% of vision loss from diabetes is preventable with early detection, but access to ophthalmologists remains severely limited: rural areas in India have approximately one ophthalmologist per 100,000-120,000 people, compared to the WHO recommendation of 1 per 20,000 <span class="citation" data-cites="who2019classification">(<a href="#ref-who2019classification" role="doc-biblioref">Steinmetz et al. 2024</a>)</span>. This stark disparity makes AI-assisted screening not just convenient but potentially life-changing for millions <span class="citation" data-cites="rajkomar2019machine">(<a href="#ref-rajkomar2019machine" role="doc-biblioref">Rajkomar, Dean, and Kohane 2019</a>)</span>.</p><div id="ref-who2019classification" class="csl-entry" role="listitem">
Steinmetz, Jaimie D, Katrin Maria Seeher, Nicoline Schiess, Emma Nichols, Bochen Cao, Chiara Servili, Vanessa Cavallera, et al. 2024. <span>“Global, Regional, and National Burden of Disorders Affecting the Nervous System, 1990–2021: A Systematic Analysis for the Global Burden of Disease Study 2021.”</span> <em>The Lancet Neurology</em> 23 (4): 344–81. <a href="https://doi.org/10.1016/s1474-4422(24)00038-3">https://doi.org/10.1016/s1474-4422(24)00038-3</a>.
</div></div></div><div id="fig-eye-dr" class="quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-eye-dr-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<a href="images/png/eye-dr.png" class="lightbox" data-gallery="quarto-lightbox-gallery-3" title="Figure&nbsp;3: Retinal Hemorrhages: Diabetic retinopathy causes visible hemorrhages in retinal images, providing a key visual indicator for model training and evaluation in medical image analysis. these images represent the input data used to develop algorithms that automatically detect and classify retinal diseases, ultimately assisting in early diagnosis and treatment. Source: Google."><img src="images/png/eye-dr.png" class="img-fluid figure-img" style="width:90.0%"></a>
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-eye-dr-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;3: <strong>Retinal Hemorrhages</strong>: Diabetic retinopathy causes visible hemorrhages in retinal images, providing a key visual indicator for model training and evaluation in medical image analysis. these images represent the input data used to develop algorithms that automatically detect and classify retinal diseases, ultimately assisting in early diagnosis and treatment. Source: Google.
</figcaption>
</figure>
</div>
</section>
<section id="sec-ai-workflow-systems-engineering-lessons-144a" class="level4 page-columns page-full">
<h4 class="anchored" data-anchor-id="sec-ai-workflow-systems-engineering-lessons-144a">Systems Engineering Lessons</h4>
<p>DR system development illustrates fundamental AI systems principles across lifecycle stages. Challenges with data quality lead to innovations in distributed data validation. Infrastructure constraints in rural clinics drive breakthroughs in edge computing<a href="#fn9" class="footnote-ref" id="fnref9" role="doc-noteref"><sup>9</sup></a> optimization. Integration with clinical workflows reveals the importance of human-AI collaboration design. These experiences demonstrate that building robust AI systems requires more than accurate models; success demands systematic engineering approaches that address real-world deployment complexity.</p>
<div class="no-row-height column-margin column-container"><div id="fn9"><p><sup>9</sup>&nbsp;<strong>Edge Computing</strong>: Distributed computing paradigm that processes data near the source rather than in centralized cloud data centers, reducing latency from 50-500ms (cloud) to 5-50ms (edge) depending on the application. Originally developed for CDNs (1990s), edge computing became essential for ML when real-time applications like autonomous vehicles and medical devices required sub-20ms response times that cloud computing couldn’t achieve <span class="citation" data-cites="shi2016edge">(<a href="#ref-shi2016edge" role="doc-biblioref">Shi et al. 2016</a>)</span>. The edge AI market grew from approximately $1.12B in 2018 to $8.2B in 2023, driven by IoT devices generating an estimated 73-80 zettabytes of data annually by 2025 that cannot be efficiently transmitted to cloud servers.</p><div id="ref-shi2016edge" class="csl-entry" role="listitem">
Shi, Weisong, Jie Cao, Quan Zhang, Youhuizi Li, and Lanyu Xu. 2016. <span>“Edge Computing: Vision and Challenges.”</span> <em>IEEE Internet of Things Journal</em> 3 (5): 637–46. <a href="https://doi.org/10.1109/jiot.2016.2579198">https://doi.org/10.1109/jiot.2016.2579198</a>.
</div></div><div id="fn10"><p><sup>10</sup>&nbsp;<strong>Healthcare AI Deployment Reality</strong>: Studies show that 75-80% of healthcare AI projects never reach clinical deployment <span class="citation" data-cites="chen2019machine">(<a href="#ref-chen2019machine" role="doc-biblioref">Chen and Asch 2017</a>)</span>, with the majority failing not due to algorithmic issues but due to integration challenges, regulatory hurdles, and workflow disruption. The “AI chasm” between research success and clinical adoption is particularly wide in healthcare: while medical AI papers show 95%+ accuracy rates, real-world implementation studies report significant performance drops due to data drift, equipment variations, and user acceptance issues <span class="citation" data-cites="kelly2019key">(<a href="#ref-kelly2019key" role="doc-biblioref">Kelly et al. 2019</a>)</span>.</p><div id="ref-chen2019machine" class="csl-entry" role="listitem">
Chen, Jonathan H., and Steven M. Asch. 2017. <span>“Machine Learning and Prediction in Medicine — Beyond the Peak of Inflated Expectations.”</span> <em>New England Journal of Medicine</em> 376 (26): 2507–9. <a href="https://doi.org/10.1056/nejmp1702071">https://doi.org/10.1056/nejmp1702071</a>.
</div><div id="ref-kelly2019key" class="csl-entry" role="listitem">
Kelly, Christopher J., Alan Karthikesalingam, Mustafa Suleyman, Greg Corrado, and Dominic King. 2019. <span>“Key Challenges for Delivering Clinical Impact with Artificial Intelligence.”</span> <em>BMC Medicine</em> 17 (1): 1–9. <a href="https://doi.org/10.1186/s12916-019-1426-2">https://doi.org/10.1186/s12916-019-1426-2</a>.
</div></div></div><p>This comprehensive journey through real-world deployment challenges reflects broader patterns in healthcare AI development. Throughout each lifecycle stage, the DR case study demonstrates how decisions made in early phases influence later stages, how feedback loops drive continuous improvement, and how emergent system behaviors require holistic solutions. These deployment challenges reflect broader issues in healthcare AI<a href="#fn10" class="footnote-ref" id="fnref10" role="doc-noteref"><sup>10</sup></a> that affect most real-world medical ML applications.</p>
<p>This narrative thread demonstrates how the AI lifecycle’s integrated nature requires systems thinking from the beginning. The DR case shows that sustainable AI systems emerge from understanding and designing for complex interactions between all lifecycle stages, rather than from optimizing individual components in isolation.</p>
<p>With this framework and case study established, examination of each lifecycle stage begins with problem definition.</p>
<div id="quiz-question-sec-ai-workflow-six-core-lifecycle-stages-fab9" class="callout callout-quiz-question">
<details class="callout-quiz-question fbx-default closebutton"><summary><strong>Self-Check: Question 1.4</strong></summary><div>
<ol type="1">
<li><p>Which of the following best describes the purpose of the ‘Problem Definition’ stage in the ML lifecycle?</p>
<ol type="a">
<li>To define objectives and constraints for the ML system.</li>
<li>To gather and clean data for model training.</li>
<li>To deploy the model into production environments.</li>
<li>To monitor the system’s performance post-deployment.</li>
</ol></li>
<li><p>Order the following ML lifecycle stages from start to finish: (1) Deployment &amp; Integration, (2) Model Development &amp; Training, (3) Data Collection &amp; Preparation, (4) Monitoring &amp; Maintenance.</p></li>
<li><p>How does the feedback loop in the ML lifecycle contribute to the system’s adaptability and improvement?</p></li>
<li><p>In the context of the DR screening system, which lifecycle stage likely involves ensuring model performance in real-world conditions?</p>
<ol type="a">
<li>Problem Definition</li>
<li>Data Collection &amp; Preparation</li>
<li>Evaluation &amp; Validation</li>
<li>Monitoring &amp; Maintenance</li>
</ol></li>
</ol>
<p><a href="#quiz-answer-sec-ai-workflow-six-core-lifecycle-stages-fab9" class="question-label">See Answers →</a></p>
</div></details>
</div>
</section>
</section>
</section>
<section id="sec-ai-workflow-problem-definition-stage-3e18" class="level2 page-columns page-full">
<h2 class="anchored" data-anchor-id="sec-ai-workflow-problem-definition-stage-3e18">Problem Definition Stage</h2>
<p>Machine learning system development begins with a challenge distinct from traditional software development: defining not just what the system should do, but how it should learn to do it. Conventional software requirements translate directly into implementation rules, while ML systems require teams to consider how the system will learn from data while operating within real-world constraints<a href="#fn11" class="footnote-ref" id="fnref11" role="doc-noteref"><sup>11</sup></a>. This first stage shown in <a href="#fig-lifecycle-overview" class="quarto-xref">Figure&nbsp;2</a> lays the foundation for all subsequent phases in the ML lifecycle.</p>
<div class="no-row-height column-margin column-container"><div id="fn11"><p><sup>11</sup>&nbsp;<strong>ML vs.&nbsp;Traditional Problem Definition</strong>: Traditional software problems are defined by deterministic specifications (“if input X, then output Y”), but ML problems are defined by examples and desired behaviors. This shift means that Studies suggest 60-80% of ML projects fail, with many failures occurring during problem formulation and requirements phases, compared to lower failure rates in traditional software projects <span class="citation" data-cites="standish2020chaos">(<a href="#ref-standish2020chaos" role="doc-biblioref">Maor 1987</a>)</span>. The challenge lies in translating business objectives into learning objectives—something that didn’t exist in software engineering until the rise of data-driven systems in the 2000s <span class="citation" data-cites="amershi2019software">(<a href="#ref-amershi2019software" role="doc-biblioref">Amershi et al. 2019</a>)</span>.</p><div id="ref-standish2020chaos" class="csl-entry" role="listitem">
Maor, Eli. 1987. <span>“CHAOS 2020: Beyond Infinity.”</span> In <em>To Infinity and Beyond</em>, 60–65. Birkhäuser Boston. <a href="https://doi.org/10.1007/978-1-4612-5394-5\_10">https://doi.org/10.1007/978-1-4612-5394-5\_10</a>.
</div><div id="ref-amershi2019software" class="csl-entry" role="listitem">
Amershi, Saleema, Andrew Begel, Christian Bird, Robert DeLine, Harald Gall, Ece Kamar, Nachiappan Nagappan, Besmira Nushi, and Thomas Zimmermann. 2019. <span>“Software Engineering for Machine Learning: A Case Study.”</span> In <em>2019 IEEE/ACM 41st International Conference on Software Engineering: Software Engineering in Practice (ICSE-SEIP)</em>, 291–300. IEEE. <a href="https://doi.org/10.1109/icse-seip.2019.00042">https://doi.org/10.1109/icse-seip.2019.00042</a>.
</div></div></div><p>The DR screening example illustrates how this complexity manifests in practice. A diabetic retinopathy screening system’s problem definition reveals complexity beneath an apparently straightforward medical imaging task. What initially appeared straightforward computer vision actually required defining multiple interconnected objectives that shaped every subsequent lifecycle stage.</p>
<p>Development teams balance competing constraints in such systems: diagnostic accuracy for patient safety, computational efficiency for rural clinic hardware, workflow integration for clinical adoption, regulatory compliance for medical device approval, and cost-effectiveness for sustainable deployment. Each constraint influences the others, creating a complex optimization problem that traditional software development approaches cannot address. This multi-dimensional problem definition drives data collection strategies, model architecture choices, and deployment infrastructure decisions throughout the project lifecycle.</p>
<section id="sec-ai-workflow-balancing-competing-constraints-0c62" class="level3">
<h3 class="anchored" data-anchor-id="sec-ai-workflow-balancing-competing-constraints-0c62">Balancing Competing Constraints</h3>
<p>Problem definition decisions cascade through system design. Requirements analysis in a DR screening system evolves from initial focus on diagnostic accuracy metrics to encompass deployment environment constraints and opportunities.</p>
<p>Achieving 90%+ sensitivity for detecting referable diabetic retinopathy prevents vision loss, while maintaining 80%+ specificity avoids overwhelming referral systems with false positives. These metrics must be achieved across diverse patient populations, camera equipment, and image quality conditions typical in resource-limited settings.</p>
<p>Rural clinic deployments impose strict constraints reflecting edge deployment challenges from <strong><a href="../ml_systems/ml_systems.html#sec-ml-systems">Chapter 2: ML Systems</a></strong>: models must run on devices with limited computational power, operate reliably with intermittent internet connectivity, and produce results within clinical workflow timeframes. These systems require operation by healthcare workers with minimal technical training.</p>
<p>Medical device regulations require extensive validation, audit trails, and performance monitoring capabilities that influence data collection, model development, and deployment strategies.</p>
<p>These interconnected requirements demonstrate how problem definition in ML systems requires understanding the complete ecosystem in which the system will operate. Early recognition of these constraints enables teams to make architecture decisions crucial for successful deployment, rather than discovering limitations after significant development investment.</p>
</section>
<section id="sec-ai-workflow-collaborative-problem-definition-process-a19c" class="level3">
<h3 class="anchored" data-anchor-id="sec-ai-workflow-collaborative-problem-definition-process-a19c">Collaborative Problem Definition Process</h3>
<p>Establishing clear and actionable problem definitions involves a systematic workflow that bridges technical, operational, and user considerations. The process begins with identifying the core objective of the system: what tasks it must perform and what constraints it must satisfy. Teams collaborate with stakeholders to gather domain knowledge, outline requirements, and anticipate challenges that may arise in real-world deployment.</p>
<p>In a DR-type project, this phase involves close collaboration with clinicians to determine the diagnostic needs of rural clinics. Key decisions, such as balancing model complexity with hardware limitations and ensuring interpretability for healthcare providers, emerge during this phase. The approach must account for regulatory considerations, such as patient privacy and compliance with healthcare standards. This collaborative process ensures that the problem definition aligns with both technical feasibility and clinical relevance.</p>
</section>
<section id="sec-ai-workflow-adapting-definitions-scale-b2ee" class="level3 page-columns page-full">
<h3 class="anchored" data-anchor-id="sec-ai-workflow-adapting-definitions-scale-b2ee">Adapting Definitions for Scale</h3>
<p>As ML systems scale, their problem definitions must adapt to new operational challenges<a href="#fn12" class="footnote-ref" id="fnref12" role="doc-noteref"><sup>12</sup></a>. A DR-type system might initially focus on a limited number of clinics with consistent imaging setups. However, as such a system expands to include clinics with varying equipment, staff expertise, and patient demographics<a href="#fn13" class="footnote-ref" id="fnref13" role="doc-noteref"><sup>13</sup></a>, the original problem definition requires adjustments to accommodate these variations.</p>
<div class="no-row-height column-margin column-container"><div id="fn12"><p><sup>12</sup>&nbsp;<strong>ML System Scaling Complexity</strong>: Scaling ML systems is exponentially more complex than traditional software due to data heterogeneity, model drift, and infrastructure requirements. Studies show that ML systems typically require 5-10x more monitoring infrastructure than traditional applications <span class="citation" data-cites="paleyes2022challenges">(<a href="#ref-paleyes2022challenges" role="doc-biblioref">Paleyes, Urma, and Lawrence 2022</a>)</span>, with companies like Uber running 1,000+ model quality checks daily across their ML platform <span class="citation" data-cites="uber2017michelangelo">(<a href="#ref-uber2017michelangelo" role="doc-biblioref">Hermann and Del Balso 2017</a>)</span>. The “scaling wall” typically hits at 100+ models in production, where manual processes break down and teams need specialized MLOps platforms—explaining why the ML platform market grew from approximately $1.5B in 2019 to $15.5B in 2023, with MLOps tools representing a significant subset <span class="citation" data-cites="kreuzberger2023machine">(<a href="#ref-kreuzberger2023machine" role="doc-biblioref">Kreuzberger, Kühl, and Hirschl 2023</a>)</span>.</p><div id="ref-kreuzberger2023machine" class="csl-entry" role="listitem">
Kreuzberger, Dominik, Niklas Kühl, and Sebastian Hirschl. 2023. <span>“Machine Learning Operations (MLOps): Overview, Definition, and Architecture.”</span> <em>IEEE Access</em> 11: 31866–79. <a href="https://doi.org/10.1109/access.2023.3262138">https://doi.org/10.1109/access.2023.3262138</a>.
</div></div><div id="fn13"><p><sup>13</sup>&nbsp;<strong>Algorithmic Fairness in Healthcare</strong>: Medical AI systems show significant performance disparities across demographic groups—dermatology AI systems show significant performance disparities, with some studies reporting 10-36% worse accuracy on darker skin tones depending on the specific condition and dataset <span class="citation" data-cites="larson2017gender">(<a href="#ref-larson2017gender" role="doc-biblioref">Chin-Purcell and Chambers 2021</a>)</span>, while diabetic retinopathy models trained primarily on European populations show 15-25% accuracy drops for Asian and African populations <span class="citation" data-cites="gulshan2016deep">(<a href="#ref-gulshan2016deep" role="doc-biblioref">Gulshan et al. 2016</a>)</span>. The FDA’s 2021 Action Plan for AI/ML-based medical devices now requires demographic performance reporting <span class="citation" data-cites="fda2021artificial">(<a href="#ref-fda2021artificial" role="doc-biblioref">Food and Administration 2021</a>)</span>, and companies like Google Health spend 20-30% of development resources on fairness testing and bias mitigation across racial, gender, and socioeconomic groups <span class="citation" data-cites="rajkomar2019machine">(<a href="#ref-rajkomar2019machine" role="doc-biblioref">Rajkomar, Dean, and Kohane 2019</a>)</span>.</p><div id="ref-larson2017gender" class="csl-entry" role="listitem">
Chin-Purcell, Lia, and America Chambers. 2021. <span>“Investigating Accuracy Disparities for Gender Classification Using Convolutional Neural Networks.”</span> In <em>2021 IEEE International Symposium on Technology and Society (ISTAS)</em>, 81:1–7. IEEE. <a href="https://doi.org/10.1109/istas52410.2021.9629153">https://doi.org/10.1109/istas52410.2021.9629153</a>.
</div><div id="ref-gulshan2016deep" class="csl-entry" role="listitem">
Gulshan, Varun, Lily Peng, Marc Coram, Martin C. Stumpe, Derek Wu, Arunachalam Narayanaswamy, Subhashini Venugopalan, et al. 2016. <span>“Development and Validation of a Deep Learning Algorithm for Detection of Diabetic Retinopathy in Retinal Fundus Photographs.”</span> <em>JAMA</em> 316 (22): 2402. <a href="https://doi.org/10.1001/jama.2016.17216">https://doi.org/10.1001/jama.2016.17216</a>.
</div><div id="ref-fda2021artificial" class="csl-entry" role="listitem">
Food, U. S., and Drug Administration. 2021. <span>“Artificial Intelligence/Machine Learning (AI/ML)-Based Software as a Medical Device (SaMD) Action Plan.”</span> U.S. Department of Health; Human Services. <a href="https://www.fda.gov/media/145022/download">https://www.fda.gov/media/145022/download</a>.
</div><div id="ref-rajkomar2019machine" class="csl-entry" role="listitem">
Rajkomar, Alvin, Jeffrey Dean, and Isaac Kohane. 2019. <span>“Machine Learning in Medicine.”</span> <em>New England Journal of Medicine</em> 380 (14): 1347–58. <a href="https://doi.org/10.1056/nejmra1814259">https://doi.org/10.1056/nejmra1814259</a>.
</div></div></div><p>Scaling also introduces data challenges. Larger datasets may include more diverse edge cases, which can expose weaknesses in the initial model design. Expanding deployment to new regions introduces variations in imaging equipment and patient populations that require further system tuning. Defining a problem that accommodates such diversity from the outset ensures the system can handle future expansion without requiring a complete redesign.</p>
<p>In our DR example, the problem definition process shapes data collection strategy. Requirements for multi-population validation drive the need for diverse training data, while edge deployment constraints influence data preprocessing approaches. Regulatory compliance needs determine annotation protocols and quality assurance standards. These interconnected requirements demonstrate how effective problem definition anticipates constraints that will emerge in subsequent lifecycle stages, establishing a foundation for integrated system development rather than sequential, isolated optimization.</p>
<p>With clear problem definition established, the development process transitions to assembling the data resources needed to achieve these objectives.</p>
<div id="quiz-question-sec-ai-workflow-problem-definition-stage-3e18" class="callout callout-quiz-question">
<details class="callout-quiz-question fbx-default closebutton"><summary><strong>Self-Check: Question 1.5</strong></summary><div>
<ol type="1">
<li><p>How does problem definition in machine learning differ from traditional software development?</p>
<ol type="a">
<li>It involves defining how the system should learn from data.</li>
<li>It focuses solely on deterministic specifications.</li>
<li>It requires no consideration of real-world constraints.</li>
<li>It is based on fixed input-output rules.</li>
</ol></li>
<li><p>Why is it crucial to align problem definition with real-world constraints in ML system development?</p></li>
<li><p>In ML systems, the process of translating business objectives into learning objectives is known as ____.</p></li>
<li><p>Which of the following best describes a key challenge in scaling ML systems?</p>
<ol type="a">
<li>Data homogeneity across all environments.</li>
<li>Consistent model performance without additional tuning.</li>
<li>Data heterogeneity and infrastructure requirements.</li>
<li>Simplified monitoring infrastructure compared to traditional applications.</li>
</ol></li>
<li><p>In a production system, how might problem definition influence the choice of deployment infrastructure?</p></li>
</ol>
<p><a href="#quiz-answer-sec-ai-workflow-problem-definition-stage-3e18" class="question-label">See Answers →</a></p>
</div></details>
</div>
</section>
</section>
<section id="sec-ai-workflow-data-collection-preparation-stage-a0aa" class="level2 page-columns page-full">
<h2 class="anchored" data-anchor-id="sec-ai-workflow-data-collection-preparation-stage-a0aa">Data Collection &amp; Preparation Stage</h2>
<p>Data collection and preparation represent the second stage in the ML lifecycle (<a href="#fig-lifecycle-overview" class="quarto-xref">Figure&nbsp;2</a>), where raw data is gathered, processed, and prepared for model development. This stage presents unique challenges extending beyond gathering sufficient training examples<a href="#fn14" class="footnote-ref" id="fnref14" role="doc-noteref"><sup>14</sup></a>. These challenges form the core focus of <strong><a href="../data_engineering/data_engineering.html#sec-data-engineering">Chapter 6: Data Engineering</a></strong>. For medical AI systems like DR screening, data collection must balance statistical rigor with operational feasibility while meeting the highest standards for diagnostic accuracy.</p>
<div class="no-row-height column-margin column-container"><div id="fn14"><p><sup>14</sup>&nbsp;<strong>The 80/20 Rule in ML</strong>: Data scientists typically spend 60-80% of their time on data collection, cleaning, and preparation, with the remainder on modeling and analysis. This ratio, first documented by CrowdFlower <span class="citation" data-cites="crowdflower2016data">(<a href="#ref-crowdflower2016data" role="doc-biblioref">CrowdFlower, n.d.</a>)</span> in 2016, remains consistent across industries despite advances in automated tools. The “data preparation tax” includes handling missing values (present in 90% of real-world datasets), resolving inconsistencies (affecting 60% of data fields), and ensuring legal compliance (requiring 15+ different consent mechanisms for EU data). This explains why successful ML teams invest heavily in data engineering capabilities from day one.</p><div id="ref-crowdflower2016data" class="csl-entry" role="listitem">
CrowdFlower. n.d. <span>“Supplemental Information 1: Source Code for Analysis in Matlab, Correlation Matrix, XML Code for Crowdflower Survey.”</span> <em>CrowdFlower Inc</em>. PeerJ. <a href="https://doi.org/10.7287/peerj.preprints.1069/supp-1">https://doi.org/10.7287/peerj.preprints.1069/supp-1</a>.
</div></div></div><p>Problem definition decisions shape data requirements in the DR example. The multi-dimensional success criteria established (accuracy across diverse populations, hardware efficiency, and regulatory compliance) demand a data collection strategy that goes beyond typical computer vision datasets.</p>
<p>Building this foundation in such a system might require assembling a development dataset of 128,000 retinal fundus photographs, each reviewed by 3-7 expert ophthalmologists from a panel of 54 specialists<a href="#fn15" class="footnote-ref" id="fnref15" role="doc-noteref"><sup>15</sup></a>. This expert consensus approach addresses the inherent subjectivity in medical diagnosis while establishing ground truth labels that can withstand regulatory scrutiny. The annotation process captures clinically relevant features like microaneurysms, hemorrhages, and hard exudates across the spectrum of disease severity.</p>
<div class="no-row-height column-margin column-container"><div id="fn15"><p><sup>15</sup>&nbsp;<strong>Medical Data Annotation Costs</strong>: Expert medical annotation is extraordinarily expensive: ophthalmologists charge $200-500 per hour, meaning the DR dataset’s annotation cost exceeded $2.7 million in expert time alone. This represents one of the highest annotation costs per sample in ML history, driving interest in active learning and synthetic data generation.</p></div></div><p>High-resolution retinal scans typically generate files ranging from 10-120 megabytes depending on resolution and compression, creating substantial infrastructure challenges. A typical clinic processing 50 patients daily generates 5-15 GB of imaging data per week depending on image quality and compression, quickly exceeding the capacity of rural internet connections (often limited to 2-10 Mbps upload speeds). This data volume constraint forces architectural decisions toward edge-computing solutions rather than cloud-based processing.</p>
<section id="sec-ai-workflow-bridging-laboratory-realworld-data-6ebf" class="level3 page-columns page-full">
<h3 class="anchored" data-anchor-id="sec-ai-workflow-bridging-laboratory-realworld-data-6ebf">Bridging Laboratory and Real-World Data</h3>
<p>Transitioning from laboratory-quality training data to real-world deployment reveals fundamental gaps when such a system moves to rural clinic settings.</p>
<p>When deployment begins in rural clinics across regions like Thailand and India, real-world data differs dramatically from carefully curated training sets. Images come from diverse camera equipment operated by staff with varying expertise levels, often under suboptimal lighting conditions and with inconsistent patient positioning. These variations threaten model performance and reveal the need for robust preprocessing and quality assurance systems.</p>
<p>This data volume constraint drives a fundamental architectural decision between the deployment paradigms discussed in <strong><a href="../ml_systems/ml_systems.html#sec-ml-systems">Chapter 2: ML Systems</a></strong>: edge computing deployment rather than cloud-based inference. Local preprocessing reduces bandwidth requirements by 95% (from 15 GB to 750 MB weekly transmission) but requires 10x more local computational resources, shaping both model optimization strategies and deployment hardware requirements using specialized edge devices like NVIDIA Jetson<a href="#fn16" class="footnote-ref" id="fnref16" role="doc-noteref"><sup>16</sup></a>.</p>
<div class="no-row-height column-margin column-container"><div id="fn16"><p><sup>16</sup>&nbsp;<strong>NVIDIA Jetson</strong>: Series of embedded computing boards designed for AI edge computing, featuring GPU acceleration in power-efficient form factors (5-30 watts vs.&nbsp;250+ watts for desktop GPUs). First released in 2014, Jetson modules enable real-time AI inference on devices like autonomous drones, medical equipment, and industrial robots. Popular models include Jetson Nano ($99, 472 GFLOPS), Jetson AGX Xavier ($699, 32 TOPS), and Jetson AGX Orin ($1,699, 275 TOPS), making high-performance AI accessible for edge deployment scenarios where cloud connectivity is unreliable or latency-critical.</p></div></div><p>A typical solution architecture emerges from data collection constraints: NVIDIA Jetson edge devices (2-32GB RAM, 64-2048 CUDA cores depending on model) for local inference, clinic aggregation servers (8-core CPUs, 32GB RAM) for data management, and cloud training infrastructure using 32-GPU clusters for weekly model updates. This distributed approach achieves sub-80ms inference latency with 94% uptime across deployments spanning 200+ clinic locations.</p>
<p>Patient privacy regulations require federated learning architecture, enabling model training without centralizing sensitive patient data. This approach adds complexity to both data collection workflows and model training infrastructure, but proves essential for regulatory approval and clinical adoption.</p>
<p>These experiences illustrate the constraint propagation principles we established earlier: lifecycle decisions in data collection create constraints and opportunities that propagate through the entire system development process, shaping everything from infrastructure design to model architecture.</p>
</section>
<section id="sec-ai-workflow-data-infrastructure-distributed-deployment-66ad" class="level3">
<h3 class="anchored" data-anchor-id="sec-ai-workflow-data-infrastructure-distributed-deployment-66ad">Data Infrastructure for Distributed Deployment</h3>
<p>Understanding how data characteristics and deployment constraints drive architectural decisions becomes critical at scale. Each retinal image follows a complex journey: capture on clinic cameras, local storage and initial processing, quality validation, secure transmission to central systems, and integration with training datasets.</p>
<p>Different data access patterns demand different storage solutions. Teams typically implement tiered approaches balancing cost, performance, and availability: frequently accessed training data requires high-speed storage for rapid model iteration, while historical datasets can tolerate slower access times in exchange for cost efficiency. Intelligent caching systems optimize data access based on usage patterns, ensuring that relevant data remains readily available.</p>
<p>Rural clinic deployments face significant connectivity constraints, requiring flexible data transmission strategies. Real-time transmission works well for clinics with reliable internet, while store-and-forward systems enable operation in areas with intermittent connectivity. This adaptive approach ensures consistent system operation regardless of local infrastructure limitations.</p>
<p>Infrastructure design must anticipate growth from pilot deployments to hundreds of clinics. The architecture accommodates varying data volumes, different hardware configurations, and diverse operational requirements while maintaining data consistency and system reliability. This scalability foundation proves essential as systems expand to new regions.</p>
</section>
<section id="sec-ai-workflow-managing-data-scale-61c3" class="level3 page-columns page-full">
<h3 class="anchored" data-anchor-id="sec-ai-workflow-managing-data-scale-61c3">Managing Data at Scale</h3>
<p>Applying systems thinking to scale, data collection challenges grow exponentially as ML systems expand. In our DR example, scaling from initial clinics to a broader network introduces emergent complexity: significant variability in equipment, workflows, and operating conditions. Each clinic effectively becomes an independent data node<a href="#fn17" class="footnote-ref" id="fnref17" role="doc-noteref"><sup>17</sup></a>, yet the system needs to ensure consistent performance across all locations. Following the collaborative coordination patterns established earlier, teams implement specialized orchestration with shared artifact repositories, versioned APIs, and automated testing pipelines that enable efficient management of large clinic networks.</p>
<div class="no-row-height column-margin column-container"><div id="fn17"><p><sup>17</sup>&nbsp;<strong>Federated Learning Architecture</strong>: Federated learning <span class="citation" data-cites="mcmahan2017communication">(<a href="#ref-mcmahan2017communication" role="doc-biblioref">McMahan et al. 2017</a>)</span>, introduced by Google in 2016 for mobile keyboards, enables training across distributed data sources without centralizing data. Healthcare applications are particularly suited for federated learning due to privacy regulations: studies show federated medical models achieve 85-95% of centralized model accuracy while keeping data local. However, federated learning introduces new challenges: communication costs increase 100-1000x per training iteration, and statistical heterogeneity across sites can cause model convergence issues that centralized training doesn’t face.</p><div id="ref-mcmahan2017communication" class="csl-entry" role="listitem">
McMahan, Brendan, Eider Moore, Daniel Ramage, Seth Hampson, and Blaise Agüera y Arcas. 2017. <span>“Communication-Efficient Learning of Deep Networks from Decentralized Data.”</span> In <em>Artificial Intelligence and Statistics</em>, 1273–82. PMLR. <a href="http://proceedings.mlr.press/v54/mcmahan17a.html">http://proceedings.mlr.press/v54/mcmahan17a.html</a>.
</div></div></div><p>Scaling such systems to additional clinics also brings increasing data volumes, as higher-resolution imaging devices become standard, generating larger and more detailed images. These advances amplify the demands on storage and processing infrastructure, requiring optimizations to maintain efficiency without compromising quality. Differences in patient demographics, clinic workflows, and connectivity patterns further underscore the need for robust design to handle these variations gracefully.</p>
<p>Scaling challenges highlight how decisions made during the data collection phase ripple through the lifecycle, impacting subsequent stages like model development, deployment, and monitoring. For instance, accommodating higher-resolution data during collection directly influences computational requirements for training and inference, emphasizing the need for lifecycle thinking even at this early stage.</p>
</section>
<section id="sec-ai-workflow-quality-assurance-validation-1bd4" class="level3">
<h3 class="anchored" data-anchor-id="sec-ai-workflow-quality-assurance-validation-1bd4">Quality Assurance and Validation</h3>
<p>Quality assurance is an integral part of the data collection process, ensuring that data meets the requirements for downstream stages. In our DR example, automated checks at the point of collection flag issues like poor focus or incorrect framing, allowing clinic staff to address problems immediately. These proactive measures ensure that low-quality data is not propagated through the pipeline.</p>
<p>Validation systems extend these efforts by verifying not just image quality but also proper labeling, patient association, and compliance with privacy regulations. Operating at both local and centralized levels, these systems ensure data reliability and robustness, safeguarding the integrity of the entire ML pipeline.</p>
<p>The data collection experiences in such systems directly inform model development approaches. The infrastructure constraints discovered during data collection (limited bandwidth, diverse hardware, intermittent connectivity) establish requirements for model efficiency that drive architectural decisions. The distributed federated learning approach required by privacy constraints influences training pipeline design. The quality variations observed across different clinic environments shape validation strategies and robustness requirements. This coupling between data collection insights and model development strategies exemplifies how integrated lifecycle planning trumps sequential stage optimization.</p>
<p><a href="#fig-ml-lifecycle-feedback" class="quarto-xref">Figure&nbsp;4</a> illustrates these critical feedback loops that enable continuous system improvement. The foundation established during data collection both enables and constrains the technical approaches available for creating effective models—a dynamic that becomes apparent as we now transition to model development.</p>
<div id="fig-ml-lifecycle-feedback" class="quarto-float quarto-figure quarto-figure-center anchored" data-fig-env="figure" data-fig-pos="htb">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-ml-lifecycle-feedback-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<a href="5d4c6dbc2d5c776a4c56979510d7852864221bd3.svg" class="lightbox" data-gallery="quarto-lightbox-gallery-4" title="Figure&nbsp;4: ML Lifecycle Dependencies: Iterative feedback loops connect data collection, preparation, model training, evaluation, and monitoring, emphasizing that each stage informs and influences subsequent stages in a continuous process. Effective machine learning system development requires acknowledging these dependencies to refine data, retrain models, and maintain performance over time."><img src="workflow_files/mediabag/5d4c6dbc2d5c776a4c56979510d7852864221bd3.svg" class="img-fluid figure-img"></a>
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-ml-lifecycle-feedback-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;4: <strong>ML Lifecycle Dependencies</strong>: Iterative feedback loops connect data collection, preparation, model training, evaluation, and monitoring, emphasizing that each stage informs and influences subsequent stages in a continuous process. Effective machine learning system development requires acknowledging these dependencies to refine data, retrain models, and maintain performance over time.
</figcaption>
</figure>
</div>
<div id="quiz-question-sec-ai-workflow-data-collection-preparation-stage-a0aa" class="callout callout-quiz-question">
<details class="callout-quiz-question fbx-default closebutton"><summary><strong>Self-Check: Question 1.6</strong></summary><div>
<ol type="1">
<li><p>Which of the following best describes a major challenge in data collection for medical AI systems like diabetic retinopathy screening?</p>
<ol type="a">
<li>Ensuring high-resolution images are captured consistently.</li>
<li>Reducing the cost of expert annotation.</li>
<li>Balancing statistical rigor with operational feasibility.</li>
<li>Maximizing the number of images collected daily.</li>
</ol></li>
<li><p>How does the data volume constraint in rural clinics influence architectural decisions in ML systems?</p></li>
<li><p>Order the following steps involved in the data collection process for a medical AI system: (1) Initial processing and storage, (2) Data capture, (3) Quality validation, (4) Secure transmission.</p></li>
<li><p>What is a key reason for using federated learning in the data collection strategy for medical AI systems?</p>
<ol type="a">
<li>To improve model accuracy by centralizing data.</li>
<li>To comply with patient privacy regulations.</li>
<li>To reduce the cost of data annotation.</li>
<li>To increase the speed of data processing.</li>
</ol></li>
</ol>
<p><a href="#quiz-answer-sec-ai-workflow-data-collection-preparation-stage-a0aa" class="question-label">See Answers →</a></p>
</div></details>
</div>
</section>
</section>
<section id="sec-ai-workflow-model-development-training-stage-05ec" class="level2 page-columns page-full">
<h2 class="anchored" data-anchor-id="sec-ai-workflow-model-development-training-stage-05ec">Model Development &amp; Training Stage</h2>
<p>Model development and training (the third stage in <a href="#fig-lifecycle-overview" class="quarto-xref">Figure&nbsp;2</a>) form the core of machine learning systems, yet this stage presents unique challenges extending beyond selecting algorithms and tuning hyperparameters<a href="#fn18" class="footnote-ref" id="fnref18" role="doc-noteref"><sup>18</sup></a>. The training methodologies, infrastructure requirements, and distributed training strategies are covered in <strong><a href="../training/training.html#sec-ai-training">Chapter 8: AI Training</a></strong>. In high-stakes domains like healthcare, every design decision impacts clinical outcomes, making the integration of technical performance with operational constraints critical.</p>
<div class="no-row-height column-margin column-container"><div id="fn18"><p><sup>18</sup>&nbsp;<strong>Hyperparameter Optimization Complexity</strong>: Modern deep learning models have 10-100+ hyperparameters (learning rate, batch size, architecture choices), creating search spaces with 10^20+ possible combinations. AutoML platforms like Google’s AutoML and H2O spend $10,000-100,000 in compute costs to find optimal configurations for complex models. Random search (2012) surprisingly outperforms grid search, while Bayesian optimization (2010s) and population-based training (2017) represent current state-of-the-art, reducing tuning time by 10-100x but still requiring substantial computational resources that didn’t exist in traditional software development.</p></div></div><p>Early lifecycle decisions cascade through model development in our DR example. The problem definition requirements established (expert-level accuracy combined with edge device compatibility) create an optimization challenge that demands innovative approaches to both model architecture and training strategies.</p>
<p>Using transfer learning from ImageNet<a href="#fn19" class="footnote-ref" id="fnref19" role="doc-noteref"><sup>19</sup></a> combined with a meticulously labeled dataset of 128,000 images, developers in such projects achieve F-scores<a href="#fn20" class="footnote-ref" id="fnref20" role="doc-noteref"><sup>20</sup></a> of 0.91-0.95, comparable to or exceeding ophthalmologist performance in controlled settings. This result validates approaches that combine large-scale pre-training with domain-specific fine-tuning—a training strategy leveraging the gradient-based optimization principles from <strong><a href="../dl_primer/dl_primer.html#sec-dl-primer">Chapter 3: Deep Learning Primer</a></strong> to adapt pre-trained convolutional architectures from <strong><a href="../dnn_architectures/dnn_architectures.html#sec-dnn-architectures">Chapter 4: DNN Architectures</a></strong> for medical imaging.</p>
<div class="no-row-height column-margin column-container"><div id="fn19"><p><sup>19</sup>&nbsp;<strong>Transfer Learning</strong>: A technique where models pre-trained on large datasets (like ImageNet’s 14 million images) are adapted for specific tasks, dramatically reducing training time and data requirements <span class="citation" data-cites="krizhevsky2012imagenet deng2009imagenet">(<a href="#ref-krizhevsky2012imagenet" role="doc-biblioref">Krizhevsky, Sutskever, and Hinton 2017</a>; <a href="#ref-deng2009imagenet" role="doc-biblioref">Deng et al. 2009</a>)</span>. Introduced by Yann LeCun’s team in the 1990s and popularized by the 2014 ImageNet competition, transfer learning became the foundation for most practical computer vision applications. Instead of training from scratch, practitioners can achieve expert-level performance with thousands rather than millions of training examples.</p><div id="ref-krizhevsky2012imagenet" class="csl-entry" role="listitem">
Krizhevsky, Alex, Ilya Sutskever, and Geoffrey E. Hinton. 2017. <span>“ImageNet Classification with Deep Convolutional Neural Networks.”</span> <em>Communications of the ACM</em> 60 (6): 84–90. <a href="https://doi.org/10.1145/3065386">https://doi.org/10.1145/3065386</a>.
</div><div id="ref-deng2009imagenet" class="csl-entry" role="listitem">
Deng, Jia, Wei Dong, Richard Socher, Li-Jia Li, Kai Li, and Li Fei-Fei. 2009. <span>“ImageNet: A Large-Scale Hierarchical Image Database.”</span> In <em>2009 IEEE Conference on Computer Vision and Pattern Recognition</em>, 248–55. IEEE; IEEE. <a href="https://doi.org/10.1109/cvpr.2009.5206848">https://doi.org/10.1109/cvpr.2009.5206848</a>.
</div></div><div id="fn20"><p><sup>20</sup>&nbsp;<strong>F-Score (F1 Score)</strong>: The harmonic mean of precision and recall, calculated as 2 × (precision × recall) / (precision + recall), providing a single metric that balances both measures. Values range from 0 (worst) to 1 (perfect). Introduced in information retrieval (1979), F-score became essential for ML evaluation because accuracy alone can be misleading with imbalanced datasets—a model predicting “no disease” for all patients might achieve 95% accuracy in a population where only 5% have the condition, but would have an F-score near 0, revealing its clinical uselessness.</p></div><div id="fn21"><p><sup>21</sup>&nbsp;<strong>Ensemble Learning</strong>: A technique that combines predictions from multiple models to achieve better performance than any individual model. Common methods include bagging (training multiple models on different data subsets), boosting (sequentially training models to correct previous errors), and stacking (using a meta-model to combine base model predictions). Netflix’s recommendation system uses ensembles of 100+ algorithms, while winning entries in ML competitions typically ensemble 10-50 models. However, ensembles trade inference speed and memory usage for accuracy—a critical constraint in edge deployment scenarios.</p></div></div><p>Achieving high accuracy is only the first challenge. Data collection insights about edge deployment constraints impose strict efficiency requirements: models must operate under 98MB in size, achieve sub-50ms inference latency, and consume under 400MB RAM during operation. The initial research model (a 2.1GB ensemble<a href="#fn21" class="footnote-ref" id="fnref21" role="doc-noteref"><sup>21</sup></a> achieving 95.2% accuracy) violates all deployment constraints, requiring systematic optimization to reach a final 96MB model maintaining 94.8% accuracy while meeting all operational requirements.</p>
<p>These constraints drive architectural innovations including model optimization techniques for size reduction, inference acceleration, and efficient deployment scenarios—balancing the computational demands of deep convolutional networks from <strong><a href="../dnn_architectures/dnn_architectures.html#sec-dnn-architectures">Chapter 4: DNN Architectures</a></strong> with the resource limitations of edge devices detailed in <strong><a href="../ml_systems/ml_systems.html#sec-ml-systems">Chapter 2: ML Systems</a></strong>.</p>
<p>Following the iterative development framework established, the model development process requires continuous iteration between accuracy optimization and efficiency optimization. Each architectural decision (from the number of convolutional layers to the choice of activation functions covered in <strong><a href="../dl_primer/dl_primer.html#sec-dl-primer">Chapter 3: Deep Learning Primer</a></strong> to the overall network depth explored in <strong><a href="../dnn_architectures/dnn_architectures.html#sec-dnn-architectures">Chapter 4: DNN Architectures</a></strong>) must be validated against test set metrics and the infrastructure constraints identified during data collection. This multi-objective optimization approach exemplifies the interdependence principle where deployment constraints shape development decisions.</p>
<section id="sec-ai-workflow-balancing-performance-deployment-constraints-6488" class="level3 page-columns page-full">
<h3 class="anchored" data-anchor-id="sec-ai-workflow-balancing-performance-deployment-constraints-6488">Balancing Performance and Deployment Constraints</h3>
<p>The model development experiences in our DR example illustrate fundamental trade-offs between clinical effectiveness and deployment feasibility that characterize real-world AI systems.</p>
<p>Medical applications demand specific performance metrics<a href="#fn22" class="footnote-ref" id="fnref22" role="doc-noteref"><sup>22</sup></a> that differ significantly from the standard classification metrics introduced in <strong><a href="../dl_primer/dl_primer.html#sec-dl-primer">Chapter 3: Deep Learning Primer</a></strong>. A DR system requires &gt;90% sensitivity (to prevent vision loss from missed cases) and &gt;80% specificity (to avoid overwhelming referral systems). These metrics must be maintained across diverse patient populations and image quality conditions.</p>
<div class="no-row-height column-margin column-container"><div id="fn22"><p><sup>22</sup>&nbsp;<strong>Medical AI Performance Metrics</strong>: Medical AI requires different metrics than general ML: sensitivity (true positive rate) and specificity (true negative rate) are often more important than overall accuracy. For diabetic retinopathy screening, &gt;90% sensitivity is crucial (missing cases causes blindness), while &gt;80% specificity prevents unnecessary referrals. Medical AI also requires metrics like positive predictive value (PPV) and negative predictive value (NPV) that vary with disease prevalence in different populations—a model with 95% accuracy in a lab setting might have only 50% PPV in a low-prevalence population, making it clinically useless despite high technical performance.</p></div><div id="fn23"><p><sup>23</sup>&nbsp;<strong>Model Compression Techniques</strong>: Methods to reduce model size and computational requirements while preserving accuracy. <strong>Quantization</strong> reduces numerical precision from 32-bit floats to 8-bit integers, achieving 4x size reduction with minimal accuracy loss. <strong>Pruning</strong> removes unnecessary connections or entire neurons, potentially reducing parameters by 90-95%. <strong>Knowledge distillation</strong> trains a smaller “student” model to mimic a larger “teacher” model’s behavior, transferring learned knowledge to a more efficient architecture. These techniques, detailed in <strong><a href="../optimizations/optimizations.html#sec-model-optimizations">Chapter 10: Model Optimizations</a></strong>, are essential for edge deployment where memory and compute are severely constrained.</p></div></div><p>Optimizing for clinical performance alone proves insufficient. Edge deployment constraints from the data collection phase impose additional requirements: the model must run efficiently on resource-limited hardware while maintaining real-time inference speeds compatible with clinical workflows. This creates a multi-objective optimization problem where improvements in one dimension often come at the cost of others, a fundamental tension between model capacity (explored in <strong><a href="../dnn_architectures/dnn_architectures.html#sec-dnn-architectures">Chapter 4: DNN Architectures</a></strong>) and deployment feasibility (discussed in <strong><a href="../ml_systems/ml_systems.html#sec-ml-systems">Chapter 2: ML Systems</a></strong>). Teams discover that an original 2GB model with 95.2% accuracy can be optimized to 96MB with 94.8% accuracy through systematic application of quantization, pruning, and knowledge distillation<a href="#fn23" class="footnote-ref" id="fnref23" role="doc-noteref"><sup>23</sup></a> techniques, achieving deployment requirements while maintaining clinical utility.</p>
<p>The choice to use an ensemble of lightweight models rather than a single large model exemplifies how model development decisions propagate through the system lifecycle. This architectural decision reduces individual model complexity (enabling edge deployment) but increases inference pipeline complexity (affecting deployment and monitoring strategies). Teams must develop orchestration logic for model ensembles and create monitoring systems that can track performance across multiple model components.</p>
<p>These model development experiences reinforce the lifecycle integration principles we established earlier. Architecture decisions—from choosing CNN architectures for spatial feature extraction (<strong><a href="../dnn_architectures/dnn_architectures.html#sec-dnn-architectures">Chapter 4: DNN Architectures</a></strong>) to configuring training hyperparameters (<strong><a href="../dl_primer/dl_primer.html#sec-dl-primer">Chapter 3: Deep Learning Primer</a></strong>)—influence data preprocessing pipelines, training infrastructure requirements, and deployment strategies. This demonstrates how successful model development requires anticipating constraints from subsequent lifecycle stages rather than optimizing models in isolation, reflecting our systems thinking approach.</p>
</section>
<section id="sec-ai-workflow-constraintdriven-development-process-a8f3" class="level3 page-columns page-full">
<h3 class="anchored" data-anchor-id="sec-ai-workflow-constraintdriven-development-process-a8f3">Constraint-Driven Development Process</h3>
<p>Real-world constraints shape the entire model development process from initial exploration through final optimization, demanding systematic approaches to experimentation.</p>
<p>Development begins with collaboration between data scientists and domain experts (like ophthalmologists in medical imaging) to identify characteristics indicative of the target conditions. This interdisciplinary approach ensures that model architectures capture clinically relevant features while meeting the computational constraints identified during data collection.</p>
<p>Computational constraints profoundly shape experimental approaches. Production ML workflows create multiplicative costs: 10 model variants × 5 hyperparameter sweeps (exploring learning rates from 1e-4 to 1e-2, batch sizes from 16 to 128, and optimization algorithms from <strong><a href="../dl_primer/dl_primer.html#sec-dl-primer">Chapter 3: Deep Learning Primer</a></strong>) × 3 preprocessing approaches (raw images, histogram equalization, adaptive filtering) = 150 training runs. At approximately $500-2000 per training run depending on hardware and duration, iteration costs can reach $150K per experiment cycle. This economic reality drives innovations in efficient experimentation: intelligent job scheduling reducing idle GPU time by 60%, caching of intermediate results saving 30% of preprocessing time, early stopping techniques terminating unpromising experiments after 20% completion, and automated resource optimization achieving 2.3x cost efficiency.</p>
<p>ML model development exhibits emergent behaviors that make outcomes inherently uncertain, demanding scientific methodology principles: controlled variables through fixed random seeds and environment versions, systematic ablation studies<a href="#fn24" class="footnote-ref" id="fnref24" role="doc-noteref"><sup>24</sup></a> to isolate component contributions, confounding factor analysis to separate architecture effects from optimization effects, and statistical significance testing across multiple runs using A/B testing<a href="#fn25" class="footnote-ref" id="fnref25" role="doc-noteref"><sup>25</sup></a> frameworks. This approach proves essential for distinguishing genuine performance improvements from statistical noise.</p>
<div class="no-row-height column-margin column-container"><div id="fn24"><p><sup>24</sup>&nbsp;<strong>Ablation Studies</strong>: Systematic experiments that remove or modify individual components to understand their contribution to overall performance. In ML, ablation studies might remove specific layers, change activation functions, or exclude data augmentation techniques to isolate their effects. Named after medical ablation (surgical removal of tissue), this method became standard in ML research after the 2012 AlexNet paper used ablation to validate each architectural choice. Ablation studies are essential for complex models where component interactions make it difficult to determine which design decisions actually improve performance.</p></div><div id="fn25"><p><sup>25</sup>&nbsp;<strong>A/B Testing in ML</strong>: Statistical method for comparing two model versions by randomly assigning users to different groups and measuring performance differences. Originally developed for web optimization (2000s), A/B testing became crucial for ML deployment because models can perform differently in production than in development. Companies like Netflix run hundreds of concurrent experiments with users participating in multiple tests simultaneously, while Uber tests 100+ ML model improvements weekly <span class="citation" data-cites="uber2017michelangelo">(<a href="#ref-uber2017michelangelo" role="doc-biblioref">Hermann and Del Balso 2017</a>)</span>. A/B testing requires careful statistical design to avoid confounding variables and ensure sufficient sample sizes for reliable conclusions.</p></div></div><p>Throughout development, teams validate models against deployment constraints identified in earlier lifecycle stages. Each architectural innovation must be evaluated for accuracy improvements and compatibility with edge device limitations and clinical workflow requirements. This dual validation approach ensures that development efforts align with deployment goals rather than optimizing for laboratory conditions that don’t translate to real-world performance.</p>
</section>
<section id="sec-ai-workflow-prototype-productionscale-development-104e" class="level3 page-columns page-full">
<h3 class="anchored" data-anchor-id="sec-ai-workflow-prototype-productionscale-development-104e">From Prototype to Production-Scale Development</h3>
<p>As projects like our DR example evolve from prototype to production systems, teams encounter emergent complexity across multiple dimensions: larger datasets, more sophisticated models, concurrent experiments, and distributed training infrastructure. These scaling challenges illustrate systems thinking principles that apply broadly to large-scale AI system development.</p>
<p>Moving from single-machine training to distributed systems introduces coordination requirements that demand balancing training speed improvements against increased system complexity. This leads to implementing fault tolerance mechanisms and automated failure recovery systems. Orchestration frameworks enable component-based pipeline construction with reusable stages, automatic resource scaling, and monitoring across distributed components.</p>
<p>Systematic tracking becomes critical as experiments generate artifacts<a href="#fn26" class="footnote-ref" id="fnref26" role="doc-noteref"><sup>26</sup></a> including model checkpoints, training logs, and performance metrics. Without structured organization, teams risk losing institutional knowledge from their experimentation efforts. Addressing this requires implementing systematic experiment identification, automated artifact versioning, and search capabilities to query experiments by performance characteristics and configuration parameters.</p>
<div class="no-row-height column-margin column-container"><div id="fn26"><p><sup>26</sup>&nbsp;<strong>ML Artifacts</strong>: All digital outputs generated during ML development: trained models, datasets, preprocessing code, hyperparameter configurations, training logs, evaluation metrics, and documentation. Unlike traditional software artifacts (compiled binaries, documentation), ML artifacts are interdependent—model performance depends on specific data versions, preprocessing steps, and hyperparameter settings. Managing ML artifacts requires specialized tools like MLflow, Neptune, or Weights &amp; Biases that track lineage between artifacts, enable reproducibility, and support comparison across experiments. A typical ML project generates 10-100x more artifacts than equivalent traditional software projects.</p></div></div><p>Large-scale model development demands resource allocation between training computation and supporting infrastructure. While effective experiment management requires computational overhead, this investment pays dividends in accelerated development cycles and improved model quality through systematic performance analysis and optimization.</p>
<p>The model development process establishes both capabilities and constraints that directly influence the next lifecycle stage. Edge-optimized ensemble architectures enable clinic deployment but require sophisticated serving infrastructure. Regulatory validation requirements shape deployment validation protocols. These interconnected requirements demonstrate how development decisions create the foundation and limitations for deployment approaches.</p>
<p>These model development achievements ultimately create new challenges for the deployment stage. An optimized ensemble architecture that meets edge device constraints still requires sophisticated serving infrastructure. The distributed training approach that enables rapid iteration demands model versioning and synchronization across clinic deployments. The regulatory validation requirements that guide model development inform deployment validation and monitoring strategies. These interconnections demonstrate how successful model development must anticipate deployment challenges, ensuring that technical innovations can be translated into operational systems that deliver value.</p>
<div id="quiz-question-sec-ai-workflow-model-development-training-stage-05ec" class="callout callout-quiz-question">
<details class="callout-quiz-question fbx-default closebutton"><summary><strong>Self-Check: Question 1.7</strong></summary><div>
<ol type="1">
<li><p>Which of the following best describes the trade-off between model accuracy and deployment feasibility in the context of edge devices?</p>
<ol type="a">
<li>Increasing model accuracy always improves deployment feasibility.</li>
<li>Model accuracy and deployment feasibility are unrelated aspects of model development.</li>
<li>Deployment feasibility is independent of model accuracy.</li>
<li>Higher model accuracy often requires more computational resources, which can hinder deployment on edge devices.</li>
</ol></li>
<li><p>Explain how model compression techniques like quantization and pruning help in meeting deployment constraints for edge devices.</p></li>
<li><p>The process of training a smaller model to mimic the behavior of a larger model is known as ____. This technique helps in reducing model size while maintaining accuracy.</p></li>
<li><p>Order the following steps in optimizing a model for edge deployment: (1) Initial model training, (2) Model compression, (3) Performance evaluation, (4) Deployment testing.</p></li>
<li><p>In a production system, how might the choice of model architecture impact the system’s operational constraints?</p></li>
</ol>
<p><a href="#quiz-answer-sec-ai-workflow-model-development-training-stage-05ec" class="question-label">See Answers →</a></p>
</div></details>
</div>
</section>
</section>
<section id="sec-ai-workflow-deployment-integration-stage-7f90" class="level2">
<h2 class="anchored" data-anchor-id="sec-ai-workflow-deployment-integration-stage-7f90">Deployment &amp; Integration Stage</h2>
<p>At the deployment and integration stage (the fifth stage in <a href="#fig-lifecycle-overview" class="quarto-xref">Figure&nbsp;2</a>), the trained model is integrated into production systems and workflows. Deployment requires addressing practical challenges such as system compatibility, scalability, and operational constraints. Successful integration ensures that the model’s predictions are accurate and actionable in real-world settings, where resource limitations and workflow disruptions can pose barriers. The operational aspects of deployment and maintenance are covered in <strong><a href="../ops/ops.html#sec-ml-operations">Chapter 13: ML Operations</a></strong>.</p>
<p>In our DR example, deployment strategies are shaped by the diverse environments we identified earlier. Edge deployment enables local processing of retinal images in rural clinics with intermittent connectivity, while automated quality checks flag poor-quality images for recapture, ensuring reliable predictions. These measures demonstrate how deployment must bridge technological sophistication with usability and scalability across clinical settings.</p>
<section id="sec-ai-workflow-technical-operational-requirements-7574" class="level3">
<h3 class="anchored" data-anchor-id="sec-ai-workflow-technical-operational-requirements-7574">Technical and Operational Requirements</h3>
<p>The requirements for deployment stem from both the technical specifications of the model and the operational constraints of its intended environment. In our DR-type system, the model must operate in rural clinics with limited computational resources and intermittent internet connectivity. It must fit into the existing clinical workflow, requiring rapid, interpretable results that assist healthcare providers without causing disruption.</p>
<p>These requirements influence deployment strategies. A cloud-based deployment, while technically simpler, may not be feasible due to unreliable connectivity in many clinics. Instead, teams often opt for edge deployment, where models run locally on clinic hardware. This approach requires model optimization to meet specific hardware constraints: target metrics might include under 98MB model size, sub-50ms inference latency, and under 400MB RAM usage on edge devices. Achieving these targets requires systematic application of optimization techniques that reduce model size and computational requirements while balancing accuracy trade-offs.</p>
<p>Integration with existing systems poses additional challenges. The ML system must interface with hospital information systems (HIS) for accessing patient records and storing results. Privacy regulations mandate secure data handling at every step, shaping deployment decisions. These considerations ensure that the system adheres to clinical and legal standards while remaining practical for daily use.</p>
</section>
<section id="sec-ai-workflow-phased-rollout-integration-process-0a43" class="level3">
<h3 class="anchored" data-anchor-id="sec-ai-workflow-phased-rollout-integration-process-0a43">Phased Rollout and Integration Process</h3>
<p>The deployment and integration workflow in our DR example highlights the complex interplay between model functionality, infrastructure, and user experience. The process begins with thorough testing in simulated environments that replicate the technical constraints and workflows of the target clinics. These simulations help identify potential bottlenecks and incompatibilities early, allowing teams to refine the deployment strategy before full-scale rollout.</p>
<p>Once the deployment strategy is finalized, teams typically implement a phased rollout. Initial deployments are limited to a few pilot sites, allowing for controlled testing in real-world conditions. This approach provides valuable feedback from clinicians and technical staff, helping to identify issues that didn’t surface during simulations.</p>
<p>Integration efforts focus on ensuring seamless interaction between the ML system and existing tools. For example, such a DR system must pull patient information from the HIS, process retinal images from connected cameras, and return results in a format that clinicians can easily interpret. These tasks require the development of robust APIs, real-time data processing pipelines, and user-friendly interfaces tailored to the needs of healthcare providers.</p>
</section>
<section id="sec-ai-workflow-multisite-deployment-challenges-283d" class="level3">
<h3 class="anchored" data-anchor-id="sec-ai-workflow-multisite-deployment-challenges-283d">Multi-Site Deployment Challenges</h3>
<p>Deploying our DR-type system across multiple clinic locations reveals the fundamental challenges of scaling AI systems beyond controlled laboratory environments. Each clinic presents unique constraints: different imaging equipment, varying network reliability, diverse operator expertise levels, and distinct workflow patterns.</p>
<p>The transition from development to deployment exposes significant performance challenges. Variations in imaging equipment and operator expertise create data quality inconsistencies that models can struggle to handle. Infrastructure constraints can force emergency model optimizations, demonstrating how deployment realities propagate backwards through the development process, influencing preprocessing strategies, architecture decisions, and validation approaches.</p>
<p>Teams discover that deployment architecture decisions create cascading effects throughout the system. Edge deployment minimizes latency for real-time clinical workflows but imposes strict constraints on model complexity. Cloud deployment enables model flexibility but can introduce latency that proves unacceptable for time-sensitive medical applications.</p>
<p>Successful deployment requires more than technical optimization. Clinician feedback often reveals that initial system interfaces need significant redesign to achieve widespread adoption. Teams must balance technical sophistication with clinical usability, recognizing that user trust and proficiency are as critical as algorithmic performance.</p>
<p>Managing improvements across distributed deployments requires sophisticated coordination mechanisms. Centralized version control systems and automated update pipelines ensure that performance improvements reach all deployment sites while minimizing disruption to clinical operations. As illustrated in <a href="#fig-ml-lifecycle-feedback" class="quarto-xref">Figure&nbsp;4</a>, deployment challenges create multiple feedback paths that drive continuous system improvement.</p>
</section>
<section id="sec-ai-workflow-ensuring-clinicalgrade-reliability-bff5" class="level3">
<h3 class="anchored" data-anchor-id="sec-ai-workflow-ensuring-clinicalgrade-reliability-bff5">Ensuring Clinical-Grade Reliability</h3>
<p>In a clinical context, reliability is paramount. DR-type systems need to function seamlessly under a wide range of conditions, from high patient volumes to suboptimal imaging setups. To ensure robustness, teams implement fail-safes that can detect and handle common issues, such as incomplete or poor-quality data. These mechanisms include automated image quality checks and fallback workflows for cases where the system encounters errors.</p>
<p>Testing plays a central role in ensuring reliability. Teams conduct extensive stress testing to simulate peak usage scenarios, validating that the system can handle high throughput without degradation in performance. Redundancy is built into critical components to minimize the risk of downtime, and all interactions with external systems, such as the HIS, are rigorously tested for compatibility and security.</p>
<p>Deployment experiences in such systems reveal how this stage transitions from development-focused activities to operation-focused concerns. Real-world deployment feedback (from clinician usability concerns to hardware performance issues) generates insights that inform the final lifecycle stage: ongoing monitoring and maintenance strategies. The distributed edge deployment architecture creates new requirements for system-wide monitoring and coordinated updates. The integration challenges with hospital information systems establish protocols for managing system evolution without disrupting clinical workflows.</p>
<p>Successful deployment establishes the foundation for effective monitoring and maintenance, creating the operational infrastructure and feedback mechanisms that enable continuous improvement. The deployment experience demonstrates that this stage is not an endpoint but a transition into the continuous operations phase that exemplifies our systems thinking approach.</p>
<div id="quiz-question-sec-ai-workflow-deployment-integration-stage-7f90" class="callout callout-quiz-question">
<details class="callout-quiz-question fbx-default closebutton"><summary><strong>Self-Check: Question 1.8</strong></summary><div>
<ol type="1">
<li><p>Which of the following is a primary reason for choosing edge deployment over cloud deployment in rural clinics?</p>
<ol type="a">
<li>To increase model complexity</li>
<li>To leverage cloud computing resources</li>
<li>To reduce latency and ensure reliability despite intermittent connectivity</li>
<li>To simplify the deployment process</li>
</ol></li>
<li><p>Explain how deployment requirements in rural clinics influence the choice of model optimization techniques.</p></li>
<li><p>Order the following steps in the deployment workflow: (1) Pilot site rollout, (2) Simulated environment testing, (3) Full-scale rollout.</p></li>
<li><p>What is a key challenge when integrating an ML system with existing hospital information systems (HIS)?</p>
<ol type="a">
<li>Maintaining secure data handling and compatibility</li>
<li>Ensuring the model is interpretable</li>
<li>Increasing the model’s accuracy</li>
<li>Reducing the model’s training time</li>
</ol></li>
</ol>
<p><a href="#quiz-answer-sec-ai-workflow-deployment-integration-stage-7f90" class="question-label">See Answers →</a></p>
</div></details>
</div>
</section>
</section>
<section id="sec-ai-workflow-monitoring-maintenance-stage-c6f7" class="level2 page-columns page-full">
<h2 class="anchored" data-anchor-id="sec-ai-workflow-monitoring-maintenance-stage-c6f7">Monitoring &amp; Maintenance Stage</h2>
<p>Once AI systems transition from deployment to production operation, they enter a fundamentally different operational phase than traditional software systems. As <a href="#fig-lifecycle-overview" class="quarto-xref">Figure&nbsp;2</a> illustrates with the feedback loop returning from the final stage back to data collection, monitoring and maintenance create the continuous cycle that keeps systems performing reliably. Conventional applications maintain static behavior until explicitly updated, while ML systems must account for evolving data distributions, changing usage patterns, and model performance drift.</p>
<p>Monitoring and maintenance represent ongoing, critical processes that ensure the continued effectiveness and reliability of deployed machine learning systems. Traditional software maintains static behavior, while ML systems must account for shifts in data distributions<a href="#fn27" class="footnote-ref" id="fnref27" role="doc-noteref"><sup>27</sup></a>, changing usage patterns, and evolving operational requirements<a href="#fn28" class="footnote-ref" id="fnref28" role="doc-noteref"><sup>28</sup></a>. Monitoring provides the feedback necessary to adapt to these challenges, while maintenance ensures the system evolves to meet new needs. These operational practices form the foundation of <strong><a href="../ops/ops.html#sec-ml-operations">Chapter 13: ML Operations</a></strong>.</p>
<div class="no-row-height column-margin column-container"><div id="fn27"><p><sup>27</sup>&nbsp;<strong>Data Drift Detection</strong>: Data drift occurs when input data characteristics change over time: user behavior shifts, sensor calibration drifts, or population demographics evolve. Studies show that Studies suggest 50-80% of production ML models experience some form of data drift within 12-18 months <span class="citation" data-cites="breck2017ml">(<a href="#ref-breck2017ml" role="doc-biblioref">Breck et al. 2017</a>)</span>, yet only 23% of organizations have automated drift detection <span class="citation" data-cites="paleyes2022challenges">(<a href="#ref-paleyes2022challenges" role="doc-biblioref">Paleyes, Urma, and Lawrence 2022</a>)</span>. Statistical tests like Kolmogorov-Smirnov and Population Stability Index can detect drift, but require setting thresholds and monitoring 100+ features continuously. Cloud providers now offer drift detection services (AWS SageMaker Model Monitor, Google AI Platform), but custom implementation remains necessary for domain-specific requirements.</p><div id="ref-paleyes2022challenges" class="csl-entry" role="listitem">
Paleyes, Andrei, Raoul-Gabriel Urma, and Neil D. Lawrence. 2022. <span>“Challenges in Deploying Machine Learning: A Survey of Case Studies.”</span> <em>ACM Computing Surveys</em> 55 (6): 1–29. <a href="https://doi.org/10.1145/3533378">https://doi.org/10.1145/3533378</a>.
</div></div><div id="fn28"><p><sup>28</sup>&nbsp;<strong>Model Drift Phenomenon</strong>: ML models degrade over time without any code changes—a phenomenon unknown in traditional software. Studies show that Studies indicate that 40-70% of production ML models experience measurable performance degradation within 6-12 months due to data drift, concept drift, or infrastructure drift <span class="citation" data-cites="polyzotis2019data">(<a href="#ref-polyzotis2019data" role="doc-biblioref">Polyzotis et al. 2017</a>)</span>. This “silent failure” problem led to the development of specialized monitoring tools like Evidently AI (2020) and Fiddler (2018), creating an entirely new category of ML infrastructure that has no equivalent in traditional software engineering.</p><div id="ref-polyzotis2019data" class="csl-entry" role="listitem">
Polyzotis, Neoklis, Sudip Roy, Steven Euijong Whang, and Martin Zinkevich. 2017. <span>“Data Management Challenges in Production Machine Learning.”</span> In <em>Proceedings of the 2017 ACM International Conference on Management of Data</em>, 1723–26. ACM. <a href="https://doi.org/10.1145/3035918.3054782">https://doi.org/10.1145/3035918.3054782</a>.
</div></div></div><p>As we saw in <a href="#fig-ml-lifecycle-feedback" class="quarto-xref">Figure&nbsp;4</a>, monitoring serves as a central hub for system improvement, generating three critical feedback loops: “Performance Insights” flowing back to data collection to address gaps, “Data Quality Issues” triggering refinements in data preparation, and “Model Updates” initiating retraining when performance drifts. In our DR example, these feedback loops enable continuous system improvement: identifying underrepresented patient demographics (triggering new data collection), detecting image quality issues (improving preprocessing), and addressing model drift (initiating retraining).</p>
<p>For DR screening systems, continuous monitoring tracks system performance across diverse clinics, detecting issues such as changing patient demographics or new imaging technologies that could impact accuracy. Proactive maintenance includes plans to incorporate 3D imaging modalities like OCT, expanding the system’s capabilities to diagnose a wider range of conditions. This demonstrates the importance of designing systems that adapt to future challenges while maintaining compliance with rigorous healthcare regulations and the responsible AI principles explored in <strong><a href="../responsible_ai/responsible_ai.html#sec-responsible-ai">Chapter 17: Responsible AI</a></strong>.</p>
<section id="sec-ai-workflow-production-monitoring-dynamic-systems-e716" class="level3 page-columns page-full">
<h3 class="anchored" data-anchor-id="sec-ai-workflow-production-monitoring-dynamic-systems-e716">Production Monitoring for Dynamic Systems</h3>
<p>The requirements for monitoring and maintenance emerge from both technical needs and operational realities. In our DR example, monitoring from a technical perspective requires continuous tracking of model performance, data quality, and system resource usage. However, operational constraints add layers of complexity: monitoring systems must align with clinical workflows, detect shifts in patient demographics, and provide actionable insights to both technical teams and healthcare providers.</p>
<p>Initial deployment often highlights several areas where systems fail to meet real-world needs, such as 15-25% accuracy decrease in clinics with equipment older than 5 years or images with resolution below 1024x1024 pixels. Monitoring systems detect performance drops in specific subgroups: 18% accuracy reduction for patients with proliferative diabetic retinopathy (affecting 2% of screening population), and 22% sensitivity loss for images with significant cataracts (affecting 12% of elderly patients over 65). These blind spots, invisible during laboratory validation but critical in clinical practice<a href="#fn29" class="footnote-ref" id="fnref29" role="doc-noteref"><sup>29</sup></a>, inform maintenance strategies including targeted data collection (adding 15,000 cataract-affected images) and architectural improvements (ensemble models with specialized pathology detectors).</p>
<div class="no-row-height column-margin column-container"><div id="fn29"><p><sup>29</sup>&nbsp;<strong>The Lab-to-Clinic Performance Gap</strong>: Medical AI systems typically see 10-30% performance drops when deployed in real-world settings, a phenomenon known as the “deployment reality gap.” This occurs because training data, despite best efforts, cannot capture the full diversity of real-world conditions—different camera models, varying image quality, diverse patient populations, and operator skill levels all contribute to this gap. The gap is so consistent that regulatory bodies like the FDA now require “real-world performance studies” for medical AI approval, acknowledging that laboratory performance is insufficient to predict clinical utility.</p></div><div id="fn30"><p><sup>30</sup>&nbsp;<strong>Population Stability Index (PSI)</strong>: Statistical measure that quantifies how much a dataset’s distribution has shifted compared to a baseline, with values 0-0.1 indicating minimal shift, 0.1-0.2 moderate shift requiring investigation, and &gt;0.2 significant shift requiring model retraining. Developed by credit risk analysts in the 1990s, PSI became standard for ML monitoring because distribution shifts often precede model performance degradation. PSI = Σ((actual% - expected%) × ln(actual%/expected%)), providing early warning of data drift before accuracy metrics decline, which is crucial since model retraining can take days or weeks. To prevent alert fatigue, teams limit alerts to 10 per day per team, implementing escalation hierarchies and alert suppression mechanisms. To support this, teams implement advanced logging and analytics pipelines to process large amounts of operational data from clinics without disrupting diagnostic workflows. Secure and efficient data handling is essential to transmit data across multiple clinics while preserving patient confidentiality.</p></div></div><p>These requirements influence system design significantly. The critical nature of such systems demands real-time monitoring capabilities rather than periodic offline evaluations. Teams typically establish quantitative performance thresholds with clear action triggers: P95 latency exceeding 2x baseline generates immediate alerts with 5-minute response SLAs, model accuracy drops greater than 5% trigger daily alerts with automated retraining workflows, data drift Population Stability Index (PSI)<a href="#fn30" class="footnote-ref" id="fnref30" role="doc-noteref"><sup>30</sup></a> scores above 0.2 initiate weekly alerts with data team notifications, and resource utilization exceeding 80% activates auto-scaling mechanisms with cost monitoring.</p>
<p>Monitoring requirements also affect model design, as teams incorporate mechanisms for granular performance tracking and anomaly detection. Even the system’s user interface is influenced, needing to present monitoring data in a clear, actionable manner for clinical and technical staff alike.</p>
</section>
<section id="sec-ai-workflow-continuous-improvement-feedback-loops-3b51" class="level3 page-columns page-full">
<h3 class="anchored" data-anchor-id="sec-ai-workflow-continuous-improvement-feedback-loops-3b51">Continuous Improvement Through Feedback Loops</h3>
<p>The monitoring and maintenance workflow in our DR example reveals the intricate interplay between automated systems, human expertise, and evolving healthcare practices. This workflow begins with defining a complete monitoring framework, establishing key performance indicators (KPIs), and implementing dashboards and alert systems. This framework must balance depth of monitoring with system performance and privacy considerations, collecting sufficient data to detect issues without overburdening the system or violating patient confidentiality.</p>
<p>As systems mature, maintenance becomes an increasingly dynamic process. Model updates driven by new medical knowledge or performance improvements require careful validation and controlled rollouts. Teams employ A/B testing frameworks to evaluate updates in real-world conditions and implement rollback mechanisms<a href="#fn31" class="footnote-ref" id="fnref31" role="doc-noteref"><sup>31</sup></a> to address issues quickly when they arise. Unlike traditional software where continuous integration and deployment<a href="#fn32" class="footnote-ref" id="fnref32" role="doc-noteref"><sup>32</sup></a> handles code changes deterministically, ML systems must account for data evolution<a href="#fn33" class="footnote-ref" id="fnref33" role="doc-noteref"><sup>33</sup></a> that affects model behavior in ways traditional CI/CD pipelines were not designed to handle.</p>
<div class="no-row-height column-margin column-container"><div id="fn31"><p><sup>31</sup>&nbsp;<strong>Rollback Mechanisms</strong>: Automated systems that quickly revert software to a previous stable version when issues are detected, essential for maintaining service reliability during deployments. In traditional software, rollbacks take 5-30 minutes and restore deterministic behavior, but ML rollbacks are more complex because model behavior depends on current data distributions. Companies like Uber maintain shadow deployments where old and new models run simultaneously, enabling instant rollbacks within 60 seconds while preserving prediction consistency <span class="citation" data-cites="uber2017michelangelo">(<a href="#ref-uber2017michelangelo" role="doc-biblioref">Hermann and Del Balso 2017</a>)</span>. ML rollbacks require careful consideration of data compatibility and feature dependencies.</p><div id="ref-uber2017michelangelo" class="csl-entry" role="listitem">
Hermann, Jeremy, and Mike Del Balso. 2017. <span>“Michelangelo: Uber’s Machine Learning Platform.”</span> In <em>Data Engineering Bulletin</em>, 40:8–21. 4.
</div></div><div id="fn32"><p><sup>32</sup>&nbsp;<strong>CI/CD for Machine Learning</strong>: Traditional continuous integration is designed for deterministic builds where code changes produce predictable outputs. ML systems violate this assumption because model behavior depends on training data, random initialization, and hardware differences. Google’s TFX and similar platforms had to reinvent CI/CD principles for ML, introducing concepts like “model validation” and “data validation” that have no equivalent in traditional software.</p></div><div id="fn33"><p><sup>33</sup>&nbsp;<strong>Data Evolution in Production</strong>: Unlike traditional software where inputs are static, ML system inputs evolve continuously: user behavior changes, market conditions shift, and sensor data drifts. Netflix and similar companies report that recommendation models see approximately 10-15% of features require updating monthly <span class="citation" data-cites="netflix2012recommendation">(<a href="#ref-netflix2012recommendation" role="doc-biblioref">Gomez-Uribe and Hunt 2015</a>)</span>, while financial fraud detection models experience 30-40% feature drift quarterly <span class="citation" data-cites="stripe2019machine">(<a href="#ref-stripe2019machine" role="doc-biblioref">Arsene, Dumitrache, and Mihu 2015</a>)</span>. This constant evolution means ML systems require “data testing” pipelines that validate 200+ statistical properties of incoming data, a complexity absent in traditional software where input validation involves simple type checking <span class="citation" data-cites="breck2017ml">(<a href="#ref-breck2017ml" role="doc-biblioref">Breck et al. 2017</a>)</span>.</p><div id="ref-netflix2012recommendation" class="csl-entry" role="listitem">
Gomez-Uribe, Carlos A., and Neil Hunt. 2015. <span>“The Netflix Recommender System: Algorithms, Business Value, and Innovation.”</span> <em>ACM Transactions on Management Information Systems</em> 6 (4): 1–19. <a href="https://doi.org/10.1145/2843948">https://doi.org/10.1145/2843948</a>.
</div><div id="ref-stripe2019machine" class="csl-entry" role="listitem">
Arsene, Octavian, Ioan Dumitrache, and Ioana Mihu. 2015. <span>“Expert System for Medicine Diagnosis Using Software Agents.”</span> <em>Expert Systems with Applications</em> 42 (4): 1825–34. <a href="https://doi.org/10.1016/j.eswa.2014.10.026">https://doi.org/10.1016/j.eswa.2014.10.026</a>.
</div><div id="ref-breck2017ml" class="csl-entry" role="listitem">
Breck, Eric, Shanqing Cai, Eric Nielsen, Michael Salib, and D. Sculley. 2017. <span>“The ML Test Score: A Rubric for ML Production Readiness and Technical Debt Reduction.”</span> In <em>2017 IEEE International Conference on Big Data (Big Data)</em>, 1123–32. IEEE; IEEE. <a href="https://doi.org/10.1109/bigdata.2017.8258038">https://doi.org/10.1109/bigdata.2017.8258038</a>.
</div></div></div><p>Monitoring and maintenance form an iterative cycle rather than discrete phases. Insights from monitoring inform maintenance activities, while maintenance efforts often necessitate updates to monitoring strategies. Teams develop workflows to transition seamlessly from issue detection to resolution, involving collaboration across technical and clinical domains.</p>
</section>
<section id="sec-ai-workflow-distributed-system-monitoring-scale-90d6" class="level3 page-columns page-full">
<h3 class="anchored" data-anchor-id="sec-ai-workflow-distributed-system-monitoring-scale-90d6">Distributed System Monitoring at Scale</h3>
<p>As our DR example illustrates, scaling from 5 pilot sites to 200+ clinic deployment causes monitoring and maintenance complexities to grow exponentially. Each additional clinic generates 2-5 GB of operational logs weekly (including inference times, image quality metrics, error rates, and usage patterns), creating a system-wide data volume of 400-1000 GB per week that requires automated analysis. Each clinic also introduces environmental variables: 15+ different camera models (from 2-megapixel mobile devices to 12-megapixel professional systems), varying operator skill levels (from trained technicians to community health workers), and diverse demographic patterns (urban vs.&nbsp;rural, age distributions varying by 20+ years in median age).</p>
<p>The need to monitor both global performance metrics and site-specific behaviors requires sophisticated infrastructure. The monitoring system tracks stage-level metrics including processing time, error rates, and resource utilization across the distributed workflow, maintains complete data lineage<a href="#fn34" class="footnote-ref" id="fnref34" role="doc-noteref"><sup>34</sup></a> tracking with source-to-prediction audit trails for regulatory compliance, correlates production issues with specific training experiments to enable rapid root cause analysis, and provides cost attribution tracking resource usage across teams and projects.</p>
<div class="no-row-height column-margin column-container"><div id="fn34"><p><sup>34</sup>&nbsp;<strong>Data Lineage</strong>: Complete record of data flow from source systems through transformations to final outputs, enabling traceability, debugging, and regulatory compliance. Originally developed for financial systems (1990s) to meet audit requirements, data lineage became crucial for ML because model predictions depend on complex data pipelines with 10+ transformation steps. Regulations like GDPR “right to explanation” require organizations to trace how individual data points influence ML decisions. Companies like Netflix track lineage for 100,000+ daily data transformations, while financial firms maintain 7+ years of lineage data for regulatory compliance. While global metrics provide an overview of system health, localized issues, including a hardware malfunction at a specific clinic or unexpected patterns in patient data, need targeted monitoring. Advanced analytics systems process data from all clinics to identify these localized anomalies while maintaining a system-wide perspective, enabling teams to detect subtle system-wide diagnostic pattern shifts that are invisible in individual clinics but evident in aggregated data.</p></div></div><p>Continuous adaptation adds further complexity. Real-world usage exposes the system to an ever-expanding range of scenarios. Capturing insights from these scenarios and using them to drive system updates requires efficient mechanisms for integrating new data into training pipelines and deploying improved models without disrupting clinical workflows.</p>
</section>
<section id="sec-ai-workflow-anticipating-preventing-system-degradation-b0b9" class="level3">
<h3 class="anchored" data-anchor-id="sec-ai-workflow-anticipating-preventing-system-degradation-b0b9">Anticipating and Preventing System Degradation</h3>
<p>Reactive maintenance alone proves insufficient for dynamic operating environments. Proactive strategies become essential to anticipate and prevent issues before they affect clinical operations.</p>
<p>Predictive maintenance models identify potential problems based on patterns in operational data. Continuous learning pipelines allow the system to retrain and adapt based on new data, ensuring its relevance as clinical practices or patient demographics evolve. These capabilities require careful balancing to ensure safety and reliability while maintaining system performance.</p>
<p>Metrics assessing adaptability and resilience become as important as accuracy, reflecting the system’s ability to evolve alongside its operating environment. Proactive maintenance ensures the system can handle future challenges without sacrificing reliability.</p>
<p>These monitoring and maintenance experiences bring our lifecycle journey full circle, demonstrating the continuous feedback loops illustrated in <a href="#fig-ml-lifecycle" class="quarto-xref">Figure&nbsp;1</a>. Production insights inform refined problem definitions, data quality improvements, architectural enhancements, and infrastructure planning for subsequent iterations—closing the loop that distinguishes ML systems from traditional linear development.</p>
<p>This continuous feedback and improvement cycle embodies the systems thinking approach that distinguishes AI systems from traditional software development. Success emerges not from perfecting individual lifecycle stages in isolation, but from building systems that learn, adapt, and improve through understanding how all components interconnect.</p>
<div id="quiz-question-sec-ai-workflow-monitoring-maintenance-stage-c6f7" class="callout callout-quiz-question">
<details class="callout-quiz-question fbx-default closebutton"><summary><strong>Self-Check: Question 1.9</strong></summary><div>
<ol type="1">
<li><p>Which of the following best describes the primary purpose of monitoring in ML systems?</p>
<ol type="a">
<li>To maintain static behavior of the system.</li>
<li>To eliminate the need for human oversight.</li>
<li>To ensure deterministic outputs from the system.</li>
<li>To detect and adapt to data and model drift.</li>
</ol></li>
<li><p>Explain how data drift can impact the performance of a machine learning model in production.</p></li>
<li><p>Order the following steps in a typical ML maintenance workflow: (1) Model Retraining, (2) Data Drift Detection, (3) Performance Monitoring, (4) Feedback Loop Initiation.</p></li>
<li><p>What are the benefits of implementing proactive maintenance strategies in ML systems?</p></li>
</ol>
<p><a href="#quiz-answer-sec-ai-workflow-monitoring-maintenance-stage-c6f7" class="question-label">See Answers →</a></p>
</div></details>
</div>
</section>
</section>
<section id="sec-ai-workflow-integrating-systems-thinking-principles-6bfc" class="level2">
<h2 class="anchored" data-anchor-id="sec-ai-workflow-integrating-systems-thinking-principles-6bfc">Integrating Systems Thinking Principles</h2>
<p>After examining each stage of the AI lifecycle via our diabetic retinopathy case study, systems-level patterns emerge that distinguish successful AI projects from those that struggle with integration challenges. The DR example demonstrates that building effective machine learning systems requires more than technical excellence; it demands understanding how technical decisions create interdependencies that cascade throughout the entire development and deployment process.</p>
<p>Four fundamental systems thinking patterns emerge from our analysis: constraint propagation, multi-scale feedback, emergent complexity, and resource optimization. These patterns provide the analytical framework for understanding how the technical chapters ahead interconnect, showing why specialized approaches to data engineering, frameworks, training, and operations collectively enable integrated systems that individual optimizations cannot achieve.</p>
<section id="sec-ai-workflow-decisions-cascade-system-4927" class="level3">
<h3 class="anchored" data-anchor-id="sec-ai-workflow-decisions-cascade-system-4927">How Decisions Cascade Through the System</h3>
<p>Constraint propagation represents the most crucial systems thinking pattern in ML development: early decisions create cascading effects that shape every subsequent stage. Our DR example illustrates this pattern clearly: regulatory requirements for &gt;90% sensitivity drive data collection strategies (requiring expert consensus labeling), which influence model architecture choices (demanding high-capacity networks), which determine deployment constraints (necessitating edge optimization), which shape monitoring approaches (requiring distributed performance tracking).</p>
<p>This propagation operates bidirectionally, creating dynamic constraint networks rather than linear dependencies. When rural clinic deployment reveals bandwidth limitations (averaging 2-10 Mbps), teams must redesign data preprocessing pipelines to achieve 95% compression ratios, which requires model architectures optimized for compressed inputs, which influences training strategies that account for data degradation. Understanding these cascading relationships enables teams to make architectural decisions that accommodate rather than fight against systemic constraints.</p>
</section>
<section id="sec-ai-workflow-orchestrating-feedback-across-multiple-timescales-310d" class="level3">
<h3 class="anchored" data-anchor-id="sec-ai-workflow-orchestrating-feedback-across-multiple-timescales-310d">Orchestrating Feedback Across Multiple Timescales</h3>
<p>ML systems succeed through orchestrating feedback loops across multiple timescales, each serving different system optimization purposes. Our DR deployment exemplifies this pattern: minute-level loops (real-time quality checks, automated image validation), daily loops (model performance monitoring across 200+ clinics), weekly loops (aggregated accuracy analysis, drift detection), monthly loops (demographic bias assessment, hardware performance review), and quarterly loops (architecture evaluation, capacity planning for new regions).</p>
<p>The temporal structure of these feedback loops reflects the inherent dynamics of ML systems. Rapid loops enable quick correction of operational issues—a clinic’s misconfigured camera can be detected and corrected within minutes. Slower loops enable strategic adaptation—recognizing that population demographic shifts require expanded training data takes months of monitoring to detect reliably. This multi-scale approach prevents both reactionary changes (over-responding to daily fluctuations) and sluggish adaptation (under-responding to meaningful trends).</p>
</section>
<section id="sec-ai-workflow-understanding-systemlevel-behaviors-2762" class="level3">
<h3 class="anchored" data-anchor-id="sec-ai-workflow-understanding-systemlevel-behaviors-2762">Understanding System-Level Behaviors</h3>
<p>Complex systems exhibit emergent behaviors that are invisible when analyzing individual components but become apparent at system scale. Our DR deployment reveals this pattern: individual clinics may show stable 94% accuracy, yet system-wide analysis detects subtle performance degradation affecting specific demographic groups—patterns invisible in single-site monitoring but critical for equitable healthcare delivery.</p>
<p>Emergent complexity in ML systems manifests differently than in traditional software. While conventional distributed systems fail through deterministic cascades (server crashes, network partitions), ML systems exhibit probabilistic degradation through data drift, model bias amplification, and subtle performance erosion across heterogeneous environments. Managing this complexity requires analytical frameworks that detect statistical patterns across distributed deployments, enabling proactive intervention before system-wide problems manifest.</p>
</section>
<section id="sec-ai-workflow-multidimensional-resource-tradeoffs-bb50" class="level3">
<h3 class="anchored" data-anchor-id="sec-ai-workflow-multidimensional-resource-tradeoffs-bb50">Multi-Dimensional Resource Trade-offs</h3>
<p>Resource optimization in ML systems involves multi-dimensional trade-offs that create complex interdependencies absent in traditional software development. Our DR case illustrates these trade-offs: increasing model accuracy from 94.8% to 95.2% requires expanding from 96MB to 180MB model size, which forces deployment from edge devices ($200-600 each) to more powerful hardware ($800-2000 each), multiplied across 200+ clinics—a $160,000 infrastructure cost increase for 0.4% accuracy improvement.</p>
<p>These resource trade-offs exhibit non-linear relationships that defy simple optimization approaches. Training time scales quadratically with data size, but model accuracy improvements show diminishing returns. Edge deployment reduces inference latency by 85% but constrains model complexity by 90%. Cloud deployment enables unlimited model complexity but introduces 200ms+ latency that violates clinical workflow requirements. Understanding these trade-off relationships enables teams to make strategic architectural decisions rather than attempting to optimize individual components in isolation.</p>
</section>
<section id="sec-ai-workflow-engineering-discipline-ml-systems-b4e3" class="level3">
<h3 class="anchored" data-anchor-id="sec-ai-workflow-engineering-discipline-ml-systems-b4e3">Engineering Discipline for ML Systems</h3>
<p>These four systems thinking patterns—constraint propagation, multi-scale feedback, emergent complexity, and resource optimization—converge to define a fundamentally different approach to engineering machine learning systems. Unlike traditional software where components can be optimized independently, ML systems demand integrated optimization that accounts for cross-component dependencies, temporal dynamics, and resource constraints simultaneously.</p>
<p>The DR case study demonstrates that this integrated approach yields systems that are more robust, adaptive, and effective than those developed through sequential optimization of individual stages. When teams design data collection strategies that anticipate deployment constraints, create model architectures that accommodate operational realities, and implement monitoring systems that drive continuous improvement, they achieve performance levels that isolated optimization approaches cannot reach. This systematic integration represents the core engineering discipline that transforms machine learning from experimental technique into reliable system engineering practice.</p>
<div id="quiz-question-sec-ai-workflow-integrating-systems-thinking-principles-6bfc" class="callout callout-quiz-question">
<details class="callout-quiz-question fbx-default closebutton"><summary><strong>Self-Check: Question 1.10</strong></summary><div>
<ol type="1">
<li><p>Which of the following best illustrates the concept of constraint propagation in AI development?</p>
<ol type="a">
<li>Using high-capacity networks to improve model accuracy.</li>
<li>Deploying models on edge devices to reduce latency.</li>
<li>Adjusting data preprocessing pipelines due to bandwidth limitations.</li>
<li>Increasing model size to enhance performance.</li>
</ol></li>
<li><p>Explain how multi-scale feedback loops contribute to the robustness of an AI system.</p></li>
<li><p>In managing emergent complexity, what is a key difference between ML systems and traditional software systems?</p>
<ol type="a">
<li>ML systems require monitoring for data drift and model bias.</li>
<li>Traditional systems exhibit probabilistic degradation.</li>
<li>ML systems rely on deterministic processes.</li>
<li>Traditional systems focus on hardware performance.</li>
</ol></li>
<li><p>Discuss the trade-offs involved in resource optimization for ML systems, using the DR case study as an example.</p></li>
</ol>
<p><a href="#quiz-answer-sec-ai-workflow-integrating-systems-thinking-principles-6bfc" class="question-label">See Answers →</a></p>
</div></details>
</div>
</section>
</section>
<section id="sec-ai-workflow-fallacies-pitfalls-6c5b" class="level2">
<h2 class="anchored" data-anchor-id="sec-ai-workflow-fallacies-pitfalls-6c5b">Fallacies and Pitfalls</h2>
<p>Machine learning development introduces unique complexities that differ from traditional software engineering, yet many teams attempt to apply familiar development patterns without recognizing these differences. The experimental nature of ML, the central role of data quality, and the probabilistic behavior of models create workflow challenges that traditional methodologies cannot address.</p>
<p><strong>Fallacy:</strong> <em>ML development can follow traditional software engineering workflows without modification.</em></p>
<p>This misconception leads teams to apply conventional software development practices directly to machine learning projects. As established in our comparison of Traditional vs.&nbsp;AI Lifecycles, ML systems introduce fundamental uncertainties through data variability, algorithmic randomness, and evolving model performance that traditional deterministic approaches cannot handle. Forcing ML projects into rigid waterfall or standard agile methodologies often results in missed deadlines, inadequate model validation, and deployment failures. Successful ML workflows require specialized stages for data validation (<strong><a href="../data_engineering/data_engineering.html#sec-data-engineering">Chapter 6: Data Engineering</a></strong>), experiment tracking (<strong><a href="../frameworks/frameworks.html#sec-ai-frameworks">Chapter 7: AI Frameworks</a></strong>), and iterative model refinement (<strong><a href="../training/training.html#sec-ai-training">Chapter 8: AI Training</a></strong>).</p>
<p><strong>Pitfall:</strong> <em>Treating data preparation as a one-time preprocessing step.</em></p>
<p>Many practitioners view data collection and preprocessing as initial workflow stages that, once completed, remain static throughout the project lifecycle. This approach fails to account for the dynamic nature of real-world data, where distribution shifts, quality changes, and new data sources continuously emerge. Production systems require ongoing data validation, monitoring for drift, and adaptive preprocessing pipelines as detailed in <strong><a href="../data_engineering/data_engineering.html#sec-data-engineering">Chapter 6: Data Engineering</a></strong>. Teams that treat data preparation as a completed milestone often encounter unexpected model degradation when deployed systems encounter data that differs from training conditions, highlighting the robustness challenges explored in <strong><a href="../robust_ai/robust_ai.html#sec-robust-ai">Chapter 16: Robust AI</a></strong>.</p>
<p><strong>Fallacy:</strong> <em>Model performance in development environments accurately predicts production performance.</em></p>
<p>This belief assumes that achieving good metrics during development ensures successful deployment. Development environments typically use clean, well-curated datasets and controlled computational resources, creating artificial conditions that rarely match production realities. Production systems face data quality issues, latency constraints, resource limitations, and adversarial inputs not present during development. Models that excel in development can fail in production due to these environmental differences, requiring workflow stages specifically designed to bridge this gap through robust deployment practices covered in <strong><a href="../ops/ops.html#sec-ml-operations">Chapter 13: ML Operations</a></strong> and system design principles from <strong><a href="../ml_systems/ml_systems.html#sec-ml-systems">Chapter 2: ML Systems</a></strong>.</p>
<p><strong>Pitfall:</strong> <em>Skipping systematic validation stages to accelerate development timelines.</em></p>
<p>Under pressure to deliver quickly, teams often bypass validation, testing, and documentation stages. This approach treats validation as overhead rather than essential engineering discipline. Inadequate validation leads to models with hidden biases, poor generalization, or unexpected failure modes that only manifest in production. The cost of fixing these issues after deployment exceeds the time investment required for systematic validation. Robust workflows embed validation throughout the development process rather than treating it as a final checkpoint, incorporating the benchmarking and evaluation principles detailed in <strong><a href="../benchmarking/benchmarking.html#sec-benchmarking-ai">Chapter 12: Benchmarking AI</a></strong>.</p>
<div id="quiz-question-sec-ai-workflow-fallacies-pitfalls-6c5b" class="callout callout-quiz-question">
<details class="callout-quiz-question fbx-default closebutton"><summary><strong>Self-Check: Question 1.11</strong></summary><div>
<ol type="1">
<li><p>True or False: Machine learning development can effectively follow traditional software engineering workflows without any modifications.</p></li>
<li><p>Which of the following is a common pitfall in ML development?</p>
<ol type="a">
<li>Using agile methodologies for iterative development.</li>
<li>Treating data preparation as a one-time preprocessing step.</li>
<li>Incorporating feedback loops in the ML lifecycle.</li>
<li>Ensuring continuous data validation and monitoring.</li>
</ol></li>
<li><p>Explain why model performance in development environments may not accurately predict production performance.</p></li>
<li><p>The belief that achieving good metrics during development ensures successful deployment is a common ____. This assumption overlooks the differences between development and production environments.</p></li>
<li><p>In a production system, how might you address the pitfall of skipping systematic validation stages to accelerate development timelines?</p></li>
</ol>
<p><a href="#quiz-answer-sec-ai-workflow-fallacies-pitfalls-6c5b" class="question-label">See Answers →</a></p>
</div></details>
</div>
</section>
<section id="sec-ai-workflow-summary-84ad" class="level2">
<h2 class="anchored" data-anchor-id="sec-ai-workflow-summary-84ad">Summary</h2>
<p>This chapter established the ML lifecycle as the systematic framework for engineering machine learning systems, the mental roadmap that organizes how data, models, and deployment infrastructure interconnect throughout development. <a href="#fig-ml-lifecycle" class="quarto-xref">Figure&nbsp;1</a> visualized this framework through two parallel pipelines: the data pipeline transforms raw inputs through collection, ingestion, analysis, labeling, validation, and preparation into ML-ready datasets, while the model development pipeline takes these datasets through training, evaluation, validation, and deployment to create production systems. The critical insight lies in their interconnections: the feedback arrows showing how deployment insights trigger data refinements, creating the continuous improvement cycles that distinguish ML from traditional linear development.</p>
<p>Understanding this framework explains why machine learning systems demand specialized approaches that differ fundamentally from traditional software. ML workflows replace deterministic specifications with probabilistic optimization, static behavior with dynamic adaptation, and isolated development with continuous feedback loops. This systematic perspective recognizes that success emerges not from perfecting individual stages in isolation, but from understanding how data quality affects model performance, how deployment constraints shape training strategies, and how production insights inform each subsequent development iteration.</p>
<div class="callout callout-style-default callout-important callout-titled" title="Key Takeaways">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Key Takeaways
</div>
</div>
<div class="callout-body-container callout-body">
<ul>
<li>The ML lifecycle provides the scaffolding framework for understanding how subsequent technical chapters interconnect—data engineering, frameworks, training, and operations each address specific components within this complete system</li>
<li>Two parallel pipelines characterize ML development: data processing (collection → preparation) and model development (training → deployment), unified by continuous feedback loops</li>
<li>ML workflows differ fundamentally from traditional software through iterative experimentation, data-driven adaptation, and feedback mechanisms that enable continuous system improvement</li>
<li>Systems thinking patterns—constraint propagation, multi-scale feedback, emergent complexity, and resource optimization—span all technical implementations explored in subsequent chapters</li>
</ul>
</div>
</div>
<p>The workflow framework established here provides the organizing structure for Part II’s technical chapters. Data Engineering (<strong><a href="../data_engineering/data_engineering.html#sec-data-engineering">Chapter 6: Data Engineering</a></strong>) expands on the data pipeline stages we explored, addressing how to ensure quality and manage data throughout the lifecycle. Frameworks (<strong><a href="../frameworks/frameworks.html#sec-ai-frameworks">Chapter 7: AI Frameworks</a></strong>) examines the software tools that enable this iterative development process. Training (<strong><a href="../training/training.html#sec-ai-training">Chapter 8: AI Training</a></strong>) details how to efficiently train models at scale. Operations (<strong><a href="../ops/ops.html#sec-ml-operations">Chapter 13: ML Operations</a></strong>) explores how systems maintain performance in production through the feedback loops illustrated in <a href="#fig-ml-lifecycle" class="quarto-xref">Figure&nbsp;1</a>. Each subsequent chapter assumes you understand where its specific techniques fit within this complete workflow, building upon the systematic perspective developed here.</p>


<div id="quiz-question-sec-ai-workflow-summary-84ad" class="callout callout-quiz-question">
<details class="callout-quiz-question fbx-default closebutton"><summary><strong>Self-Check: Question 1.12</strong></summary><div>
<ol type="1">
<li><p>Which of the following best describes the role of feedback loops in the ML lifecycle?</p>
<ol type="a">
<li>They enable continuous improvement by refining data and model performance.</li>
<li>They provide a mechanism for error correction in static systems.</li>
<li>They are used to validate models before deployment.</li>
<li>They ensure that the ML lifecycle is a linear process.</li>
</ol></li>
<li><p>Explain how the interconnection between data and model pipelines contributes to the success of machine learning systems.</p></li>
<li><p>Order the following stages of the ML lifecycle from data collection to deployment: (1) Model Training, (2) Data Preparation, (3) Model Evaluation, (4) Data Collection, (5) Deployment.</p></li>
<li><p>True or False: The ML lifecycle is characterized by deterministic specifications and static behavior.</p></li>
</ol>
<p><a href="#quiz-answer-sec-ai-workflow-summary-84ad" class="question-label">See Answers →</a></p>
</div></details>
</div>
</section>
<section id="self-check-answers" class="level2">
<h2 class="anchored" data-anchor-id="self-check-answers">Self-Check Answers</h2>
<div id="quiz-answer-sec-ai-workflow-systematic-framework-ml-development-1fc3" class="callout callout-quiz-answer">
<details class="callout-quiz-answer fbx-answer closebutton"><summary><strong>Self-Check: Answer 1.1</strong></summary><div>
<ol type="1">
<li><p><strong>How does the machine learning workflow differ from traditional software engineering processes?</strong></p>
<ol type="a">
<li>ML workflow is iterative and data-centric, involving experimentation and empirical validation.</li>
<li>ML workflow is deterministic and follows a strict requirement-to-implementation path.</li>
<li>ML workflow does not involve any feedback mechanisms.</li>
<li>ML workflow is identical to traditional software engineering.</li>
</ol>
<p><em>Answer</em>: The correct answer is A. ML workflow is iterative and data-centric, involving experimentation and empirical validation. Traditional software engineering is more deterministic, whereas ML systems evolve through iterative experimentation and data-driven insights.</p>
<p><em>Learning Objective</em>: Understand the fundamental differences between ML workflows and traditional software engineering processes.</p></li>
<li><p><strong>Why is iterative experimentation crucial in the development of machine learning systems?</strong></p>
<p><em>Answer</em>: Iterative experimentation is crucial because it allows ML systems to evolve by continuously testing and validating models against data, refining them based on performance metrics. This process accommodates uncertainty and enables the system to adapt to new data and deployment constraints, ensuring robust performance in real-world scenarios.</p>
<p><em>Learning Objective</em>: Explain the importance of iterative experimentation in ML system development.</p></li>
<li><p><strong>What role do feedback mechanisms play in the ML system development workflow?</strong></p>
<ol type="a">
<li>They are unnecessary as ML systems are static once deployed.</li>
<li>They are used to finalize the initial model without further changes.</li>
<li>They only apply to traditional software engineering.</li>
<li>They inform earlier development phases and help refine models.</li>
</ol>
<p><em>Answer</em>: The correct answer is D. They inform earlier development phases and help refine models. Feedback mechanisms are essential in ML workflows as they provide insights that guide iterative improvements and model adjustments.</p>
<p><em>Learning Objective</em>: Understand the function of feedback mechanisms in ML system workflows.</p></li>
<li><p><strong>In the context of ML system development, how might the diabetic retinopathy screening system case study illustrate the workflow principles discussed?</strong></p>
<p><em>Answer</em>: The diabetic retinopathy screening system case study illustrates workflow principles by showing how data acquisition, model training, and deployment constraints are managed iteratively. It demonstrates the interplay of these components in refining model accuracy and operational efficiency, highlighting the importance of empirical validation and iterative improvements in real-world applications.</p>
<p><em>Learning Objective</em>: Apply workflow principles to a real-world ML system case study.</p></li>
</ol>
<p><a href="#quiz-question-sec-ai-workflow-systematic-framework-ml-development-1fc3" class="answer-label">← Back to Questions</a></p>
</div></details>
</div>
<div id="quiz-answer-sec-ai-workflow-understanding-ml-lifecycle-8445" class="callout callout-quiz-answer">
<details class="callout-quiz-answer fbx-answer closebutton"><summary><strong>Self-Check: Answer 1.2</strong></summary><div>
<ol type="1">
<li><p><strong>Which of the following best describes the role of feedback loops in the ML lifecycle?</strong></p>
<ol type="a">
<li>They ensure that each stage of the lifecycle is completed before moving to the next.</li>
<li>They are used to validate the final model before deployment.</li>
<li>They allow for continuous improvement by informing earlier stages with insights from later stages.</li>
<li>They help in maintaining a linear development process.</li>
</ol>
<p><em>Answer</em>: The correct answer is C. They allow for continuous improvement by informing earlier stages with insights from later stages. This iterative process is crucial for adapting to real-world conditions and improving system performance.</p>
<p><em>Learning Objective</em>: Understand the role of feedback loops in the ML lifecycle and their impact on continuous improvement.</p></li>
<li><p><strong>Explain how systems thinking applies to the machine learning lifecycle and why it is important.</strong></p>
<p><em>Answer</em>: Systems thinking in the ML lifecycle involves understanding how different stages interrelate and influence each other. This approach is important because it ensures that changes in one part of the system, such as data quality, are considered in the context of the entire lifecycle, leading to more robust and adaptable ML systems. For example, improving data quality can enhance model performance, which in turn affects deployment strategies.</p>
<p><em>Learning Objective</em>: Apply systems thinking to the ML lifecycle to understand interdependencies and their implications.</p></li>
<li><p><strong>Order the following stages of the ML lifecycle from data collection to deployment: (1) Model Training, (2) Data Preparation, (3) Model Evaluation, (4) Data Collection, (5) ML System Deployment.</strong></p>
<p><em>Answer</em>: The correct order is: (4) Data Collection, (2) Data Preparation, (1) Model Training, (3) Model Evaluation, (5) ML System Deployment. This sequence represents the flow from gathering raw data to deploying a validated ML system.</p>
<p><em>Learning Objective</em>: Understand the sequential flow of stages in the ML lifecycle from data collection to deployment.</p></li>
<li><p><strong>True or False: The ML lifecycle is a linear process where each stage is independent of the others.</strong></p>
<p><em>Answer</em>: False. The ML lifecycle is not linear; it is an iterative process where each stage is interconnected, and feedback from later stages can influence earlier ones.</p>
<p><em>Learning Objective</em>: Recognize the iterative and interconnected nature of the ML lifecycle.</p></li>
</ol>
<p><a href="#quiz-question-sec-ai-workflow-understanding-ml-lifecycle-8445" class="answer-label">← Back to Questions</a></p>
</div></details>
</div>
<div id="quiz-answer-sec-ai-workflow-ml-vs-traditional-software-development-0f90" class="callout callout-quiz-answer">
<details class="callout-quiz-answer fbx-answer closebutton"><summary><strong>Self-Check: Answer 1.3</strong></summary><div>
<ol type="1">
<li><p><strong>Which of the following best describes a key difference between traditional software development and machine learning development?</strong></p>
<ol type="a">
<li>Traditional software development follows a linear progression with predefined specifications, whereas ML development involves iterative experimentation and evolving objectives.</li>
<li>ML development relies on deterministic specifications, while traditional development is probabilistic.</li>
<li>Traditional software development is iterative, while ML development is linear.</li>
<li>ML development does not require feedback loops, unlike traditional software development.</li>
</ol>
<p><em>Answer</em>: The correct answer is A. Traditional software development follows a linear progression with predefined specifications, whereas ML development involves iterative experimentation and evolving objectives. This is correct because traditional methods rely on fixed requirements, while ML adapts to data-driven insights.</p>
<p><em>Learning Objective</em>: Understand the fundamental differences in development approaches between traditional software and ML systems.</p></li>
<li><p><strong>Explain why continuous feedback loops are crucial in the machine learning development lifecycle.</strong></p>
<p><em>Answer</em>: Continuous feedback loops are crucial in ML development because they allow insights from deployment to refine earlier stages such as data preparation and model design. For example, performance metrics from a deployed model can highlight areas for improvement in feature engineering. This is important because ML systems must adapt to changing data distributions and objectives, unlike traditional software.</p>
<p><em>Learning Objective</em>: Analyze the role of feedback loops in adapting ML systems to dynamic environments.</p></li>
<li><p><strong>Order the following dimensions of development lifecycle differences between traditional software and ML systems: (1) Deployment, (2) Testing and Validation, (3) Feedback Loops.</strong></p>
<p><em>Answer</em>: The correct order is: (2) Testing and Validation, (1) Deployment, (3) Feedback Loops. Testing in traditional software is deterministic, while ML requires statistical validation. Deployment in traditional systems is static, whereas ML systems adapt over time. Feedback loops are minimal in traditional development but frequent in ML to refine earlier stages.</p>
<p><em>Learning Objective</em>: Understand the sequence and interaction of lifecycle dimensions in ML versus traditional software development.</p></li>
</ol>
<p><a href="#quiz-question-sec-ai-workflow-ml-vs-traditional-software-development-0f90" class="answer-label">← Back to Questions</a></p>
</div></details>
</div>
<div id="quiz-answer-sec-ai-workflow-six-core-lifecycle-stages-fab9" class="callout callout-quiz-answer">
<details class="callout-quiz-answer fbx-answer closebutton"><summary><strong>Self-Check: Answer 1.4</strong></summary><div>
<ol type="1">
<li><p><strong>Which of the following best describes the purpose of the ‘Problem Definition’ stage in the ML lifecycle?</strong></p>
<ol type="a">
<li>To define objectives and constraints for the ML system.</li>
<li>To gather and clean data for model training.</li>
<li>To deploy the model into production environments.</li>
<li>To monitor the system’s performance post-deployment.</li>
</ol>
<p><em>Answer</em>: The correct answer is A. To define objectives and constraints for the ML system. This stage sets the foundation for all subsequent work by ensuring alignment between the system’s goals and desired outcomes. Other options describe different stages of the lifecycle.</p>
<p><em>Learning Objective</em>: Understand the role and importance of the ‘Problem Definition’ stage in the ML lifecycle.</p></li>
<li><p><strong>Order the following ML lifecycle stages from start to finish: (1) Deployment &amp; Integration, (2) Model Development &amp; Training, (3) Data Collection &amp; Preparation, (4) Monitoring &amp; Maintenance.</strong></p>
<p><em>Answer</em>: The correct order is: (3) Data Collection &amp; Preparation, (2) Model Development &amp; Training, (1) Deployment &amp; Integration, (4) Monitoring &amp; Maintenance. This sequence reflects the progression from data preparation to model training, deployment, and ongoing maintenance.</p>
<p><em>Learning Objective</em>: Understand the sequential order of ML lifecycle stages and their interdependencies.</p></li>
<li><p><strong>How does the feedback loop in the ML lifecycle contribute to the system’s adaptability and improvement?</strong></p>
<p><em>Answer</em>: The feedback loop allows insights from later stages, such as Monitoring &amp; Maintenance, to inform refinements in earlier stages like Data Collection &amp; Preparation. For example, if monitoring reveals performance issues, data preprocessing can be adjusted to improve model accuracy. This is important because it enables the system to adapt to changing requirements and data distributions.</p>
<p><em>Learning Objective</em>: Analyze the role of feedback loops in enhancing the adaptability and continuous improvement of ML systems.</p></li>
<li><p><strong>In the context of the DR screening system, which lifecycle stage likely involves ensuring model performance in real-world conditions?</strong></p>
<ol type="a">
<li>Problem Definition</li>
<li>Data Collection &amp; Preparation</li>
<li>Evaluation &amp; Validation</li>
<li>Monitoring &amp; Maintenance</li>
</ol>
<p><em>Answer</em>: The correct answer is C. Evaluation &amp; Validation. This stage involves testing the model’s performance against predefined metrics and validating its behavior in different scenarios to ensure it is accurate and robust in real-world conditions.</p>
<p><em>Learning Objective</em>: Connect lifecycle stages to practical applications in real-world ML systems, such as the DR screening system.</p></li>
</ol>
<p><a href="#quiz-question-sec-ai-workflow-six-core-lifecycle-stages-fab9" class="answer-label">← Back to Questions</a></p>
</div></details>
</div>
<div id="quiz-answer-sec-ai-workflow-problem-definition-stage-3e18" class="callout callout-quiz-answer">
<details class="callout-quiz-answer fbx-answer closebutton"><summary><strong>Self-Check: Answer 1.5</strong></summary><div>
<ol type="1">
<li><p><strong>How does problem definition in machine learning differ from traditional software development?</strong></p>
<ol type="a">
<li>It involves defining how the system should learn from data.</li>
<li>It focuses solely on deterministic specifications.</li>
<li>It requires no consideration of real-world constraints.</li>
<li>It is based on fixed input-output rules.</li>
</ol>
<p><em>Answer</em>: The correct answer is A. It involves defining how the system should learn from data. ML problem definition requires understanding how a system learns from data, unlike traditional software which relies on deterministic rules.</p>
<p><em>Learning Objective</em>: Understand the fundamental differences between ML and traditional software problem definitions.</p></li>
<li><p><strong>Why is it crucial to align problem definition with real-world constraints in ML system development?</strong></p>
<p><em>Answer</em>: Aligning problem definition with real-world constraints ensures the system is practical and effective in its deployment environment. For example, a diabetic retinopathy screening system must consider diagnostic accuracy, hardware limitations, and regulatory compliance. This alignment is important because it influences data collection, model design, and deployment strategies.</p>
<p><em>Learning Objective</em>: Explain the importance of considering real-world constraints in the problem definition of ML systems.</p></li>
<li><p><strong>In ML systems, the process of translating business objectives into learning objectives is known as ____.</strong></p>
<p><em>Answer</em>: problem formulation. This process is crucial in defining how a system will learn and achieve business goals.</p>
<p><em>Learning Objective</em>: Recall the term for translating business objectives into learning objectives in ML systems.</p></li>
<li><p><strong>Which of the following best describes a key challenge in scaling ML systems?</strong></p>
<ol type="a">
<li>Data homogeneity across all environments.</li>
<li>Consistent model performance without additional tuning.</li>
<li>Data heterogeneity and infrastructure requirements.</li>
<li>Simplified monitoring infrastructure compared to traditional applications.</li>
</ol>
<p><em>Answer</em>: The correct answer is C. Data heterogeneity and infrastructure requirements. Scaling ML systems involves managing diverse data and complex infrastructure, unlike traditional software.</p>
<p><em>Learning Objective</em>: Identify challenges specific to scaling ML systems compared to traditional software.</p></li>
<li><p><strong>In a production system, how might problem definition influence the choice of deployment infrastructure?</strong></p>
<p><em>Answer</em>: Problem definition influences deployment infrastructure by dictating requirements such as computational efficiency and reliability. For instance, a DR screening system in rural clinics must operate on limited hardware and intermittent internet. This is important because it ensures the system is feasible and effective in its intended environment.</p>
<p><em>Learning Objective</em>: Analyze how problem definition impacts deployment infrastructure decisions in ML systems.</p></li>
</ol>
<p><a href="#quiz-question-sec-ai-workflow-problem-definition-stage-3e18" class="answer-label">← Back to Questions</a></p>
</div></details>
</div>
<div id="quiz-answer-sec-ai-workflow-data-collection-preparation-stage-a0aa" class="callout callout-quiz-answer">
<details class="callout-quiz-answer fbx-answer closebutton"><summary><strong>Self-Check: Answer 1.6</strong></summary><div>
<ol type="1">
<li><p><strong>Which of the following best describes a major challenge in data collection for medical AI systems like diabetic retinopathy screening?</strong></p>
<ol type="a">
<li>Ensuring high-resolution images are captured consistently.</li>
<li>Reducing the cost of expert annotation.</li>
<li>Balancing statistical rigor with operational feasibility.</li>
<li>Maximizing the number of images collected daily.</li>
</ol>
<p><em>Answer</em>: The correct answer is C. Balancing statistical rigor with operational feasibility. This is correct because medical AI systems require data that meets high standards for diagnostic accuracy while being practical to collect in real-world settings. Other options do not fully capture the dual challenge of rigor and feasibility.</p>
<p><em>Learning Objective</em>: Understand the specific challenges of data collection in medical AI systems.</p></li>
<li><p><strong>How does the data volume constraint in rural clinics influence architectural decisions in ML systems?</strong></p>
<p><em>Answer</em>: Data volume constraints in rural clinics necessitate edge-computing solutions to reduce bandwidth requirements. For example, local preprocessing can decrease weekly data transmission from 15 GB to 750 MB, but requires more local computational resources. This is important because it shapes the deployment strategy and hardware requirements.</p>
<p><em>Learning Objective</em>: Analyze how infrastructure constraints drive architectural decisions in ML deployments.</p></li>
<li><p><strong>Order the following steps involved in the data collection process for a medical AI system: (1) Initial processing and storage, (2) Data capture, (3) Quality validation, (4) Secure transmission.</strong></p>
<p><em>Answer</em>: The correct order is: (2) Data capture, (1) Initial processing and storage, (3) Quality validation, (4) Secure transmission. This sequence reflects the logical flow from capturing data to ensuring its quality and securely transmitting it for further use.</p>
<p><em>Learning Objective</em>: Understand the sequential steps in the data collection workflow for medical AI systems.</p></li>
<li><p><strong>What is a key reason for using federated learning in the data collection strategy for medical AI systems?</strong></p>
<ol type="a">
<li>To improve model accuracy by centralizing data.</li>
<li>To comply with patient privacy regulations.</li>
<li>To reduce the cost of data annotation.</li>
<li>To increase the speed of data processing.</li>
</ol>
<p><em>Answer</em>: The correct answer is B. To comply with patient privacy regulations. This is correct because federated learning allows model training without centralizing sensitive patient data, which is crucial for meeting privacy requirements.</p>
<p><em>Learning Objective</em>: Understand the role of federated learning in addressing privacy concerns in data collection.</p></li>
</ol>
<p><a href="#quiz-question-sec-ai-workflow-data-collection-preparation-stage-a0aa" class="answer-label">← Back to Questions</a></p>
</div></details>
</div>
<div id="quiz-answer-sec-ai-workflow-model-development-training-stage-05ec" class="callout callout-quiz-answer">
<details class="callout-quiz-answer fbx-answer closebutton"><summary><strong>Self-Check: Answer 1.7</strong></summary><div>
<ol type="1">
<li><p><strong>Which of the following best describes the trade-off between model accuracy and deployment feasibility in the context of edge devices?</strong></p>
<ol type="a">
<li>Increasing model accuracy always improves deployment feasibility.</li>
<li>Model accuracy and deployment feasibility are unrelated aspects of model development.</li>
<li>Deployment feasibility is independent of model accuracy.</li>
<li>Higher model accuracy often requires more computational resources, which can hinder deployment on edge devices.</li>
</ol>
<p><em>Answer</em>: The correct answer is D. Higher model accuracy often requires more computational resources, which can hinder deployment on edge devices. This is because edge devices have limited computational capacity, and optimizing for accuracy alone can lead to models that are too large or slow for practical deployment.</p>
<p><em>Learning Objective</em>: Understand the trade-offs between model accuracy and deployment feasibility in edge device scenarios.</p></li>
<li><p><strong>Explain how model compression techniques like quantization and pruning help in meeting deployment constraints for edge devices.</strong></p>
<p><em>Answer</em>: Model compression techniques such as quantization and pruning reduce the size and computational requirements of models, making them suitable for deployment on resource-constrained edge devices. Quantization reduces numerical precision, while pruning removes unnecessary parameters, both of which help maintain performance while fitting within hardware limits. In practice, these techniques enable models to run efficiently without sacrificing significant accuracy, crucial for real-time applications.</p>
<p><em>Learning Objective</em>: Explain the role of model compression techniques in optimizing models for edge deployment.</p></li>
<li><p><strong>The process of training a smaller model to mimic the behavior of a larger model is known as ____. This technique helps in reducing model size while maintaining accuracy.</strong></p>
<p><em>Answer</em>: knowledge distillation. This technique helps in reducing model size while maintaining accuracy by transferring learned knowledge from a large ‘teacher’ model to a smaller ‘student’ model.</p>
<p><em>Learning Objective</em>: Recall the concept and purpose of knowledge distillation in model development.</p></li>
<li><p><strong>Order the following steps in optimizing a model for edge deployment: (1) Initial model training, (2) Model compression, (3) Performance evaluation, (4) Deployment testing.</strong></p>
<p><em>Answer</em>: The correct order is: (1) Initial model training, (3) Performance evaluation, (2) Model compression, (4) Deployment testing. Initially, the model is trained, then its performance is evaluated. Compression techniques are applied to meet deployment constraints, followed by testing to ensure the model functions correctly in the deployment environment.</p>
<p><em>Learning Objective</em>: Understand the sequence of steps involved in optimizing a model for deployment on edge devices.</p></li>
<li><p><strong>In a production system, how might the choice of model architecture impact the system’s operational constraints?</strong></p>
<p><em>Answer</em>: The choice of model architecture directly affects the system’s operational constraints such as computational load, memory usage, and latency. For example, a complex architecture might offer high accuracy but require more resources, making it unsuitable for edge devices. Conversely, a simpler architecture might meet operational constraints but at the cost of reduced accuracy. Balancing these aspects is crucial for effective deployment. This is important because operational constraints dictate the feasibility and efficiency of deploying models in real-world environments.</p>
<p><em>Learning Objective</em>: Analyze the impact of model architecture choices on operational constraints in production systems.</p></li>
</ol>
<p><a href="#quiz-question-sec-ai-workflow-model-development-training-stage-05ec" class="answer-label">← Back to Questions</a></p>
</div></details>
</div>
<div id="quiz-answer-sec-ai-workflow-deployment-integration-stage-7f90" class="callout callout-quiz-answer">
<details class="callout-quiz-answer fbx-answer closebutton"><summary><strong>Self-Check: Answer 1.8</strong></summary><div>
<ol type="1">
<li><p><strong>Which of the following is a primary reason for choosing edge deployment over cloud deployment in rural clinics?</strong></p>
<ol type="a">
<li>To increase model complexity</li>
<li>To leverage cloud computing resources</li>
<li>To reduce latency and ensure reliability despite intermittent connectivity</li>
<li>To simplify the deployment process</li>
</ol>
<p><em>Answer</em>: The correct answer is C. To reduce latency and ensure reliability despite intermittent connectivity. Edge deployment allows models to run locally, which is crucial in environments with unreliable internet connectivity, ensuring timely and reliable model predictions.</p>
<p><em>Learning Objective</em>: Understand the trade-offs between edge and cloud deployment in specific environments.</p></li>
<li><p><strong>Explain how deployment requirements in rural clinics influence the choice of model optimization techniques.</strong></p>
<p><em>Answer</em>: Deployment in rural clinics requires models to be optimized for limited computational resources and intermittent connectivity. Techniques like model quantization and pruning reduce model size and computational load, ensuring that the model fits within hardware constraints while maintaining performance. This is important because it allows the model to operate effectively in resource-constrained environments.</p>
<p><em>Learning Objective</em>: Analyze how environmental constraints dictate model optimization strategies.</p></li>
<li><p><strong>Order the following steps in the deployment workflow: (1) Pilot site rollout, (2) Simulated environment testing, (3) Full-scale rollout.</strong></p>
<p><em>Answer</em>: The correct order is: (2) Simulated environment testing, (1) Pilot site rollout, (3) Full-scale rollout. Simulated testing helps identify potential issues, pilot rollouts provide real-world feedback, and full-scale rollout ensures widespread implementation.</p>
<p><em>Learning Objective</em>: Understand the sequential steps involved in deploying a model to production.</p></li>
<li><p><strong>What is a key challenge when integrating an ML system with existing hospital information systems (HIS)?</strong></p>
<ol type="a">
<li>Maintaining secure data handling and compatibility</li>
<li>Ensuring the model is interpretable</li>
<li>Increasing the model’s accuracy</li>
<li>Reducing the model’s training time</li>
</ol>
<p><em>Answer</em>: The correct answer is A. Maintaining secure data handling and compatibility. Integration with HIS requires secure data management to comply with privacy regulations and ensure seamless data exchange.</p>
<p><em>Learning Objective</em>: Identify integration challenges between ML systems and existing infrastructure.</p></li>
</ol>
<p><a href="#quiz-question-sec-ai-workflow-deployment-integration-stage-7f90" class="answer-label">← Back to Questions</a></p>
</div></details>
</div>
<div id="quiz-answer-sec-ai-workflow-monitoring-maintenance-stage-c6f7" class="callout callout-quiz-answer">
<details class="callout-quiz-answer fbx-answer closebutton"><summary><strong>Self-Check: Answer 1.9</strong></summary><div>
<ol type="1">
<li><p><strong>Which of the following best describes the primary purpose of monitoring in ML systems?</strong></p>
<ol type="a">
<li>To maintain static behavior of the system.</li>
<li>To eliminate the need for human oversight.</li>
<li>To ensure deterministic outputs from the system.</li>
<li>To detect and adapt to data and model drift.</li>
</ol>
<p><em>Answer</em>: The correct answer is D. To detect and adapt to data and model drift. Monitoring is essential for identifying changes in data distributions and model performance, allowing the system to adapt and maintain reliability.</p>
<p><em>Learning Objective</em>: Understand the role of monitoring in identifying and adapting to changes in ML systems.</p></li>
<li><p><strong>Explain how data drift can impact the performance of a machine learning model in production.</strong></p>
<p><em>Answer</em>: Data drift impacts ML models by altering the input data distribution from what the model was trained on, leading to potential performance degradation. For example, if user behavior changes, the model may make less accurate predictions. This is important because it necessitates ongoing monitoring and potential model retraining to maintain accuracy.</p>
<p><em>Learning Objective</em>: Analyze the effects of data drift on ML model performance and the need for continuous monitoring.</p></li>
<li><p><strong>Order the following steps in a typical ML maintenance workflow: (1) Model Retraining, (2) Data Drift Detection, (3) Performance Monitoring, (4) Feedback Loop Initiation.</strong></p>
<p><em>Answer</em>: The correct order is: (3) Performance Monitoring, (2) Data Drift Detection, (4) Feedback Loop Initiation, (1) Model Retraining. Monitoring identifies performance issues, drift detection confirms the cause, feedback loops trigger necessary actions, and retraining updates the model.</p>
<p><em>Learning Objective</em>: Understand the sequence of steps involved in maintaining ML systems in production.</p></li>
<li><p><strong>What are the benefits of implementing proactive maintenance strategies in ML systems?</strong></p>
<p><em>Answer</em>: Proactive maintenance prevents issues before they impact operations by using predictive models to identify potential problems early. For example, continuous learning pipelines can adapt models to new data trends. This ensures system reliability and performance, reducing downtime and maintaining service quality.</p>
<p><em>Learning Objective</em>: Evaluate the advantages of proactive maintenance in ensuring ML system reliability and performance.</p></li>
</ol>
<p><a href="#quiz-question-sec-ai-workflow-monitoring-maintenance-stage-c6f7" class="answer-label">← Back to Questions</a></p>
</div></details>
</div>
<div id="quiz-answer-sec-ai-workflow-integrating-systems-thinking-principles-6bfc" class="callout callout-quiz-answer">
<details class="callout-quiz-answer fbx-answer closebutton"><summary><strong>Self-Check: Answer 1.10</strong></summary><div>
<ol type="1">
<li><p><strong>Which of the following best illustrates the concept of constraint propagation in AI development?</strong></p>
<ol type="a">
<li>Using high-capacity networks to improve model accuracy.</li>
<li>Deploying models on edge devices to reduce latency.</li>
<li>Adjusting data preprocessing pipelines due to bandwidth limitations.</li>
<li>Increasing model size to enhance performance.</li>
</ol>
<p><em>Answer</em>: The correct answer is C. Adjusting data preprocessing pipelines due to bandwidth limitations. This illustrates constraint propagation because an initial constraint (bandwidth limitation) influences subsequent stages like data preprocessing.</p>
<p><em>Learning Objective</em>: Understand how constraint propagation affects various stages of AI system development.</p></li>
<li><p><strong>Explain how multi-scale feedback loops contribute to the robustness of an AI system.</strong></p>
<p><em>Answer</em>: Multi-scale feedback loops contribute to robustness by enabling quick correction of operational issues through rapid loops and strategic adaptation through slower loops. For example, minute-level loops can detect and correct misconfigured cameras, while monthly loops can identify demographic shifts requiring data expansion. This prevents both overreaction to daily fluctuations and underreaction to meaningful trends.</p>
<p><em>Learning Objective</em>: Analyze the role of feedback loops in maintaining AI system robustness.</p></li>
<li><p><strong>In managing emergent complexity, what is a key difference between ML systems and traditional software systems?</strong></p>
<ol type="a">
<li>ML systems require monitoring for data drift and model bias.</li>
<li>Traditional systems exhibit probabilistic degradation.</li>
<li>ML systems rely on deterministic processes.</li>
<li>Traditional systems focus on hardware performance.</li>
</ol>
<p><em>Answer</em>: The correct answer is A. ML systems require monitoring for data drift and model bias. Unlike traditional systems, ML systems exhibit probabilistic degradation through data drift and bias, necessitating different monitoring approaches.</p>
<p><em>Learning Objective</em>: Differentiate between emergent complexity in ML systems and traditional software systems.</p></li>
<li><p><strong>Discuss the trade-offs involved in resource optimization for ML systems, using the DR case study as an example.</strong></p>
<p><em>Answer</em>: Resource optimization involves trade-offs like model accuracy versus deployment cost. In the DR case, increasing accuracy from 94.8% to 95.2% requires larger models, leading to higher hardware costs. This illustrates non-linear relationships where small accuracy gains can result in significant cost increases, highlighting the need for strategic decision-making.</p>
<p><em>Learning Objective</em>: Evaluate resource optimization trade-offs in ML system development.</p></li>
</ol>
<p><a href="#quiz-question-sec-ai-workflow-integrating-systems-thinking-principles-6bfc" class="answer-label">← Back to Questions</a></p>
</div></details>
</div>
<div id="quiz-answer-sec-ai-workflow-fallacies-pitfalls-6c5b" class="callout callout-quiz-answer">
<details class="callout-quiz-answer fbx-answer closebutton"><summary><strong>Self-Check: Answer 1.11</strong></summary><div>
<ol type="1">
<li><p><strong>True or False: Machine learning development can effectively follow traditional software engineering workflows without any modifications.</strong></p>
<p><em>Answer</em>: False. ML development introduces uncertainties and requires specialized workflows for data validation and iterative model refinement.</p>
<p><em>Learning Objective</em>: Understand the fallacy of applying traditional software engineering workflows to ML development.</p></li>
<li><p><strong>Which of the following is a common pitfall in ML development?</strong></p>
<ol type="a">
<li>Using agile methodologies for iterative development.</li>
<li>Treating data preparation as a one-time preprocessing step.</li>
<li>Incorporating feedback loops in the ML lifecycle.</li>
<li>Ensuring continuous data validation and monitoring.</li>
</ol>
<p><em>Answer</em>: The correct answer is B. Treating data preparation as a one-time preprocessing step. This is a pitfall because it ignores the dynamic nature of real-world data, leading to model degradation.</p>
<p><em>Learning Objective</em>: Identify common pitfalls in ML development workflows.</p></li>
<li><p><strong>Explain why model performance in development environments may not accurately predict production performance.</strong></p>
<p><em>Answer</em>: Development environments often use clean datasets and controlled resources, creating artificial conditions. In contrast, production systems face data quality issues, latency constraints, and adversarial inputs. For example, a model might perform well in a controlled setting but fail in production due to unexpected data variations. This is important because it highlights the need for robust deployment practices.</p>
<p><em>Learning Objective</em>: Analyze the discrepancy between development and production performance in ML systems.</p></li>
<li><p><strong>The belief that achieving good metrics during development ensures successful deployment is a common ____. This assumption overlooks the differences between development and production environments.</strong></p>
<p><em>Answer</em>: fallacy. This assumption overlooks the differences between development and production environments.</p>
<p><em>Learning Objective</em>: Recall specific fallacies related to ML system development.</p></li>
<li><p><strong>In a production system, how might you address the pitfall of skipping systematic validation stages to accelerate development timelines?</strong></p>
<p><em>Answer</em>: To address this pitfall, integrate validation throughout the development process rather than treating it as a final step. For example, incorporate benchmarking and evaluation at each stage. This is important because it prevents hidden biases and poor generalization, which are costly to fix post-deployment.</p>
<p><em>Learning Objective</em>: Apply strategies to mitigate common pitfalls in ML development workflows.</p></li>
</ol>
<p><a href="#quiz-question-sec-ai-workflow-fallacies-pitfalls-6c5b" class="answer-label">← Back to Questions</a></p>
</div></details>
</div>
<div id="quiz-answer-sec-ai-workflow-summary-84ad" class="callout callout-quiz-answer">
<details class="callout-quiz-answer fbx-answer closebutton"><summary><strong>Self-Check: Answer 1.12</strong></summary><div>
<ol type="1">
<li><p><strong>Which of the following best describes the role of feedback loops in the ML lifecycle?</strong></p>
<ol type="a">
<li>They enable continuous improvement by refining data and model performance.</li>
<li>They provide a mechanism for error correction in static systems.</li>
<li>They are used to validate models before deployment.</li>
<li>They ensure that the ML lifecycle is a linear process.</li>
</ol>
<p><em>Answer</em>: The correct answer is A. They enable continuous improvement by refining data and model performance. Feedback loops are crucial for adapting and improving ML systems based on deployment insights, distinguishing ML from traditional software development.</p>
<p><em>Learning Objective</em>: Understand the function and importance of feedback loops in the ML lifecycle.</p></li>
<li><p><strong>Explain how the interconnection between data and model pipelines contributes to the success of machine learning systems.</strong></p>
<p><em>Answer</em>: The interconnection between data and model pipelines allows for continuous feedback and refinement, ensuring that data quality directly influences model performance. For example, insights from model deployment can trigger data collection adjustments, leading to improved model accuracy. This is important because it enables adaptive learning and system optimization.</p>
<p><em>Learning Objective</em>: Analyze the relationship between data and model pipelines and its impact on system success.</p></li>
<li><p><strong>Order the following stages of the ML lifecycle from data collection to deployment: (1) Model Training, (2) Data Preparation, (3) Model Evaluation, (4) Data Collection, (5) Deployment.</strong></p>
<p><em>Answer</em>: The correct order is: (4) Data Collection, (2) Data Preparation, (1) Model Training, (3) Model Evaluation, (5) Deployment. This sequence reflects the progression from gathering raw data to preparing it for use, training and evaluating models, and finally deploying them.</p>
<p><em>Learning Objective</em>: Understand the sequential stages of the ML lifecycle and their logical progression.</p></li>
<li><p><strong>True or False: The ML lifecycle is characterized by deterministic specifications and static behavior.</strong></p>
<p><em>Answer</em>: False. The ML lifecycle is characterized by probabilistic optimization and dynamic adaptation, which are essential for handling the complexities of machine learning systems.</p>
<p><em>Learning Objective</em>: Differentiate between the characteristics of ML systems and traditional software systems.</p></li>
</ol>
<p><a href="#quiz-question-sec-ai-workflow-summary-84ad" class="answer-label">← Back to Questions</a></p>
</div></details>
</div>

</section>
</section>


<a onclick="window.scrollTo(0, 0); return false;" role="button" id="quarto-back-to-top"><i class="bi bi-arrow-up"></i> Back to top</a></main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    // Ensure there is a toggle, if there isn't float one in the top right
    if (window.document.querySelector('.quarto-color-scheme-toggle') === null) {
      const a = window.document.createElement('a');
      a.classList.add('top-right');
      a.classList.add('quarto-color-scheme-toggle');
      a.href = "";
      a.onclick = function() { try { window.quartoToggleColorScheme(); } catch {} return false; };
      const i = window.document.createElement("i");
      i.classList.add('bi');
      a.appendChild(i);
      window.document.body.appendChild(a);
    }
    setColorSchemeToggle(hasAlternateSentinel())
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
        const codeEl = trigger.previousElementSibling.cloneNode(true);
        for (const childEl of codeEl.children) {
          if (isCodeAnnotation(childEl)) {
            childEl.remove();
          }
        }
        return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp('/' + window.location.host + '/');
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
            // target, if specified
            link.setAttribute("target", "_blank");
            if (link.getAttribute("rel") === null) {
              link.setAttribute("rel", "noopener");
            }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
  });
  </script>
<nav class="page-navigation">
  <div class="nav-page nav-page-previous">
      <a href="../../../contents/core/dnn_architectures/dnn_architectures.html" class="pagination-link" aria-label="DNN Architectures">
        <i class="bi bi-arrow-left-short"></i> <span class="nav-page-text">DNN Architectures</span>
      </a>          
  </div>
  <div class="nav-page nav-page-next">
      <a href="../../../contents/core/data_engineering/data_engineering.html" class="pagination-link" aria-label="Data Engineering">
        <span class="nav-page-text">Data Engineering</span> <i class="bi bi-arrow-right-short"></i>
      </a>
  </div>
</nav>
</div> <!-- /content -->
<footer class="footer">
  <div class="nav-footer">
    <div class="nav-footer-left">
<p>© 2024 Harvard University. Licensed under <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC-BY-NC-SA 4.0</a></p>
</div>   
    <div class="nav-footer-center">
<p>Written, edited and curated by Prof.&nbsp;Vijay Janapa Reddi (Harvard University)</p>
</div>
    <div class="nav-footer-right">
      <ul class="footer-items list-unstyled">
    <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/harvard-edge/cs249r_book">
      <i class="bi bi-github" role="img" aria-label="View source on GitHub">
</i> 
    </a>
  </li>  
    <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/harvard-edge/cs249r_book">
      <i class="bi bi-star" role="img" aria-label="Star this repository">
</i> 
    </a>
  </li>  
    <li class="nav-item">
    <a class="nav-link" href="https://www.netlify.com">
<p><img src="https://www.netlify.com/v3/img/components/netlify-color-accent.svg" alt="Deploys by Netlify" style="height: 15px; vertical-align: middle; margin-left: 3px;"></p>
</a>
  </li>  
</ul>
    </div>
  </div>
</footer>
<script>var lightboxQuarto = GLightbox({"closeEffect":"zoom","descPosition":"bottom","loop":false,"openEffect":"zoom","selector":".lightbox"});
(function() {
  let previousOnload = window.onload;
  window.onload = () => {
    if (previousOnload) {
      previousOnload();
    }
    lightboxQuarto.on('slide_before_load', (data) => {
      const { slideIndex, slideNode, slideConfig, player, trigger } = data;
      const href = trigger.getAttribute('href');
      if (href !== null) {
        const imgEl = window.document.querySelector(`a[href="${href}"] img`);
        if (imgEl !== null) {
          const srcAttr = imgEl.getAttribute("src");
          if (srcAttr && srcAttr.startsWith("data:")) {
            slideConfig.href = srcAttr;
          }
        }
      } 
    });
  
    lightboxQuarto.on('slide_after_load', (data) => {
      const { slideIndex, slideNode, slideConfig, player, trigger } = data;
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(slideNode);
      }
    });
  
  };
  
})();
          </script>




</body></html>